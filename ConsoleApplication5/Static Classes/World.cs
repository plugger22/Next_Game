using System;
using System.Collections.Generic;
using Next_Game.Cartographic;
using System.Linq;
using RLNET;
using System.Diagnostics;

namespace Next_Game
{
    //handles living world for the game (data generated by History.cs at game start)
    public class World
    {
        static Random rnd;
        private int seed;
        private List<Move> listMoveObjects; //actors moving through the world
        private List<ActorSpy> listTempActiveActors; //bloodhound temp lists
        private List<ActorSpy> listTempEnemyActors; //bloodhound temp lists
        private List<HorseRecord> listHorses; //record of all Player's past horses
        //private int[,] arrayAI; //'0' -> # enemies at capital, '1,2,3,4' -> # enemies patrolling each branch, [0,] -> actual, [1,] -> desired [2,] -> temp data
        private int[] arrayTradeData; //0 -> Total Wealth, 1 # of Food, 2 # Iron, 3 # Timber, 4 # Gold, 5 # Wine, 6 # Oil, 7 # Wool, 8 # Furs
        private readonly Queue<Snippet> messageQueue; //short term queue to display recent messages
        private Dictionary<int, Active> dictActiveActors; //list of all Player controlled actors keyed off actorID (non-activated followers aren't in dictionary)
        private Dictionary<int, Passive> dictPassiveActors; //list of all NPC actors keyed of actorID
        private Dictionary<int, Enemy> dictEnemyActors; //list of all Enemy actors keyed of actorID
        private Dictionary<int, Special> dictSpecialActors; //list of all Special NPC actors -> key is SpecialID
        private Dictionary<int, Actor> dictAllActors; //list of all Actors keyed of actorID
        private Dictionary<int, MajorHouse> dictMajorHouses; //list of all Greathouses keyed off houseID (Does NOT contain CapitalHouse)
        private Dictionary<int, House> dictAllHouses; //list of all houses & special locations keyed off RefID (Does contain CapitalHouse)
        private Dictionary<int, int> dictMajorHouseID; //list of Great Houses, unsorted (Key is House ID, value is # of bannerlords)
        private Dictionary<int, int> dictHousePower; // list of Great Houses, Sorted (key is House ID, value is # of bannerlords (power))
        private Dictionary<int, Record> dictHistoricalRecords; //all historical records (including Players) in a central collection (key is trackerID)
        private Dictionary<int, Record> dictCurrentRecords; //all current records (non-Player) in a central collection (key is trackerID)
        private Dictionary<int, Record> dictPlayerRecords; //all current Player records, (key is trackerID)
        private Dictionary<int, Message> dictMessages; //all Player to Game & Game to Player messages
        private Dictionary<int, GeoCluster> dictGeoClusters; //all GeoClusters (key is geoID)
        private Dictionary<int, Skill> dictTraits; //all triats (key is traitID)
        private Dictionary<int, Rumour> dictRumoursNormal; //all normal rumours (key is rumourID)
        private Dictionary<int, Rumour> dictRumoursTimed; //all timed (TimerExpire > 0) rumours (key is rumourID)
        private Dictionary<int, Rumour> dictRumoursInactive; //all inactive (TimerStart > 0) rumours (key is rumourId)
        private Dictionary<int, Rumour> dictRumoursKnown; //all rumours known to the Player (key is rumourID)
        private Dictionary<int, Possession> dictPossessions; //all possession (key is PossID)
        private Dictionary<int, Passive> dictRoyalCourt; //advisors and royal retainers (assumed to always be at Kingskeep) excludes family
        private Dictionary<int, Passive> dictRoyalBackUp; //Act 2 Reference list of New King royal family & advisors (populated at completion of Act 1), key is ActID
        private Dictionary<int, int> dictConvertLocToRef; //dictionary to convert LocID's to RefID's (key is LocID, value is RefID)
        private Dictionary<int, int> dictConvertRefToLoc; //dictionary to convert RefID's to LocID's (key is RefID, value is LocID)
        private Dictionary<int, int> dictConvertRefToHouse; //dictionary to convert RefID's to HouseID's (key is RefID, value is HouseID)
        private Dictionary<int, BloodHound> dictBloodHound; //dictionary of all active & enemy actors movements (key is Turn #)

        //default constructor
        /// <summary>
        /// o
        /// </summary>
        /// <param name="seed"></param>
        public World(int seed)
        {
            this.seed = seed;
            rnd = new Random(seed);
            listMoveObjects = new List<Move>();
            listTempActiveActors = new List<ActorSpy>();
            listTempEnemyActors = new List<ActorSpy>();
            listHorses = new List<HorseRecord>();
            //arrayAI = new int[3, 5];
            arrayTradeData = new int[(int)Goods.Count];
            messageQueue = new Queue<Snippet>();
            dictActiveActors = new Dictionary<int, Active>();
            dictPassiveActors = new Dictionary<int, Passive>();
            dictEnemyActors = new Dictionary<int, Enemy>();
            dictSpecialActors = new Dictionary<int, Special>();
            dictAllActors = new Dictionary<int, Actor>();
            dictRoyalBackUp = new Dictionary<int, Passive>();
            dictMajorHouses = new Dictionary<int, MajorHouse>();
            dictAllHouses = new Dictionary<int, House>();
            dictMajorHouseID = new Dictionary<int, int>();
            dictHousePower = new Dictionary<int, int>();
            dictHistoricalRecords = new Dictionary<int, Record>();
            dictCurrentRecords = new Dictionary<int, Record>();
            dictPlayerRecords = new Dictionary<int, Record>();
            dictMessages = new Dictionary<int, Message>();
            dictGeoClusters = new Dictionary<int, GeoCluster>();
            dictTraits = new Dictionary<int, Skill>();
            dictRumoursNormal = new Dictionary<int, Rumour>();
            dictRumoursTimed = new Dictionary<int, Rumour>();
            dictRumoursInactive = new Dictionary<int, Rumour>();
            dictRumoursKnown = new Dictionary<int, Rumour>();
            dictPossessions = new Dictionary<int, Possession>();
            dictRoyalCourt = new Dictionary<int, Passive>();
            dictConvertLocToRef = new Dictionary<int, int>();
            dictConvertRefToLoc = new Dictionary<int, int>();
            dictConvertRefToHouse = new Dictionary<int, int>();
            dictBloodHound = new Dictionary<int, BloodHound>();
        }


        /// <summary>
        /// main method to initialise all world collections
        /// </summary>
        public void InitialiseWorld()
        {
            Game.logStart?.Write("--- InitialiseWorld (World.cs)");
            Stopwatch timer_2 = new Stopwatch();
            timer_2.Start();
            InitialiseGeoClusters();
            Game.StopTimer(timer_2, "W: InitialiseGeoClusters");
            timer_2.Start();
            InitialiseHouses();
            Game.StopTimer(timer_2, "W: InitialiseHouses");
            timer_2.Start();
            InitialiseItems();
            InitialiseActiveActors(Game.history.GetActiveActors());
            Game.StopTimer(timer_2, "W: InitiatePlayerActors");
            timer_2.Start();
            InitialiseTraits();
            Game.StopTimer(timer_2, "W: InitialiseTraits");
            timer_2.Start();
            //need to be here for sequencing issues
            Game.history.InitialiseOverthrow(dictPassiveActors);
            Game.history.InitialisePastHistoryHouses();
            Game.history.InitialiseLordRelations();
            Game.history.InitialiseSpecialCharacters(Game.file.GetCharacters("Characters.txt"));
            Game.history.InitialiseBeasts(Game.file.GetFollowers("Beasts.txt"));
            Game.StopTimer(timer_2, "W: InitialiseHistory");
            timer_2.Start();
            InitialiseHouseData(); //needs to be BEFORE InitialiseDesires but AFTER InitialiseOverthrow
            InitialiseConversionDicts(); //needs to be AFTER history methods (above) & BEFORE InitialiseEnemyActors (below)
            InitialiseSecrets();
            InitialiseDesires();
            InitialiseSafeHouses();
            InitialiseDisguises();
            Game.StopTimer(timer_2, "W: InitialiseVarious");
            timer_2.Start();
            //Game.ai.SetAI(); -> moved to ai.cs
            //Game.ai.InitialiseEnemyActors(); -> moved to ai.cs
            InitialiseItemPlacement();
            InitialiseLocTypes();
            Game.StopTimer(timer_2, "W: InitialiseAI");
        }

        /// <summary>
        /// Sets up actors in dictionaries and places them on the map.
        /// </summary>
        /// <param name="listOfActiveActors"></param>
        internal void InitialiseActiveActors(List<Active> listOfActiveActors)
        {
            Game.logStart?.Write("--- InitialiseActiveActors (World.cs)");
            int numFollowers = Game.constant.GetValue(Global.START_FOLLOWERS);
            int locID, index;

            for (int i = 0; i <= numFollowers; i++)
            {
                if (i > 0)
                {
                    //choose a random follower
                    index = rnd.Next(0, listOfActiveActors.Count);
                    Follower follower = (Follower)listOfActiveActors[index];
                    if (follower != null)
                    {
                        //remove from list
                        listOfActiveActors.RemoveAt(index);
                        //add to list and Dictionaries in World
                        SetActiveActor(follower);
                        //assign to random location on map
                        locID = Game.network.GetRandomLocation();
                        Location loc = Game.network.GetLocation(locID);
                        if (loc != null)
                        {
                            //place characters at Location
                            follower.LocID = locID;
                            follower.LastKnownLocID = locID;
                            follower.SetPosition(loc.GetPosition());
                            //set to activated
                            follower.Activated = true;
                            //add to Location list of Characters
                            loc.AddActor(follower.ActID);
                            Game.logStart?.Write($"Follower {follower.Name}, ActorID {follower.ActID}, added and placed at {loc.LocName}, LocID {loc.LocationID}");
                        }
                        else { Game.SetError(new Error(63, "Invalid Loc (null) Active Actor not placed on map")); }
                    }
                    else
                    { Game.SetError(new Error(63, "Invalid Actor in listOfActiveActors")); }
                }
                else
                {
                    //player (first in list)
                    Player player = (Player)listOfActiveActors[0];
                    if (player != null)
                    {
                        //player goes in first
                        SetActiveActor(player);
                        listOfActiveActors.RemoveAt(0);
                        //assign to random location on map -> EDIT: Already done in history.cs InitialisePlayer

                        //DEBUG ---- (start) ---
                        //
                        //Add an random, active, Item to the Player at game start that has a challenge effect
                        List<Possession> listPossessions = new List<Possession>(dictPossessions.Values);
                        List<Item> listItems = new List<Item>();
                        {
                            for (int k = 0; k < listPossessions.Count; k++)
                            {
                                Possession possObject = listPossessions[k];
                                if (possObject.Active == true && possObject is Item)
                                {
                                    Item itemObject = possObject as Item;
                                    if (itemObject.ChallengeFlag == true)
                                    { listItems.Add(itemObject); }
                                }
                            }
                        }
                        //randomly choose one item from list
                        if (listItems.Count > 0)
                        {
                            int rndIndex = rnd.Next(listItems.Count);
                            int itemID = listItems[rndIndex].PossID;
                            if (itemID > 0)
                            {
                                player.AddItem(itemID);
                                Game.logStart?.Write(string.Format("[Item] {0}, PossID {1}, ItemID {2} added to Player's Inventory", listItems[rndIndex].Description, listItems[rndIndex].PossID,
                                    listItems[rndIndex].ItemID));
                            }
                        }
                        /*//Create a disguise, add to dictionary, give to Player
                        Disguise disguise = new Disguise("a Novice belonging to the Holy Faith", 2);
                        AddPossession(disguise.PossID, disguise);
                        player.ConcealDisguise = disguise.PossID;
                        Game.logStart?.Write($"[Disguise] \"{disguise.Description}\", PossID {disguise.PossID}, added to the Player's Inventory");*/
                        //
                        //DEBUG --- (end) ---
                    }
                    else
                    { Game.SetError(new Error(63, "Invalid Player in listOfActiveActors")); }
                }
            }
            //get list of Inns
            IEnumerable<InnHouse> inns =
                from houses in dictAllHouses.Values.OfType<InnHouse>()
                select houses;
            List<InnHouse> listOfInns = inns.ToList();
            //loop list again and assign all remaining followers to inns
            if (listOfInns.Count > 0)
            {
                Game.logStart?.Write("--- Assign LeftOver Followers to Inns (World.cs)");
                int indexInns = 0;
                for (int i = 0; i < listOfActiveActors.Count; i++)
                {
                    Active actor = listOfActiveActors[i];
                    listOfInns[indexInns].AddFollower(actor.ActID);
                    indexInns++;
                    //rollover index if end of Inns reached
                    if (indexInns == listOfInns.Count) { indexInns = 0; }
                }
            }
            else { Game.SetError(new Error(63, "No Inns present on Map -> No followers available to recruit")); }
        }

        /// <summary>
        /// Initiate character Movement (creates a Move object)
        /// </summary>
        /// <param name="charID">Character</param>
        /// <param name="posOrigin"></param>
        /// <param name="posDestination"></param>
        /// <param name="path">sequenced List of Positions to destination</param>
        internal string InitialiseMoveActor(int charID, Position posOrigin, Position posDestination/*, List<Position> path*/)
        {
            Game.logTurn?.Write("--- InitiateMoveActor (World.cs)");
            string returnText = "Error in World.InitiateMoveCharacters";
            //viable Character & Position?
            if (charID > 0 && posOrigin != null && posDestination != null /* && path != null*/)
            {
                //find in dictionary
                if (dictAllActors.ContainsKey(charID))
                {
                    Game.logTurn?.Write("--- Move Actor (Director.cs)");
                    Actor person = dictAllActors[charID];
                    if (person != null)
                    {
                        if (person.Status == ActorStatus.AtLocation)
                        {
                            List<Position> path = Game.network.GetPathAnywhere(posOrigin, posDestination);
                            List<int> party = new List<int>(); //list of charID's of all characters in party
                            party.Add(charID);
                            string name = person.Name;
                            bool playerInParty = false;
                            if (charID == 1)
                            { playerInParty = true; }
                            int speed = person.Speed;
                            int distance = path.Count;
                            int time = (distance / speed) + 1; //prevents 0 result
                                                               //return string
                            string originLocation = Game.display.GetLocationName(posOrigin);
                            string destinationLocation = Game.display.GetLocationName(posDestination);
                            returnText = string.Format("{0} commences a {1} day journey from {2} to {3}", name, time, originLocation, destinationLocation);
                            //remove character from current location 
                            int locID_Origin = Game.map.GetMapInfo(MapLayer.LocID, posOrigin.PosX, posOrigin.PosY);
                            Location loc = Game.network.GetLocation(locID_Origin);
                            if (loc != null)
                            {
                                //normal travel
                                if (Game._menuMode != MenuMode.God)
                                {
                                    //check an existing Move object doesn't already exist, e.g if user issued > 1 move orders during a turn
                                    //reverse loop, deleting any that contain the Player as you go
                                    for (int i = listMoveObjects.Count - 1; i >= 0; i--)
                                    {
                                        Move tempMove = listMoveObjects[i];
                                        if (tempMove.GetPrimaryCharacter() == charID)
                                        {
                                            Position pos = tempMove.GetCurrentPosition();
                                            Game.logTurn?.Write(string.Format("[Move -> Alert] Move Object DELETED PlayerInParty -> {0}, charID {1} at Loc {2}:{3}", tempMove.PlayerInParty, tempMove.GetPrimaryCharacter(),
                                                pos.PosX, pos.PosY));
                                            Active tempActive = Game.world.GetActiveActor(charID);
                                            if (tempActive != null)
                                            {
                                                Game.world.SetMessage(new Message(string.Format("{0} {1}'s journey to {2} has been cancelled", tempActive.Title, tempActive.Name, tempMove.GetDestination()),
                                                  MessageType.Move));
                                            }
                                            else { Game.SetError(new Error(175, "Invalid Player (null)")); }
                                            listMoveObjects.RemoveAt(i);
                                        }
                                    }
                                    //housekeep all move tasks
                                    loc.RemoveActor(charID);
                                    //create new move object
                                    Move moveObject = new Move(path, party, speed, playerInParty, Game.gameTurn);
                                    //insert into moveList
                                    listMoveObjects.Add(moveObject);
                                    //update character status to 'travelling'
                                    person.Status = ActorStatus.Travelling;
                                    //update characterLocationID (now becomes destination)
                                    int locID_Destination = Game.map.GetMapInfo(MapLayer.LocID, posDestination.PosX, posDestination.PosY);
                                    person.LocID = locID_Destination;
                                    //admin
                                    SetMessage(new Message(returnText, person.ActID, locID_Destination, MessageType.Move));
                                    int refID = ConvertLocToRef(locID_Destination);
                                    if (charID == 1)
                                    { Game.world.SetPlayerRecord(new Record(returnText, charID, locID_Destination, CurrentActorEvent.Travel)); }
                                    else if (charID > 1)
                                    { Game.world.SetCurrentRecord(new Record(returnText, charID, locID_Destination, CurrentActorEvent.Travel)); }
                                }
                                //God Mode Teleport Travel
                                else
                                {
                                    returnText = string.Format("{0} instantly Teleports from {2} to {3}", name, time, originLocation, destinationLocation);
                                    //place character at destination
                                    if (CharacterAtDestination(posDestination, charID) == false)
                                    { Game.SetError(new Error(175, $"ActorID {charID} has not had their details updated upon arriving at their Destination")); }
                                    else { Game.logTurn?.Write($"[God Mode] Player teleports from {originLocation} to {destinationLocation}"); }
                                }
                                //show route (Act One -> Player & Follower only, Act Two -> Player & Inquisitors only)
                                if (Game.gameAct == Act.One)
                                {
                                    if (person is Active)
                                    { Game.map.UpdateMap(); Game.map.DrawRoutePath(path); }
                                }
                                else if (Game.gameAct == Act.Two)
                                {
                                    if (person is Player || person is Inquisitor)
                                    { Game.map.UpdateMap(); Game.map.DrawRoutePath(path); }
                                }
                                else
                                //Player specific actions
                                if (person is Player)
                                {
                                    //update Horse status
                                    Player player = person as Player;
                                    if (player.horseStatus != HorseStatus.Gone)
                                    { player.horseStatus = HorseStatus.Normal; }
                                }
                            }
                            else { Game.SetError(new Error(175, $"Invalid Game Act \"{Game.gameAct}\"")); }
                            { returnText = "ERROR: The Journey has been cancelled (Destination not Found)"; }
                        }
                        else
                        {
                            //main error conditions
                            if (person.Status == ActorStatus.Travelling)
                            { Game.logTurn?.Write(string.Format("[Move -> Error] {0} {1}, ActID {2}, currently Travelling. Move Cancelled", person.Title, person.Name, person.ActID));
                                returnText = "ERROR: The Journey has been cancelled (Actor Travelling))"; }
                            else if (person.Status == ActorStatus.Captured)
                            { Game.logTurn?.Write(string.Format("[Move -> Error] {0} {1}, ActID {2}, currently Captured. Move Cancelled", person.Title, person.Name, person.ActID));
                                returnText = "ERROR: The Journey has been cancelled (Actor Captured))"; }
                            else if (person.Status == ActorStatus.Gone)
                            { Game.logTurn?.Write(string.Format("[Move -> Error] {0} {1}, ActID {2}, is Deceased. Move Cancelled", person.Title, person.Name, person.ActID));
                                returnText = "ERROR: The Journey has been cancelled (Actor Deceased))"; }
                            else
                            { Game.SetError(new Error(175, string.Format("{0} {1}, ActID {2} Status \"{3}\" Unknown. Move Cancelled", person.Title, person.Name, person.ActID, person.Status)));
                                returnText = "ERROR: The Journey has been cancelled (Actor Status Unknown)"; }
                        }
                    }
                    else { Game.SetError(new Error(175, "Invalid Actor (null) Move Cancelled")); returnText = "ERROR: The Journey has been cancelled (Actor not Found)"; }
                }
            }
            return returnText;
        }

        /// <summary>
        /// Handles movement of all Player characters througout world
        /// </summary>
        /// <returns>returns a dictionary of mapMarkers and coordinates for the "Movement" mapGrid layer</returns>
        internal Dictionary<int, Position> MoveActors()
        {
            //create a dictionary of position and map markers to return (passed up to game thence to map to update mapgrid
            Dictionary<int, Position> dictMapMarkers = new Dictionary<int, Position>();
            Game.logTurn?.Write(string.Format("--- MoveActors -> {0} Records (World.cs)", listMoveObjects.Count));
            //loop moveList. Update each move object - update Character Location ID
            for (int i = 0; i < listMoveObjects.Count; i++)
            {

                //get move object
                Move moveObject = listMoveObjects[i];
                //debug
                int actorID = moveObject.GetPrimaryCharacter();
                Actor actor = GetAnyActor(actorID);
                if (actor != null)
                {
                    Position pos = moveObject.GetCurrentPosition();
                    if (pos != null)
                    {
                        Game.logTurn?.Write(string.Format(" [Move -> MoveObject] {0} {1}, ActID {2} travelling to {3} (current Loc {4}:{5})", actor.Title, actor.Name, actor.ActID,
                            moveObject.GetDestination(), pos.PosX, pos.PosY));
                    }
                    else { Game.SetError(new Error(42, "Invalid pos (null) in actor console printout")); }
                }
                else { Game.SetError(new Error(42, "Invalid Actor (null) in actor console printout")); }
                //move speed clicks down list of positions (ignore locations at present)
                moveObject.UpdatePartyStatus();
                if (moveObject.Status == PartyStatus.Active)
                {
                    //Arrived at Destination
                    if (moveObject.MoveParty() == true)
                    {
                        //update all relevant details for character arriving at destination
                        Position posDestination = moveObject.GetCurrentPosition();
                        /*int locID = Game.map.GetMapInfo(MapLayer.LocID, posDestination.PosX, posDestination.PosY);
                        Location loc = Game.network.GetLocation(locID);*/
                        List<int> charListMoveObject = new List<int>(moveObject.GetCharacterList());
                        //find location, get list, update for each character
                        /*if (loc != null)
                        {*/
                        foreach (int charID in charListMoveObject)
                        {
                            if (CharacterAtDestination(posDestination, charID) == false)
                            { Game.SetError(new Error(42, $"ActorID {actorID} has not had their details updated upon arriving at their Destination")); }
                        }
                        moveObject.Status = PartyStatus.Done;
                    }
                    else
                    //still enroute
                    {
                        //update dictionary
                        try
                        { dictMapMarkers.Add(moveObject.MapMarker, moveObject.GetCurrentPosition()); }
                        catch (ArgumentException)
                        { Game.SetError(new Error(42, "Error adding to dictMapMarkers (duplicate key -> Normal)")); }
                        //update Characters in list (charPos)
                        Position pos = moveObject.GetCurrentPosition();
                        List<int> characterList = new List<int>(moveObject.GetCharacterList());
                        for (int j = 0; j < characterList.Count; j++)
                        {
                            int charID = characterList[j];
                            //find in dictionary
                            if (dictAllActors.ContainsKey(charID))
                            {
                                Actor person = dictAllActors[charID];
                                person.SetPosition(pos);
                            }
                        }
                    }
                }
                else if (moveObject.Status == PartyStatus.Delayed)
                {
                    /*message about delay?*/
                    try
                    { dictMapMarkers.Add(moveObject.MapMarker, moveObject.GetCurrentPosition()); }
                    catch (ArgumentException)
                    { Game.SetError(new Error(42, "Error adding to dictMapMarkers (duplicate key -> Delayed)")); }
                }
            }
            //reverse loop through list of Moveobjects and delete any that are marked as 'Done'
            for (int i = listMoveObjects.Count; i > 0; i--)
            {
                if (listMoveObjects[i - 1].Status == PartyStatus.Done)
                {
                    try
                    { listMoveObjects.RemoveAt(i - 1); }
                    catch (Exception e)
                    { Game.SetError(new Error(61, e.Message)); }
                }
            }
            //pass dictionary of markers back to map object via Game
            return dictMapMarkers;
        }

        /// <summary>
        /// internal method to handle an active actor arriving at a destination (updates all relevant details). Returns true if all O.K
        /// </summary>
        /// <param name="posDestination"></param>
        /// <param name="actorID"></param>
        private bool CharacterAtDestination(Position posDestination, int actorID)
        {
            if (posDestination != null)
            {
                //active actor?
                if (actorID > 0)
                {
                    int locID = Game.map.GetMapInfo(MapLayer.LocID, posDestination.PosX, posDestination.PosY);
                    Location locDestination = Game.network.GetLocation(locID);
                    if (locDestination != null)
                    {
                        MessageType messageType = MessageType.Move;
                        //add character to destination
                        locDestination.AddActor(actorID);
                        //find character and update details
                        if (dictAllActors.ContainsKey(actorID))
                        {
                            Actor person = new Actor();
                            person = dictAllActors[actorID];
                            person.Status = ActorStatus.AtLocation;
                            person.SetPosition(posDestination);
                            person.LocID = locID;
                            int refID = ConvertLocToRef(locID);
                            string tempText = string.Format("{0}, Aid {1}, has arrived safely at {2}", person.Name, person.ActID, locDestination.LocName);
                            if (Game._menuMode == MenuMode.God && actorID < 10)
                            {
                                tempText = string.Format("[GodMode] {0}, Aid {1}, has teleported safely to {2}", person.Name, person.ActID, locDestination.LocName);
                                messageType = MessageType.God;
                            }

                            Message message = new Message(tempText, person.ActID, locDestination.LocationID, messageType);
                            SetMessage(message);
                            // Player
                            if (person.ActID == 1)
                            {
                                SetPlayerRecord(new Record(tempText, person.ActID, person.LocID, CurrentActorEvent.Travel));
                                Game.director.AddVisitedLoc(locID, Game.gameTurn);
                                Player player = person as Player;
                                switch (player.horseStatus)
                                {
                                    case HorseStatus.Normal:
                                        player.horseStatus = HorseStatus.Stabled;
                                        break;
                                    case HorseStatus.Exhausted:
                                    case HorseStatus.Lame:
                                    case HorseStatus.Gone:
                                        CreateHorseRecord(HorseGone.Abandoned, $"at {Game.display.GetLocationName(player.LocID)}");
                                        GetNewHorse();
                                        break;
                                }
                            }
                            else if (person.ActID > 1)
                            { SetCurrentRecord(new Record(tempText, person.ActID, person.LocID, CurrentActorEvent.Travel)); }
                            //enemy -> arrives at destination, assign goal
                            if (person is Enemy)
                            {
                                Enemy enemy = person as Enemy;
                                if (enemy.HuntMode == true) { enemy.Goal = ActorAIGoal.Search; }
                                else { enemy.Goal = ActorAIGoal.Wait; }
                                Game.logTurn?.Write(string.Format(" [Goal -> Arrival] {0} {1}, ActID {2}, currently at {3}, new Goal -> {4}", enemy.Title, enemy.Name, enemy.ActID, locDestination.LocName, enemy.Goal));
                            }
                        }
                        else
                        { Game.SetError(new Error(247, $"Character not found, actorID {actorID}")); return false; }
                    }
                    else { Game.SetError(new Error(247, "Invalid locDestination (null)")); return false; }
                }
                else { Game.SetError(new Error(247, $"Invalid actorID \"{actorID}\"-> must be > 0")); return false; }
            }
            else { Game.SetError(new Error(247, "Invalid posDestination (null)")); return false; }
            return true;
        }


        /*/// <summary>
        /// Select a Player Character from the displayed list
        /// </summary>
        /// <returns>Character ID</returns>
        public int ChooseActor()
        {
            Game.logTurn?.Write("--- ChooseActor (World.cs)");
            Game.logTurn?.Write("Which Character do you want to move (Enter ID #)? ");
            //Console.WriteLine("Which Character do you want to move (Enter ID #)? ");
            int charID = Convert.ToInt32(Console.ReadLine());
            Active person = new Active();
            //check character exists
            if (dictActiveActors.ContainsKey(charID))
            {
                person = dictActiveActors[charID];
                if (person.Status != ActorStatus.AtLocation)
                {
                    Game.logTurn?.Write("That Character isn't at a Location and can't be selected");
                    //Console.WriteLine("That Character isn't at a Location and can't be selected");
                    charID = 0;
                }
            }
            else
            {
                Game.logTurn?.Write("Character doesn't exist!");
                //Console.WriteLine("Character doesn't exist!");
                charID = 0;
            }
            return charID;
        }*/

        /// <summary>
        /// return a Passive actor from dictPassiveActors
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Passive GetPassiveActor(int actorID)
        {
            Passive person = new Passive();
            if (dictPassiveActors.ContainsKey(actorID))
            { person = dictPassiveActors[actorID]; }
            return person;
        }

        internal Dictionary<int, Passive> GetAllPassiveActors()
        { return dictPassiveActors; }

        /// <summary>
        /// return an Active actor from dictActiveActors, otherwise null
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Active GetActiveActor(int actorID)
        {
            Active person = new Active();
            if (dictActiveActors.ContainsKey(actorID))
            { person = dictActiveActors[actorID]; }
            else { person = null; }
            return person;
        }

        /// <summary>
        /// returns Player player, otherwise null
        /// </summary>
        /// <returns></returns>
        internal Player GetPlayer()
        {
            Player player = new Player();
            if (dictActiveActors.ContainsKey(1))
            { player = (Player)dictActiveActors[1]; }
            else { player = null; }
            return player;
        }

        /// <summary>
        /// return an Enemy actor from dictenemyActors, otherwise null
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Enemy GetEnemyActor(int actorID)
        {
            Enemy person = new Enemy();
            if (dictEnemyActors.ContainsKey(actorID))
            { person = dictEnemyActors[actorID]; }
            else { person = null; }
            return person;
        }


        internal Dictionary<int, Enemy> GetAllEnemyActors()
        { return dictEnemyActors; }

        /// <summary>
        /// returns any actor -> Passive or Active
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Actor GetAnyActor(int actorID)
        {
            Actor person = new Actor();
            if (dictAllActors.ContainsKey(actorID))
            { person = dictAllActors[actorID]; }
            else { person = null; }
            return person;
        }

        internal Dictionary<int, Actor> GetAllActors()
        { return dictAllActors; }

        /// <summary>
        /// returns dictionary of Active Actors
        /// </summary>
        /// <returns></returns>
        internal Dictionary<int, Active> GetAllActiveActors()
        { return dictActiveActors; }


        internal Dictionary<int, Passive> GetAllRoyals()
        { return dictRoyalBackUp; }


        /// <summary>
        /// returns true if Player at specified location and their status is 'AtLocation' (used by DrawMapRL)
        /// </summary>
        /// <param name="locID"></param>
        /// <returns></returns>
        public bool GetPlayerLocStatus(int locID)
        {
            //check player in dictionary
            if (dictActiveActors.ContainsKey(1))
            {
                Active player = dictActiveActors[1];
                if (player.Status == ActorStatus.AtLocation)
                {
                    if (player.LocID == locID)
                    { return true; }
                }
            }
            return false;
        }

        /// <summary>
        /// returns Revert # of days for specified active actor. A value of 0 indicates a status of Unknown (eg. 'Known' = false)
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public int GetActiveActorKnownStatus(int actID)
        {
            //check active actor in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active active = dictActiveActors[actID];
                if (active.Status != ActorStatus.Gone)
                { return active.Revert; }
                else { Game.SetError(new Error(137, string.Format("Active Actor, actID {0},  \"Gone\"", active.ActID))); }
            }
            else { Game.SetError(new Error(137, "Active Actor not found in dictActiveActors")); }
            return 0;
        }

        /// <summary>
        /// returns true if specified actor has the indicated status, otherwise false
        /// </summary>
        /// <param name="actorID"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        public bool CheckActorStatus(int actorID, ActorStatus status)
        {
            Actor actor = GetAnyActor(actorID);
            if (actor != null)
            { if (actor.Status == status) { return true; } }
            else { Game.SetError(new Error(191, string.Format("Invalid Actor input (null), ActID {0}, status {1}", actorID, status))); }
            return false;
        }


        /// <summary>
        /// returns num days since target was last Known
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public int GetTrackingStatus(int actID)
        {
            //check active actor in dictionary
            if (dictAllActors.ContainsKey(actID))
            {
                Actor actor = dictAllActors[actID];
                if (actor.Status != ActorStatus.Gone)
                { return actor.TurnsUnknown; }
                else { Game.SetError(new Error(137, string.Format("Actor, actID {0},  \"Gone\"", actor.ActID))); }
            }
            else { Game.SetError(new Error(137, "Actor not found in dictAllActors")); }
            return 0;
        }

        /// <summary>
        /// change an Active Actors known status -> data +ve then switch to UNKNOWN, if -ve then KNOWN (if already Known then reset Revert timer to 0). Returns MT if insuccessful
        /// </summary>
        /// <param name="actID"></param>
        /// <param name="data">data +ve then switch to UNKNOWN, if -ve then KNOWN</param>
        /// <returns></returns>
        public string SetActiveActorKnownStatus(int actID, int data)
        {
            string resultText = "";
            int maxRevert = Game.constant.GetValue(Global.KNOWN_REVERT);
            //check active actor in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active active = dictActiveActors[actID];
                if (active.Status != ActorStatus.Gone)
                {
                    if (data < 0)
                    {
                        bool disguiseFlag = false;
                        //Known -> if already known resert Revert timer to the max.
                        if (active is Player)
                        {
                            //player in disguise? -> serves to soak up the hit (disguise loses a level)
                            Player player = active as Player;
                            if (player.Conceal == ActorConceal.Disguise)
                            { Game.ai.CheckConcealment(); disguiseFlag = true; }
                        }
                        //Non-Player, or player who isn't in Disguise
                        if (active.Known == true)
                        { resultText = string.Format("{0} {1} has had their Known timer increased to the maximum ({2} days)", active.Title, active.Name, maxRevert); }
                        else
                        {
                            active.Known = true;
                            if (disguiseFlag == false)
                            { resultText = string.Format("{0} {1} is now KNOWN ({2} days)", active.Title, active.Name, maxRevert); }
                            else
                            { resultText = $"{active.Title} {active.Name}'s disguise has prevented {active.SexText} from becoming Known"; }
                        }
                        active.Revert = maxRevert;
                        //reset TurnsUnknown timer back to zero
                        active.TurnsUnknown = 0;
                        active.LastKnownLocID = active.LocID;
                    }
                    else if (data > 0)
                    {
                        //Unknown
                        active.Known = false;
                        active.Revert = 0;
                        resultText = string.Format("{0} {1} is now UNKNOWN", active.Title, active.Name);
                    }
                    else { Game.SetError(new Error(138, "Invalid Data Input (zero)")); }
                    return resultText;
                }
                else { Game.SetError(new Error(138, string.Format("Active Actor, actID {0},  \"Gone\"", active.ActID))); }
            }
            else { Game.SetError(new Error(138, "Active Actor not found in dictActiveActors")); }
            return resultText;
        }

        /// <summary>
        /// selects an actor for movement orders if at a location (both Acts) and activated (Act Two), returns null otherwise
        /// </summary>
        /// <param name="charID"></param>
        /// <returns></returns>
        internal Position GetActorLocationByPos(int charID)
        {
            Position pos = null;
            //find in dictionary
            if (Game.gameAct == Act.One)
            {
                if (dictActiveActors.ContainsKey(charID))
                {
                    Active person = dictActiveActors[charID];
                    pos = person.GetPosition();
                    //can't be selected if not at a Location
                    if (person.Status != ActorStatus.AtLocation) { pos = null; }
                    //can't be selected if not activated, eg. Crow
                    if (person.Activated == false) { pos = null; }
                }
            }
            else if (Game.gameAct == Act.Two)
            {
                //player must have Manual control
                if (Game.variable.GetValue(GameVar.Inquisitor_AI) == 0)
                {
                    if (dictEnemyActors.ContainsKey(charID))
                    {
                        Actor person = dictEnemyActors[charID];
                        pos = person.GetPosition();
                        //can't be selected if not at a Location
                        if (person.Status != ActorStatus.AtLocation) { pos = null; }
                    }
                }
            }
            else { Game.SetError(new Error(331, $"Invalid Game Act \"{Game.gameAct}\"")); }
            return pos;
        }



        /// <summary>
        /// Checks dictSpecialActors and, if found, returns ActorID, otherwise '0'
        /// </summary>
        /// <param name="specialID"></param>
        /// <returns></returns>
        internal int GetSpecialActorID(int specialID)
        {
            int actorID = 0;
            if (specialID > 0)
            {
                if (dictSpecialActors.ContainsKey(specialID))
                {
                    Special person = dictSpecialActors[specialID];
                    return person.ActID;
                }
            }
            else { Game.SetError(new Error(213, "Invalid specialID (zero, or less)")); }
            return actorID;
        }

        /// <summary>
        /// receives list of Houses from Network and places in releveant House Dictionaries for permanent use
        /// </summary>
        /// <param name="listOfHouses"></param>
        internal void InitialiseHouses()
        {
            int menAtArms = Game.constant.GetValue(Global.MEN_AT_ARMS);
            Game.network.UpdateHouses(Game.history.GetMajorHouses());
            Game.logStart?.Write("---  InitialiseHouses (World.cs) ---");
            //great houses
            List<MajorHouse> listOfMajorHouses = Game.history.GetMajorHouses();
            foreach (MajorHouse house in listOfMajorHouses)
            { AddMajorHouse(house); }
            //populate sorted dictionary (descending) of house ID's by Power (# of BannerLords)
            SortMajorHouses();
            //minor houses
            List<House> listOfMinorHouses = Game.history.GetMinorHouses();
            foreach (House house in listOfMinorHouses)
            { dictAllHouses.Add(house.RefID, house); }
            //capital
            List<CapitalHouse> listOfCapitalHouses = Game.history.GetCapitalHouses();
            foreach (House house in listOfCapitalHouses)
            { dictAllHouses.Add(house.RefID, house); house.MenAtArms = menAtArms; }
            //initialise Special Locations
            Game.history.InitialiseSpecialHouses();
            //update Map layer for RefID
            int locID = 0;
            int refID = 0;
            foreach (KeyValuePair<int, House> record in dictAllHouses)
            {
                locID = record.Value.LocID;
                refID = record.Value.RefID;
                Location loc = Game.network.GetLocation(locID);
                if (loc != null) { Game.map.SetMapInfo(MapLayer.RefID, loc.GetPosX(), loc.GetPosY(), refID); }
                else { Game.SetError(new Error(188, "Invalid Loc (null) Map Layer not updated")); }
            }
            //populate list of Bannerlord RefID's in Major Houses
            foreach (MajorHouse house in listOfMajorHouses)
            {
                List<int> bannerLords = house.GetBannerLordLocations();
                int minorRefID;
                if (bannerLords.Count > 0)
                {
                    foreach (int minorLocID in bannerLords)
                    {
                        Location loc = Game.network.GetLocation(minorLocID);
                        if (loc != null)
                        {
                            minorRefID = Game.map.GetMapInfo(MapLayer.RefID, loc.GetPosX(), loc.GetPosY());
                            house.AddBannerLord(minorRefID);
                        }
                        else { Game.SetError(new Error(188, "Invalid minorLoc (null) Bannerlord not added to Great House list")); }
                    }
                }
            }
            //fill Great Houses with Lords and Ladies
            Game.logStart?.Write("- House Genetics (add Lords and Ladies)");
            //foreach (KeyValuePair<int, MajorHouse> kvp in dictMajorHouses)
            foreach (var house in dictMajorHouses)
            {
                //create Lord and Lady for house
                Location loc = Game.network.GetLocation(house.Value.LocID);
                if (loc != null)
                {
                    Position pos = loc.GetPosition();
                    Noble actorLord = (Noble)Game.history.CreateStartingHouseActor(house.Value.Name, ActorType.Lord, pos, house.Value.LocID, house.Value.RefID, house.Value.HouseID);
                    Noble actorLady = (Noble)Game.history.CreateStartingHouseActor(house.Value.Name, ActorType.Lady, pos, house.Value.LocID, house.Value.RefID, house.Value.HouseID,
                        ActorSex.Female, WifeStatus.First_Wife);
                    //add Lord to House
                    house.Value.LordID = actorLord.ActID;
                    //create a knight, castellan and maester for each Major house
                    Knight actorKnight = Game.history.CreateKnight(pos, house.Value.LocID, house.Value.RefID, house.Value.HouseID);
                    Advisor actorCastellan = Game.history.CreateAdvisor(pos, house.Value.LocID, house.Value.RefID, house.Value.HouseID, ActorSex.Male, AdvisorNoble.Castellan);
                    Advisor actorMaester = Game.history.CreateAdvisor(pos, house.Value.LocID, house.Value.RefID, house.Value.HouseID, ActorSex.Male, AdvisorNoble.Maester);
                    Advisor actorSepton = Game.history.CreateAdvisor(pos, house.Value.LocID, house.Value.RefID, house.Value.HouseID, ActorSex.Male, AdvisorNoble.Septon);
                    //add to dictionaries of actors
                    SetPassiveActor(actorLord);
                    SetPassiveActor(actorLady);
                    SetPassiveActor(actorKnight);
                    SetPassiveActor(actorCastellan);
                    SetPassiveActor(actorMaester);
                    SetPassiveActor(actorSepton);
                    //create family
                    Game.history.CreateFamily(actorLord, actorLady);
                    //add MenAtArms (needed to be done here -> sequence issues with history. InitialisePastHistory)
                    house.Value.MenAtArms = menAtArms;

                }
                else { Game.SetError(new Error(188, "Invalid Loc (null) Lord and Lady not created")); }
                //check if lady died in childbirth
                /* if (actorLady.Status == ActorStatus.Gone)
                 {
                     int yearWifeDied = actorLady.Died;
                     //40% chance of remarrying
                     if (rnd.Next(100) < 40)
                     {
                         //new wife
                         Passive actor2ndWife = Game.history.CreatePassiveActor(kvp.Value.Name, ActorTitle.Lady, pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID, 
                             ActorSex.Female, WifeStatus.Second_Wife);
                         //add to dictionaries of actors
                         dictPassiveActors.Add(actor2ndWife.ActID, actor2ndWife);
                         dictAllActors.Add(actor2ndWife.ActID, actor2ndWife);
                         //location born (different for lady)
                         House wife2ndHouse = GetHouse(actor2ndWife.BornRefID);
                         Location loc2ndWife = Game.network.GetLocation(wife2ndHouse.LocID);
                         descriptor = string.Format("{0} (nee {1}, Aid {2}) born at {3}", actor2ndWife.Name, actor2ndWife.MaidenName, actor2ndWife.ActID, loc2ndWife.LocName);
                         Record record2ndWife = new Record(descriptor, actor2ndWife.ActID, loc2ndWife.LocationID, actor2ndWife.BornRefID, actor2ndWife.Born, HistEvent.Born);
                         //create records of being born
                         SetRecord(record2ndWife);
                         //store actor in location
                         loc.AddActor(actor2ndWife.ActID);
                         //create family
                         Game.history.CreatePassiveFamily(actorLord, actor2ndWife);
                     }
                 }*/
            }
            //hand out bastards and adopted sons to lords with no heirs
            CheckGreatLords();
            //fill minor houses with BannerLords
            foreach (var house in dictAllHouses)
            {
                //minor houses only
                if (house.Value is MinorHouse)
                {
                    //create BannerLord for house
                    Location loc = Game.network.GetLocation(house.Value.LocID);
                    if (loc != null)
                    {
                        Position pos = loc.GetPosition();
                        BannerLord bannerLord = (BannerLord)Game.history.CreateStartingHouseActor(house.Value.Name, ActorType.BannerLord, pos, house.Value.LocID, house.Value.RefID, house.Value.HouseID);
                        //add to dictionaries of actors
                        dictPassiveActors.Add(bannerLord.ActID, bannerLord);
                        dictAllActors.Add(bannerLord.ActID, bannerLord);
                        //add Lord to house
                        house.Value.LordID = bannerLord.ActID;
                        //add MenAtArms (needed to be done here -> sequence issues with history. InitialisePastHistory)
                        house.Value.MenAtArms = menAtArms / 2;
                    }
                    else { Game.SetError(new Error(188, "Invalid Loc (null) Bannerlord not created")); }
                }
            }
            //assign 9999 refId to the capital
            Location capital = Game.network.GetLocation(1);
            if (capital != null)
            { Game.map.SetMapInfo(MapLayer.RefID, capital.GetPosX(), capital.GetPosY(), 9999); }
            else { Game.SetError(new Error(188, "Invalid CapitalLoc (null) RefID not updated")); }
        }

        /// <summary>
        /// creates dictHousePower of strongest to weakest houses
        /// </summary>
        internal void SortMajorHouses()
        {
            dictHousePower.Clear();
            foreach (KeyValuePair<int, int> kvp in dictMajorHouseID.OrderByDescending(key => key.Value))
            { dictHousePower.Add(kvp.Key, kvp.Value); }
        }


        /// <summary>
        /// adds a Major House to all relevant dictionaries
        /// </summary>
        /// <param name="house"></param>
        internal void AddMajorHouse(MajorHouse house)
        {
            try
            {
                dictMajorHouses.Add(house.HouseID, house);
                dictAllHouses.Add(house.RefID, house);
                dictMajorHouseID.Add(house.HouseID, house.GetNumBannerLords());
            }
            catch (Exception e)
            { Game.SetError(new Error(34, e.Message)); }
        }

        /// <summary>
        /// Add non-Major house to the only relevant dictionary
        /// </summary>
        /// <param name="house"></param>
        internal void AddOtherHouse(House house)
        { dictAllHouses.Add(house.RefID, house); }

        /// <summary>
        /// Add a possession to the dictionary, return true if successful
        /// </summary>
        /// <param name="possID"></param>
        /// <param name="possObject"></param>
        /// <returns></returns>
        public bool AddPossession(int possID, Possession possObject)
        {
            try
            { dictPossessions.Add(possID, possObject); return true; }
            catch (ArgumentNullException)
            { Game.SetError(new Error(123, "Invalid Possession Object (null), possID")); }
            catch (ArgumentException)
            { Game.SetError(new Error(123, string.Format("Invalid possessionID (duplicate ID), possID {0}", possID))); }
            return false;
        }


        /// <summary>
        /// Add a rumour to the dictRumoursKnown (to Player), returns true if successful
        /// </summary>
        /// <param name="rumourID"></param>
        /// <param name="rumourObject"></param>
        /// <returns></returns>
        internal bool AddRumourKnown(int rumourID, Rumour rumourObject)
        {
            try
            { dictRumoursKnown.Add(rumourID, rumourObject); return true; }
            catch (ArgumentNullException)
            { Game.SetError(new Error(273, $"Invalid Rumour Object (null), rumourID {rumourID}")); }
            catch (ArgumentException)
            { Game.SetError(new Error(273, $"Invalid rumourID (duplicate ID), rumourID {rumourID}")); }
            return false;
        }

        /// <summary>
        /// Add a rumour to the dictRumoursNormal, returns true if successful
        /// </summary>
        /// <param name="rumour"></param>
        /// <returns></returns>
        internal bool AddRumourNormal(Rumour rumour)
        {
            try
            { dictRumoursNormal.Add(rumour.RumourID, rumour); return true; }
            catch (ArgumentNullException)
            { Game.SetError(new Error(273, $"Invalid Rumour (null), Normal rumourID {rumour.RumourID}")); }
            catch (ArgumentException)
            { Game.SetError(new Error(273, $"Invalid rumourID (duplicate ID), Normal rumourID {rumour.RumourID}")); }
            return false;
        }

        /// <summary>
        /// Add a rumour to the dictRumoursTimed, returns true if successful
        /// </summary>
        /// <param name="rumour"></param>
        /// <returns></returns>
        internal bool AddRumourTimed(Rumour rumour)
        {
            try
            { dictRumoursTimed.Add(rumour.RumourID, rumour); return true; }
            catch (ArgumentNullException)
            { Game.SetError(new Error(290, $"Invalid Rumour (null), Timed rumourID {rumour.RumourID}")); }
            catch (ArgumentException)
            { Game.SetError(new Error(290, $"Invalid rumourID (duplicate ID), Timed rumourID {rumour.RumourID}")); }
            return false;
        }

        /// <summary>
        /// Add a rumour to the dictRumoursInactive, returns true if successful
        /// </summary>
        /// <param name="rumour"></param>
        /// <returns></returns>
        internal bool AddRumourInactive(Rumour rumour)
        {
            try
            { dictRumoursInactive.Add(rumour.RumourID, rumour); return true; }
            catch (ArgumentNullException)
            { Game.SetError(new Error(291, $"Invalid Rumour (null), Inactive rumourID {rumour.RumourID}")); }
            catch (ArgumentException)
            { Game.SetError(new Error(291, $"Invalid rumourID (duplicate ID), Inactive rumourID {rumour.RumourID}")); }
            return false;
        }

        /// <summary>
        /// remove a Timed rumour if it exists in dictRumoursTimed
        /// </summary>
        /// <param name="rumourID"></param>
        /// <returns></returns>
        internal bool RemoveRumourTimed(int rumourID)
        {
            if (dictRumoursTimed.ContainsKey(rumourID) == true)
            {
                dictRumoursTimed.Remove(rumourID);
                Game.logTurn?.Write($"[Rumour -> Deleted] Timed RumourID {rumourID} removed from dictRumoursTimed");
                return true;
            }
            return false;
        }

        internal Dictionary<int, Rumour> GetRumoursKnown()
        { return dictRumoursKnown; }

        /// <summary>
        /// find entry with same RefID in dictAllHouses and removes it if present (used by lore.cs CreateNewMajorHouse)
        /// </summary>
        /// <param name="refID"></param>
        internal void RemoveMinorHouse(int refID)
        {
            if (!dictAllHouses.Remove(refID))
            { Game.SetError(new Error(35, "House not found")); }
        }

        /// <summary>
        /// find and remove Great House from all relevant dictionaries
        /// </summary>
        /// <param name="refID"></param>
        internal void RemoveMajorHouse(House house)
        {
            //if (!dictAllHouses.Remove(house.RefID)) -> leave this as it doesn't affect major house calculations and retains house records
            //{ Game.SetError(new Error(35, "House not found")); }
            if (!dictMajorHouses.Remove(house.HouseID))
            { Game.SetError(new Error(35, "House not found")); }
            if (!dictMajorHouseID.Remove(house.HouseID))
            { Game.SetError(new Error(35, "House not found")); }
        }

        /// <summary>
        /// checks GreatLords for having no sons at Game Start
        /// </summary>
        private void CheckGreatLords()
        {
            //loop all passive actors
            bool foundSon;
            int wifeID = 0;
            int yearUpper; //upper and lower bounds for determining what year child is born
            int yearLower;
            int yearBorn;
            List<int> listOfLords = new List<int>(); //ActID of lords who are in need of a son
            List<int> listOfLadies = new List<int>(); //ActID of ladies who are in need of a son (lord and lady have identical indexes)
            foreach (KeyValuePair<int, Passive> kvp in dictPassiveActors)
            {
                foundSon = false;
                //lord?
                if (kvp.Value.Type == ActorType.Lord && kvp.Value.Status != ActorStatus.Gone)
                {
                    //Loop family looking for a son
                    Noble noble = kvp.Value as Noble;
                    SortedDictionary<int, ActorRelation> tempDictFamily = noble.GetFamily();
                    foreach (KeyValuePair<int, ActorRelation> family_kvp in tempDictFamily)
                    {
                        if (family_kvp.Value == ActorRelation.Son)
                        { foundSon = true; }
                        else if (family_kvp.Value == ActorRelation.Wife)
                        { wifeID = family_kvp.Key; }
                    }
                    //if no son provide one
                    if (foundSon == false)
                    {
                        listOfLords.Add(kvp.Value.ActID);
                        listOfLadies.Add(wifeID);
                    }
                }
            }
            //who needs a son?
            if (listOfLords.Count > 0)
            {
                for (int i = 0; i < listOfLords.Count; i++)
                {
                    //50/50 bastard or adopted
                    ActorParents parents = ActorParents.Bastard;
                    if (rnd.Next(100) < 50)
                    { parents = ActorParents.Adopted; }
                    //create a child
                    Noble Lord = (Noble)GetPassiveActor(listOfLords[i]);
                    Noble Lady = (Noble)GetPassiveActor(listOfLadies[i]);
                    //get year
                    yearUpper = Game.gameRevolt;
                    if (Lady.Status == ActorStatus.Gone)
                    { yearUpper = Lady.Gone; }
                    yearLower = Lady.Married;
                    yearBorn = rnd.Next(yearLower, yearUpper);
                    Game.history.CreateChild(Lord, Lady, yearBorn, ActorSex.Male, parents);
                }
            }
        }


        /// <summary>
        /// populates dictionary of GeoLocations
        /// </summary>
        private void InitialiseGeoClusters()
        {
            List<GeoCluster> tempList = Game.history.GetGeoClusters();
            foreach (GeoCluster cluster in tempList)
            { dictGeoClusters.Add(cluster.GeoID, cluster); }
        }

        /// <summary>
        /// populates dictionary of Traits
        /// </summary>
        private void InitialiseTraits()
        {
            List<Skill> tempList = Game.history.GetTraits();
            foreach (Skill trait in tempList)
            { dictTraits.Add(trait.SkillID, trait); }
        }


        /// <summary>
        /// assigns each Passive character a desire
        /// </summary>
        private void InitialiseDesires()
        {
            Game.logStart?.Write("--- InitialiseDesires (World.cs)");
            List<PossPromiseType> listOfPossibleDesires = new List<PossPromiseType>();
            //list to hold specific desires
            List<int> listOfSonsAndBrothers = new List<int>();
            List<int> listOfDaughters = new List<int>();
            List<int> listOfMinorHouses = new List<int>();
            //Land
            int[,] networkAnalysis = Game.network.GetNetworkAnalysis();
            //item reason texts, 'because it...'
            string[] itemReasons = new string[] { "is their birthright", "was forseen", "has been predicted by prophecy", "is an ancestral heirloom", "belongs to their house", "belongs to them",
                "might help their enemies", "is their destiny" };
            string reason;
            bool itemProceed = true;
            //Royal household (new King)
            MajorHouse royalHouse = (MajorHouse)GetHouse(Game.lore.RoyalRefIDNew);
            //List of all Passive Items
            IEnumerable<Item> listItems =
                from items in dictPossessions.Values.OfType<Item>()
                where items.ItemType == PossItemType.Passive
                select items;
            List<Item> listOfPassiveItems = listItems.ToList();
            int possID;
            //note array should correspond exactly to enum PossPromiseType
            for (int i = 0; i < dictPassiveActors.Count; i++)
            {
                //clear out lists
                listOfPossibleDesires.Clear();
                listOfSonsAndBrothers.Clear();
                listOfMinorHouses.Clear();
                listOfDaughters.Clear();
                Passive actor = dictPassiveActors.ElementAt(i).Value;
                //Item (applies to all but is assigned seperately)
                Item item = listOfPassiveItems[rnd.Next(listOfPassiveItems.Count)];
                possID = item.PossID;
                //check item not already owned by actor
                if (actor.CheckItems(PossItemType.Passive) == true)
                {
                    List<int> tempList = actor.GetItems(PossItemType.Passive);
                    foreach (var objectID in tempList)
                    {
                        if (objectID == item.PossID)
                        { itemProceed = false; break; }
                    }
                }
                if (actor.Status != ActorStatus.Gone)
                {
                    //load up listOfPossibleDesires with relevant Desires
                    switch (actor.Type)
                    {
                        case ActorType.Lord:
                            //King is also a Lord
                            if (actor.Office != ActorOffice.King)
                            {
                                Noble lord = actor as Noble;
                                House house = GetHouse(actor.RefID);
                                if (house != null)
                                {
                                    //Land
                                    if (house is MajorHouse)
                                    {
                                        MajorHouse majorHouse = house as MajorHouse;
                                        List<int> listBannerLords = majorHouse.GetBannerLordLocations();
                                        int numHouses = listBannerLords.Count;
                                        int branch = majorHouse.Branch;
                                        int majorHouses = networkAnalysis[branch, (int)NetGrid.MajorHouses];
                                        int totalLocs = networkAnalysis[branch, (int)NetGrid.Locations];
                                        int specials = networkAnalysis[branch, (int)NetGrid.Specials];
                                        int locID = majorHouse.LocID;
                                        int index = 999;
                                        int houseID = majorHouse.HouseID;
                                        //are there any houses on the same branch of a different house?
                                        if ((totalLocs - majorHouses - specials - numHouses) > 0)
                                        {
                                            Game.logStart?.Write($"There are enough houses on branch {house.Branch} for \"{house.Name}\" to desire Land");

                                            List<Location> listBranchLocs = Game.network.GetBranchLocs(branch);
                                            //find major house position in list (sorted by distance from capital)
                                            if (listBranchLocs != null)
                                            {
                                                for (int j = 0; j < listBranchLocs.Count; j++)
                                                {
                                                    Location loc = listBranchLocs[j];
                                                    if (loc.LocationID == locID)
                                                    { index = j; break; }
                                                }
                                                //found MajorHouse?
                                                if (index < 999)
                                                {
                                                    if ((index + 1) < listBranchLocs.Count)
                                                    {
                                                        //loop forward looking for first minor House belonging to someone else
                                                        for (int m = index + 1; m < listBranchLocs.Count; m++)
                                                        {
                                                            Location loc = listBranchLocs[m];
                                                            if (loc.HouseID != houseID)
                                                            {
                                                                House searchHouse = GetHouse(loc.RefID);
                                                                if (searchHouse != null)
                                                                {
                                                                    if (searchHouse is MinorHouse)
                                                                    {
                                                                        listOfMinorHouses.Add(searchHouse.RefID);
                                                                        Game.logStart?.Write($"[Alert -> Out Neighbour] MinorHouse \"{searchHouse.Name}\", RefID {searchHouse.RefID}, added to listOfMinorHouses");
                                                                        break;
                                                                    }
                                                                }
                                                                else { Game.SetError(new Error(234, "Invalid searchHouse (null) -> Out")); }
                                                            }
                                                        }
                                                    }
                                                    else { Game.logStart?.Write("[Alert -> Index] listOfBranchLocs Index is too high"); }
                                                    if ((index - 1) >= 0)
                                                    {
                                                        //loop backwards looking for first minor House belonging to someone else
                                                        for (int m = index - 1; m >= 0; m--)
                                                        {
                                                            Location loc = listBranchLocs[m];
                                                            if (loc.HouseID != houseID)
                                                            {
                                                                House searchHouse = GetHouse(loc.RefID);
                                                                if (searchHouse != null)
                                                                {
                                                                    if (searchHouse is MinorHouse)
                                                                    {
                                                                        listOfMinorHouses.Add(searchHouse.RefID);
                                                                        Game.logStart?.Write($"[Alert -> In Neighbour] MinorHouse \"{searchHouse.Name}\", RefID {searchHouse.RefID}, added to listOfMinorHouses");
                                                                        break;
                                                                    }
                                                                }
                                                                else { Game.SetError(new Error(234, "Invalid searchHouse (null) -> In")); }
                                                            }
                                                        }
                                                    }
                                                    else { Game.logStart?.Write("[Alert -> Index] listOfBranchLocs Index is too low"); }
                                                    //if two possible minor houses delete the one that is furthest away
                                                    if (listOfMinorHouses.Count > 1)
                                                    {
                                                        Game.logStart?.Write("There are two minor houses, furthest will be eliminated");
                                                        Location locMajor = Game.network.GetLocation(majorHouse.LocID);
                                                        int[] arrayDistance = new int[listOfMinorHouses.Count];
                                                        for (int p = 0; p < listOfMinorHouses.Count; p++)
                                                        {
                                                            //work out distances
                                                            House checkHouse = GetHouse(listOfMinorHouses[p]);
                                                            if (checkHouse != null)
                                                            {
                                                                Location locMinor = Game.network.GetLocation(checkHouse.LocID);
                                                                List<Route> route = Game.network.GetRouteAnywhere(locMajor.GetPosition(), locMinor.GetPosition());
                                                                arrayDistance[p] = Game.network.GetDistance(route);
                                                                Game.logStart?.Write($"[Alert -> Distance] MinorHouse \"{checkHouse.Name}\", RefID {checkHouse.RefID}, (Loc {locMinor.GetPosX()}:{locMinor.GetPosY()}) -> Distance {arrayDistance[p]}");
                                                            }
                                                        }
                                                        //find shortest distance
                                                        int minDistance = 999;
                                                        int minIndex = 999;
                                                        for (int q = 0; q < arrayDistance.Length; q++)
                                                        {
                                                            if (arrayDistance[q] < minDistance)
                                                            {
                                                                minDistance = arrayDistance[q];
                                                                minIndex = q;
                                                            }
                                                        }
                                                        //make sure only the shortest distance minorHouse loc remains in the list
                                                        if (minIndex < 999)
                                                        {
                                                            int shortestRefID = listOfMinorHouses[minIndex];
                                                            listOfMinorHouses.Clear();
                                                            listOfMinorHouses.Add(shortestRefID);
                                                            Game.logStart?.Write($"Minor House RefID {shortestRefID} retained, others deleted");
                                                        }
                                                        else { Game.SetError(new Error(234, "Invalid minIndex (999)")); }
                                                    }
                                                }
                                                else { Game.SetError(new Error(234, $"Major House \"{majorHouse.Name}\" not found in listOfBranchLocs")); }
                                            }
                                            else { Game.SetError(new Error(234, "Invalid listBranchLocs (null)")); }
                                            //if no neighbours have been found on straight shot routes then need to get a random minor house from the branch
                                            if (listOfMinorHouses.Count == 0)
                                            { Game.logStart?.Write($"[Alert -> Cancelled] No neighbouring minor houses found"); }
                                        }
                                        else
                                        {
                                            Game.logStart?.Write($"Insufficient houses for \"{house.Name}\", branch {house.Branch} -> totalLoc {totalLocs} MajorH {majorHouses} Specials {specials} ActorH {numHouses}");
                                            //only one house on branch
                                            if (majorHouses == 1)
                                            {
                                                //Is there a connector to another branch?
                                                int[,] connectorAnalysis = Game.map.GetArrayOfConnectors();
                                                int branchConnection = connectorAnalysis[branch, 0];
                                                if (branchConnection > 0)
                                                {
                                                    Game.logStart?.Write($"[Alert] Connection exists between branch {branch} and {branchConnection}");
                                                    //is the location on the other end of the connection a minor house?
                                                    int posX = connectorAnalysis[branch, 4];
                                                    int posY = connectorAnalysis[branch, 5];
                                                    int refID = Game.map.GetMapInfo(MapLayer.RefID, posX, posY);
                                                    if (refID > 0)
                                                    {
                                                        House connHouse = GetHouse(refID);
                                                        if (connHouse != null)
                                                        {
                                                            if (connHouse is MinorHouse)
                                                            {
                                                                //this minor house is the only possibility
                                                                Game.logStart?.Write($"[Alert -> Connector] Minor House \"{connHouse.Name}\" exists at end of Connector");
                                                                listOfMinorHouses.Add(connHouse.RefID);
                                                            }
                                                            else { Game.logStart?.Write($"[Alert -> Connector] A minor house does NOT exist at the end of the connector"); }
                                                        }
                                                        else { Game.SetError(new Error(234, "Invalid connHouse (null)")); }
                                                    }
                                                    else { Game.SetError(new Error(234, "Invalid refID (zero, or less)")); }
                                                }
                                                else { Game.logStart?.Write($"[Alert] NO Connection exists on branch {branch}"); }
                                            }
                                        }
                                    }
                                    //Family
                                    SortedDictionary<int, ActorRelation> dictFamily = lord.GetFamily();
                                    //Game.logStart?.Write($"Lord {lord.Name}  \"{lord.Handle}\" of House {house.Name}, ActID {lord.ActID}");
                                    foreach (var familyMember in dictFamily)
                                    {
                                        Passive relative = GetPassiveActor(familyMember.Key);
                                        if (relative != null)
                                        {
                                            if (relative.Status != ActorStatus.Gone)
                                            {
                                                //Game.logStart?.Write($"ActID {familyMember.Key} Relationship {familyMember.Value}, {relative.Title} {relative.Name} Age {relative.Age}");
                                                //Court Position for a brother or son, or Marriage for a daughter
                                                if ((relative.Age + Game.gameExile) >= 15)
                                                {
                                                    switch (familyMember.Value)
                                                    {
                                                        case ActorRelation.Brother:
                                                        case ActorRelation.Half_Brother:
                                                            //store brothers as a negative ActID to differentiate between Sons (two entries for each brother)
                                                            listOfSonsAndBrothers.Add(familyMember.Key * -1);
                                                            listOfPossibleDesires.Add(PossPromiseType.Court);
                                                            listOfPossibleDesires.Add(PossPromiseType.Court);
                                                            //Game.logStart?.Write($"  Desire -> Court, Brother {relative.Name} ActID {relative.ActID}");
                                                            break;
                                                        case ActorRelation.Son:
                                                            //store Sons as a positive (normal) ActID (two entries for each son)
                                                            listOfSonsAndBrothers.Add(familyMember.Key);
                                                            //Game.logStart?.Write($"  Desire -> Court, Son {relative.Name} ActID {relative.ActID}");
                                                            listOfPossibleDesires.Add(PossPromiseType.Court);
                                                            listOfPossibleDesires.Add(PossPromiseType.Court);
                                                            break;
                                                        case ActorRelation.Daughter:
                                                            Noble daughter = relative as Noble;
                                                            //check that she is available
                                                            if (daughter.Married == 0)
                                                            {
                                                                //store Daughter's ActID (two entries for each daughter)
                                                                listOfDaughters.Add(familyMember.Key);
                                                                //Game.logStart?.Write($"  Desire -> Marriage, Daughter {relative.Name} ActID {relative.ActID}");
                                                                listOfPossibleDesires.Add(PossPromiseType.Marriage);
                                                                listOfPossibleDesires.Add(PossPromiseType.Marriage);
                                                            }
                                                            else { Game.logStart?.Write($"[Alert -> Daughter] {daughter.Title} {daughter.Name}, ActID {daughter.ActID} already Married in {daughter.Married}"); }
                                                            break;
                                                    }
                                                }
                                            }
                                        }
                                        else { Game.SetError(new Error(234, $"Invalid Passive relative (null) {familyMember.Value}, ActID {familyMember.Key} -> Family member not checked")); }
                                    }
                                    //Gold -> lvl 1 gives 3 entries, lvl 2 gives 2, lvl 3 gives 1
                                    if (house.Resources <= 3)
                                    {
                                        for (int k = 0; k < (4 - house.Resources); k++)
                                        {
                                            listOfPossibleDesires.Add(PossPromiseType.Gold);
                                            //Game.logStart?.Write("   Desire -> Gold");
                                        }
                                    }
                                    //Item
                                    if (itemProceed == true)
                                    { listOfPossibleDesires.Add(PossPromiseType.Item); }
                                    //Land -> 4 entries
                                    if (listOfMinorHouses.Count > 0)
                                    {
                                        listOfPossibleDesires.Add(PossPromiseType.Land);
                                        listOfPossibleDesires.Add(PossPromiseType.Land);
                                        listOfPossibleDesires.Add(PossPromiseType.Land);
                                        listOfPossibleDesires.Add(PossPromiseType.Land);
                                    }
                                }
                                else { Game.SetError(new Error(234, $"Invalid House (null) for {actor.Name} ActID {actor.ActID}")); }
                            }
                            break;
                        case ActorType.BannerLord:
                            House tempHouse = GetHouse(actor.RefID);
                            if (tempHouse != null)
                            {
                                //Gold (if poor), Lordship (if treacherous)
                                if (tempHouse.Resources <= 2)
                                { listOfPossibleDesires.Add(PossPromiseType.Gold); }
                                //Lordship -> Not if a member of Royal house
                                if (actor.HouseID != royalHouse.HouseID)
                                {
                                    int treachery = actor.GetSkill(SkillType.Treachery);
                                    switch (treachery)
                                    {
                                        case 4:
                                            listOfPossibleDesires.Add(PossPromiseType.Lordship);
                                            listOfPossibleDesires.Add(PossPromiseType.Lordship);
                                            break;
                                        case 5:
                                            listOfPossibleDesires.Add(PossPromiseType.Lordship);
                                            listOfPossibleDesires.Add(PossPromiseType.Lordship);
                                            listOfPossibleDesires.Add(PossPromiseType.Lordship);
                                            break;
                                    }
                                }
                                else { Game.logStart?.Write($"[Alert -> Royal] Bannerlord House \"{tempHouse.Name}\" is a member of the Royal Household -> Lordship desire not valid"); }
                            }
                            else { Game.SetError(new Error(234, "Invalid tempHouse (null) for BannerLord")); }
                            //Item
                            if (itemProceed == true)
                            { listOfPossibleDesires.Add(PossPromiseType.Item); }
                            //None -> possible for Bannerlords but not Lords (they all want something)
                            listOfPossibleDesires.Add(PossPromiseType.None);
                            break;
                        case ActorType.Lady:
                            Noble lady = actor as Noble;
                            //Family => cares only for son or daughter, there is no 'None' option
                            SortedDictionary<int, ActorRelation> dictFamilyWife = lady.GetFamily();
                            foreach (var familyMember in dictFamilyWife)
                            {
                                Passive relative = GetPassiveActor(familyMember.Key);
                                if (relative != null)
                                {
                                    if (relative.Status != ActorStatus.Gone)
                                    {
                                        //Court Position for a brother or son, or Marriage for a daughter
                                        if ((relative.Age + Game.gameExile) >= 15)
                                        {
                                            switch (familyMember.Value)
                                            {
                                                case ActorRelation.Son:
                                                    //store Sons as a positive (normal) ActID (two entries for each son)
                                                    listOfSonsAndBrothers.Add(familyMember.Key);
                                                    //Game.logStart?.Write($"  Desire -> Court, Son {relative.Name} ActID {relative.ActID}");
                                                    listOfPossibleDesires.Add(PossPromiseType.Court);
                                                    listOfPossibleDesires.Add(PossPromiseType.Court);
                                                    break;
                                                case ActorRelation.Daughter:
                                                    Noble daughter = relative as Noble;
                                                    //check that she is available
                                                    if (daughter.Married == 0)
                                                    {
                                                        //store Daughter's ActID (two entries for each daughter)
                                                        listOfDaughters.Add(familyMember.Key);
                                                        listOfPossibleDesires.Add(PossPromiseType.Marriage);
                                                        listOfPossibleDesires.Add(PossPromiseType.Marriage);
                                                    }
                                                    else { Game.logStart?.Write($"[Alert -> Daughter] {daughter.Title} {daughter.Name}, ActID {daughter.ActID} already Married in {daughter.Married}"); }
                                                    break;
                                            }
                                        }
                                    }
                                }
                                else { Game.SetError(new Error(234, $"Invalid Passive relative (null) {familyMember.Value}, ActID {familyMember.Key} -> Family member not checked")); }
                            }
                            break;
                        case ActorType.Knight:
                            //Title or gold, if treacherous
                            switch (actor.GetSkill(SkillType.Treachery))
                            {
                                case 4:
                                    listOfPossibleDesires.Add(PossPromiseType.Title);
                                    listOfPossibleDesires.Add(PossPromiseType.Title);
                                    listOfPossibleDesires.Add(PossPromiseType.Gold);
                                    break;
                                case 5:
                                    listOfPossibleDesires.Add(PossPromiseType.Title);
                                    listOfPossibleDesires.Add(PossPromiseType.Title);
                                    listOfPossibleDesires.Add(PossPromiseType.Title);
                                    listOfPossibleDesires.Add(PossPromiseType.Gold);
                                    break;
                            }
                            break;
                        case ActorType.Advisor:
                            //all advisors, Royal and Noble -> Desire gold if high treachery, there is no 'None' option
                            int advisorTreachery = actor.GetSkill(SkillType.Treachery);
                            switch (advisorTreachery)
                            {
                                case 4:
                                    listOfPossibleDesires.Add(PossPromiseType.Gold);
                                    break;
                                case 5:
                                    listOfPossibleDesires.Add(PossPromiseType.Gold);
                                    listOfPossibleDesires.Add(PossPromiseType.Gold);
                                    break;
                            }
                            break;
                    }

                    //actor has desires?
                    if (listOfPossibleDesires.Count > 0)
                    {
                        //randomly choose a Desire
                        PossPromiseType desire = listOfPossibleDesires[rnd.Next(listOfPossibleDesires.Count)];
                        //assign to actor
                        actor.Desire = desire;
                        actor.SetDesireKnown(false);
                        int data;
                        //choose specific option for the desire
                        switch (desire)
                        {
                            case PossPromiseType.Land:
                                actor.DesireData = listOfMinorHouses[rnd.Next(listOfMinorHouses.Count)];
                                House tempHouse = GetHouse(actor.DesireData);
                                Actor tempLord = GetAnyActor(tempHouse.LordID);
                                Location loc = Game.network.GetLocation(tempHouse.LocID);
                                actor.DesireText = $"to have {tempLord.Title} {tempLord.Name} of House {tempHouse.Name} at {tempHouse.LocName} (Loc {loc.GetPosX()}:{loc.GetPosY()}) swear allegiance";
                                break;
                            case PossPromiseType.Court:
                                data = listOfSonsAndBrothers[rnd.Next(listOfSonsAndBrothers.Count)];
                                actor.DesireData = Math.Abs(data);
                                Passive brother = GetPassiveActor(actor.DesireData);
                                actor.DesireText = string.Format("a court position for their {0} {1} \"{2}\" ActID {3}", data > 0 ? "son" : "brother", brother.Name, brother.Handle, brother.ActID);
                                break;
                            case PossPromiseType.Gold:
                                actor.DesireText = "more Gold";
                                actor.DesireData = actor.ActID;
                                break;
                            case PossPromiseType.Marriage:
                                actor.DesireData = listOfDaughters[rnd.Next(listOfDaughters.Count)];
                                Passive daughter = GetPassiveActor(actor.DesireData);
                                actor.DesireText = $"the marriage of their daughter, {daughter.Name} \"{daughter.Handle}\" ActID {daughter.ActID}, to the one true King";
                                break;
                            case PossPromiseType.Item:
                                actor.DesireData = possID;
                                reason = itemReasons[rnd.Next(itemReasons.Length)];
                                actor.DesireText = $"the {item.Description} because it {reason}";
                                break;
                            case PossPromiseType.Title:
                                actor.DesireText = "wants to become a BannerLord with their own castle";
                                actor.DesireData = actor.ActID;
                                break;
                            case PossPromiseType.Lordship:
                                actor.DesireData = actor.HouseID;
                                actor.DesireText = $"the Lordship of House {GetMajorHouseName(actor.HouseID)}";
                                break;
                            case PossPromiseType.None:
                                actor.DesireText = "nothing";
                                actor.DesireData = actor.ActID;
                                break;
                            default:
                                Game.SetError(new Error(234, $"Invalid PossPromiseType for desire \"{desire}\" -> {actor.Title} {actor.Name}, ActID {actor.ActID} desire revoked"));
                                actor.Desire = PossPromiseType.None;
                                break;
                        }
                        Game.logStart?.Write($"{actor.Title} {actor.Name} ActID {actor.ActID} wants {actor.DesireText} -> Desire: {actor.Desire}, DesireData: {actor.DesireData}");
                    }
                }
            }
        }



        /// <summary>
        /// populates Possession dictionary with Secrets
        /// </summary>
        private void InitialiseSecrets()
        {
            List<Secret> tempList = Game.history.GetSecrets();
            if (tempList != null)
            {
                foreach (Secret secret in tempList)
                {
                    try
                    { dictPossessions.Add(secret.PossID, secret); }
                    catch (ArgumentNullException)
                    { Game.SetError(new Error(198, "Invalid Secret (null) -> Not added to Dictionary")); }
                    catch (ArgumentException)
                    { Game.SetError(new Error(198, string.Format("Invalid secret.PossID \"{0}\" (duplicate) -> Not added to Dictionary", secret.PossID))); }
                }
            }
            else { Game.SetError(new Error(198, "Invalid dictionary input -> history.GetSecrets (null)")); }
        }

        /// <summary>
        /// populates Possession dictionary with Items
        /// </summary>
        private void InitialiseItems()
        {
            Game.logStart?.Write("--- InitialiseItems (World.cs)");
            List<Item> tempList = Game.file.GetItems("Items.txt");
            if (tempList != null)
            {
                foreach (Item item in tempList)
                {
                    try
                    { dictPossessions.Add(item.PossID, item); }
                    catch (ArgumentNullException)
                    { Game.SetError(new Error(199, "Invalid Item (null) -> Not added to Dictionary")); }
                    catch (ArgumentException)
                    { Game.SetError(new Error(199, string.Format("Invalid item.PossID \"{0}\" (duplicate) -> Not added to Dictionary", item.PossID))); }
                }
            }
            else { Game.SetError(new Error(199, "Invalid dictionary input -> history.GetSecrets (null)")); }
        }


      

        /// <summary>
        /// Quickly access a house name using houseID
        /// </summary>
        /// <param name="houseID"></param>
        /// <returns></returns>
        public string GetMajorHouseName(int houseID)
        {
            string houseName = "";
            MajorHouse house = new MajorHouse();
            if (dictMajorHouses.TryGetValue(houseID, out house))
            { houseName = house.Name; }
            return houseName;
        }

        /// <summary>
        /// Returns name of house (major, minor or Inn) using Ref ID. 
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        public string GetHouseName(int refID)
        {
            string houseName = "";
            House house = new House();
            if (dictAllHouses.TryGetValue(refID, out house))
            { houseName = house.Name; }
            else if (refID == 9999) { houseName = "KingsKeep"; }
            return houseName;
        }

        internal Dictionary<int, MajorHouse> GetAllMajorHouses()
        { return dictMajorHouses; }

        internal Dictionary<int, House> GetAllHouses()
        { return dictAllHouses; }

        internal Dictionary<int, Passive> GetRoyalCourt()
        { return dictRoyalCourt; }

        /// <summary>
        /// Returns Great house if found, otherwise null, keyed of
        /// </summary>
        /// <param name="houseID"></param>
        /// <returns></returns>
        internal MajorHouse GetMajorHouse(int houseID)
        {
            MajorHouse house = new MajorHouse();
            if (dictMajorHouses.TryGetValue(houseID, out house))
            { return house; }
            return null;
        }

        /// <summary>
        /// returns dictMajorHouses (key is houseID)
        /// </summary>
        /// <returns></returns>
        internal Dictionary<int, MajorHouse> GetMajorHouses()
        { return dictMajorHouses; }

        /// <summary>
        /// Returns house (any type) if found, otherwise null, keyed off refID). Note: Capital returns null
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal House GetHouse(int refID)
        {
            House house = new House();
            if (dictAllHouses.TryGetValue(refID, out house))
            { return house; }
            return null;
        }

        /// <summary>
        /// Return capital, null if not found
        /// </summary>
        /// <returns></returns>
        internal CapitalHouse GetCapital()
        {
            House house = new House();
            if (dictAllHouses.TryGetValue(9999, out house))
            {
                CapitalHouse capital = house as CapitalHouse;
                return capital;
            }
            return null;
        }

        /// <summary>
        /// Query to return list of strings containing selected actor's personal history (includes those of Player)
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal List<string> GetActorHistoricalRecords(int actorID)
        {
            List<string> actorRecords = new List<string>();
            if (actorID > 0)
            {
                //query
                IEnumerable<string> actorHistory =
                    from actor in dictHistoricalRecords
                    from actID in actor.Value.listOfActors
                    where actID == actorID
                    orderby actor.Value.Year
                    select Convert.ToString(actor.Value.Year + " " + actor.Value.Text);
                //place filtered data into list
                actorRecords = actorHistory.ToList();
            }
            else { Game.SetError(new Error(144, "Invalid actorID (0 or less)")); }
            return actorRecords;
        }

        /// <summary>
        /// Query to return list of strings containing selected actor's current game-start onwards records (excludes those of Player)
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal List<string> GetActorCurrentRecords(int actorID)
        {
            List<string> actorRecords = new List<string>();
            if (actorID > 1)
            {
                //query
                IEnumerable<string> actorCurrent =
                    from actor in dictCurrentRecords
                    from actID in actor.Value.listOfActors
                    where actID == actorID
                    orderby actor.Value.Year
                    select Convert.ToString("Day " + actor.Value.Day + ", " + actor.Value.Year + " " + actor.Value.Text);
                //place filtered data into list
                actorRecords = actorCurrent.ToList();
            }
            else { Game.SetError(new Error(142, "Invalid actorID (1 or less)")); }
            return actorRecords;
        }

        /// <summary>
        /// Query to return list of strings containing Player's current game-start onwards records
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal List<string> GetPlayerCurrentRecords(int actorID)
        {
            List<string> actorRecords = new List<string>();
            if (actorID == 1)
            {
                //query
                IEnumerable<string> actorPlayer =
                    from actor in dictPlayerRecords
                    from actID in actor.Value.listOfActors
                    where actID == actorID
                    orderby actor.Value.Year
                    select Convert.ToString("Day " + actor.Value.Day + ", " + actor.Value.Year + " " + actor.Value.Text);
                //place filtered data into list
                actorRecords = actorPlayer.ToList();
            }
            else { Game.SetError(new Error(142, "Invalid actorID (Not that of the Players)")); }
            return actorRecords;
        }

        /// <summary>
        /// Query to return list of strings containing selected house's history
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal List<string> GetHistoricalHouseRecords(int refID)
        {
            List<string> houseRecords = new List<string>();
            //query
            IEnumerable<string> houseHistory =
                from house in dictHistoricalRecords
                from _refID in house.Value.listOfHouses
                where _refID == refID
                orderby house.Value.Year
                select Convert.ToString(house.Value.Year + " " + house.Value.Text);
            //place filtered data into list
            houseRecords = houseHistory.ToList();
            return houseRecords;
        }

        /// <summary>
        /// returns RefID, '0' if not found
        /// </summary>
        /// <param name="houseID"></param>
        /// <returns></returns>
        public int GetGreatHouseRefID(int houseID)
        {
            MajorHouse house = new MajorHouse();
            if (dictMajorHouses.TryGetValue(houseID, out house))
            { return house.RefID; }
            else { Game.SetError(new Error(264, $"Invalid houseID \"{houseID}\" -> Not found in dictionary")); }
            return 0;
        }


        /// <summary>
        /// returns geoCluster, null if not found
        /// </summary>
        /// <param name="geoID"></param>
        /// <returns></returns>
        internal GeoCluster GetGeoCluster(int geoID)
        {
            GeoCluster cluster = new GeoCluster();
            if (dictGeoClusters.TryGetValue(geoID, out cluster))
            { return cluster; }
            else { Game.SetError(new Error(263, $"Invalid geoID \"{geoID}\" -> Not found in dictionary")); }
            return null;
        }

        /// <summary>
        /// return Skill, returns null if not found
        /// </summary>
        /// <param name="skillID"></param>
        /// <returns></returns>
        internal Skill GetSkill(int skillID)
        {
            Skill trait = new Skill();
            if (dictTraits.TryGetValue(skillID, out trait))
            { return trait; }
            else { Game.SetError(new Error(262, $"Invalid traitID \"{skillID}\" -> Not found in dictionary")); }
            return null;
        }

        /// <summary>
        /// get Possession, returns null if not found
        /// </summary>
        /// <param name="possID"></param>
        /// <returns></returns>
        internal Possession GetPossession(int possID)
        {
            if (possID > 0)
            {
                Possession possession = new Possession();
                if (dictPossessions.TryGetValue(possID, out possession))
                { return possession; }
            }
            else { Game.SetError(new Error(205, "Invalid PossID (zero, or less)")); }
            return null;
        }

        /// <summary>
        /// get Rumour, returns null if not found
        /// </summary>
        /// <param name="rumourID"></param>
        /// <returns></returns>
        internal Rumour GetRumour(int rumourID)
        {
            if (rumourID > 0)
            {
                Rumour rumour = new Rumour();
                //try Timed Rumour dict first (it's the smallest)
                if (dictRumoursTimed.TryGetValue(rumourID, out rumour))
                { return rumour; }
                if (dictRumoursNormal.TryGetValue(rumourID, out rumour))
                { return rumour; }
            }
            else { Game.SetError(new Error(265, $"Invalid rumourID \"{rumourID}\" -> Not found in dictRumours Normal or Timed")); }
            return null;
        }

        /// <summary>
        /// get a Known Rumour, returns null if not found
        /// </summary>
        /// <param name="rumourID"></param>
        /// <returns></returns>
        internal Rumour GetRumourKnown(int rumourID)
        {
            if (rumourID > 0)
            {
                Rumour rumour = new Rumour();
                if (dictRumoursKnown.TryGetValue(rumourID, out rumour))
                { return rumour; }
            }
            else { Game.SetError(new Error(274, $"Invalid rumourID \"{rumourID}\" -> Not found in dictRumoursKnown")); }
            return null;
        }

        /// <summary>
        /// returns True if rumour present in dict of Known Rumours
        /// </summary>
        /// <param name="rumourID"></param>
        /// <returns></returns>
        internal bool CheckRumourKnown(int rumourID)
        { return dictRumoursKnown.ContainsKey(rumourID);  }


        /// <summary>
        /// returns an Item from the Possessions Dict, null if not found
        /// </summary>
        /// <param name="possID"></param>
        /// <returns></returns>
        internal Item GetItem(int possID)
        {
            if (possID > 0)
            {
                Possession possession = new Possession();
                if (dictPossessions.TryGetValue(possID, out possession))
                {
                    if (possession is Item)
                    {
                        Item item = possession as Item;
                        return item;
                    }
                    else { Game.SetError(new Error(204, string.Format("Invalid possession -> should be an Item but isn't (possID {0})", possID))); }
                }
            }
            else { Game.SetError(new Error(204, "Invalid PossID (zero, or less)")); }
            return null;
        }

        /// <summary>
        /// Pre-Game start records for everybody including Player
        /// </summary>
        /// <param name="record"></param>
        internal void SetHistoricalRecord(Record record)
        {
            try
            { dictHistoricalRecords.Add(record.TrackerID, record); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(139, "Invalid record (null)")); }
            catch (ArgumentException)
            { Game.SetError(new Error(139, string.Format("Invalid Record TrackerID \"{0}\" (duplicate)", record.TrackerID))); }
        }

        /// <summary>
        /// Game start onwards records for everybody except the Player
        /// </summary>
        /// <param name="record"></param>
        internal void SetCurrentRecord(Record record)
        {
            try
            { dictCurrentRecords.Add(record.TrackerID, record); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(140, "Invalid record (null)")); }
            catch (ArgumentException)
            { Game.SetError(new Error(140, string.Format("Invalid Record TrackerID \"{0}\" (duplicate)", record.TrackerID))); }
        }

        /// <summary>
        /// Game start onwards records for the Player
        /// </summary>
        /// <param name="record"></param>
        internal void SetPlayerRecord(Record record)
        {
            try
            { dictPlayerRecords.Add(record.TrackerID, record); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(141, "Invalid record (null)")); }
            catch (ArgumentException)
            { Game.SetError(new Error(141, string.Format("Invalid Record TrackerID \"{0}\" (duplicate)", record.TrackerID))); }
        }

        /// <summary>
        /// handle a new message appropriately
        /// </summary>
        /// <param name="message"></param>
        internal void SetMessage(Message message)
        {
            if (message != null)
            {
                RLColor color = RLColor.White;
                //certain message types are color coded
                switch (message.Type)
                {
                    case MessageType.Activation:
                        color = Color._active;
                        break;
                    case MessageType.Error:
                        color = RLColor.LightRed;
                        break;
                    case MessageType.God:
                        color = Color._godMode;
                        break;
                }
                //queue for the most recent messages to display at bottom right console window
                Snippet snippet = new Snippet(string.Format("Day {0}, {1}, {2}", message.Day, message.Year, message.Text), color, RLColor.Black);
                messageQueue.Enqueue(snippet);
                //max 8 entries in queue at any one time
                if (messageQueue.Count > 8)
                { messageQueue.Dequeue(); }
                //add to dictionary
                dictMessages.Add(message.TrackerID, message);
                //debug -> doesn't work 'cause called by both logStart and logTurn
                //Game.logTurn.Write(string.Format("Message -> [{0}] Day {1}, {2}, {3}", message.Type, message.Day, message.Year, message.Text));
            }
        }


        /// <summary>
        /// Store a new actor (child,regent brother, etc.) in relevant dictionaries
        /// </summary>
        /// <param name="actor"></param>
        internal void SetPassiveActor(Passive actor)
        {
            try
            {
                dictPassiveActors.Add(actor.ActID, actor);
                dictAllActors.Add(actor.ActID, actor);
            }
            catch (ArgumentNullException)
            { Game.SetError(new Error(211, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(211, "Invalid actor.ActID (duplicate key exists) -> Record not saved")); }
        }

        /// <summary>
        /// store a new actor (player and follower)
        /// </summary>
        /// <param name="actor"></param>
        internal void SetActiveActor(Active actor)
        {
            try
            {
                dictActiveActors.Add(actor.ActID, actor);
                dictAllActors.Add(actor.ActID, actor);
            }
            catch (ArgumentNullException)
            { Game.SetError(new Error(150, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(150, "Invalid actor.ActID (duplicate key exists) -> Record not saved")); }
        }

        /// <summary>
        /// returns number of followers 
        /// </summary>
        /// <returns></returns>
        internal int GetNumFollowers()
        {
            int numFollowers = 0;
            foreach (var actor in dictActiveActors)
            {
                if (actor.Value is Follower && actor.Value.Status != ActorStatus.Gone)
                { numFollowers++; }
            }
            return numFollowers;
        }

        /// <summary>
        /// store a new special (NPC) actor
        /// </summary>
        /// <param name="actor"></param>
        internal void SetSpecialActor(Special actor)
        {
            try
            {
                dictPassiveActors.Add(actor.ActID, actor);
                dictAllActors.Add(actor.ActID, actor);
                dictSpecialActors.Add(actor.SpecialID, actor);
            }
            catch (ArgumentNullException)
            { Game.SetError(new Error(150, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(150, "Invalid ActID or SpecialID (duplicate key exists) -> Record not saved")); }
        }


        /// <summary>
        /// store a Royal court member in relevant dict
        /// </summary>
        /// <param name="actor"></param>
        internal void SetRoyalCourt(Passive actor)
        {
            try
            { dictRoyalCourt.Add(actor.ActID, actor); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(212, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(212, "Invalid actor.ActID (duplicate key exists) -> Record not saved")); }
        }

        /// <summary>
        /// Returns a filtered set of Historical Records
        /// </summary>
        /// <param name="keyPress"></param>
        /// <returns></returns>
        internal List<Snippet> GetHistoricalRecordSet(RLKeyPress keyPress)
        {
            List<string> tempList = new List<string>();
            List<Snippet> snippetList = new List<Snippet>();
            IEnumerable<string> recordList;
            switch (keyPress.Key)
            {
                case RLKey.A:
                    //All records
                    recordList =
                        from record in dictHistoricalRecords
                        orderby record.Value.Year, record.Value.TrackerID
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.C:
                    //CUSTOM (debugging purposes)
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfHistoricalActorIncidents
                        where eventType == HistActorEvent.Lordship
                        //where record.Value.Actual == false
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.D:
                    //deaths
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfHistoricalActorIncidents
                        where eventType == HistActorEvent.Died
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.G:
                    //Marriages
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfHistoricalActorIncidents
                        where eventType == HistActorEvent.Married
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.K:
                    //Kingdom events
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfKingdomIncidents
                        where eventType == HistKingdomEvent.Battle || eventType == HistKingdomEvent.Siege
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
            }
            foreach (string text in tempList)
            { snippetList.Add(new Snippet(text)); }
            return snippetList;
        }

        /// <summary>
        /// Returns a filtered set of Lore records
        /// </summary>
        /// <param name="keyPress"></param>
        /// <returns></returns>
        internal List<Snippet> GetLoreSet(RLKeyPress keyPress)
        {
            List<string> tempList = new List<string>();
            List<Snippet> snippetList = new List<Snippet>();
            switch (keyPress.Key)
            {
                case RLKey.U:
                    tempList.AddRange(Game.lore.GetUprising());
                    break;
                case RLKey.F:
                    tempList.AddRange(Game.lore.GetRoyalFamilyFate());
                    break;
            }
            foreach (string text in tempList)
            { snippetList.Add(new Snippet(text)); }
            return snippetList;
        }

        /*
        /// <summary>
        /// Generate a list of All Secrets
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowSecretsRL()
        {
            List <string> tempList = GetPossessionsSummary(PossessionType.Secret);
            //snippet list
            List<Snippet> listData = new List<Snippet>();
            foreach(string data in tempList)
            { listData.Add(new Snippet(data)); }
            return listData;
        }*/

        /// <summary>
        /// Generate a list of a subtype of Possessions for display
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowPossessionsRL(PossessionType type)
        {
            //snippet list
            List<Snippet> listData = new List<Snippet>();
            List<string> tempList = GetPossessionsSummary(type);
            if (tempList.Count > 0)
            {
                foreach (string data in tempList)
                { listData.Add(new Snippet(data)); }
            }
            return listData;
        }


        /// <summary>
        /// Generate a list of all Bloodhound Actor info grouped by turns
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowSpyAllRL(bool showActive, bool showEnemy)
        {
            int turn;
            string description;
            List<Snippet> listData = new List<Snippet>();
            if (showActive == true)
            {
                if (showEnemy == true)
                { listData.Add(new Snippet("--- Spy ALL", RLColor.Yellow, RLColor.Black)); }
                else { listData.Add(new Snippet("--- Spy ACTIVE Actors", RLColor.Yellow, RLColor.Black)); }
            }
            else { listData.Add(new Snippet("--- Spy ENEMY Actors", RLColor.Yellow, RLColor.Black)); }
            List<ActorSpy> listTempActive = new List<ActorSpy>();
            List<ActorSpy> listTempEnemy = new List<ActorSpy>();
            foreach (var bloodhound in dictBloodHound)
            {
                turn = bloodhound.Key;
                //clear lists
                listTempActive.Clear();
                listTempEnemy.Clear();
                //get a new turn's worth of data
                listTempActive.AddRange(bloodhound.Value.GetActiveActors());
                listTempEnemy.AddRange(bloodhound.Value.GetEnemyActors());
                //snippets -> active actors
                listData.Add(new Snippet(string.Format("Day {0}", turn), RLColor.LightRed, RLColor.Black));
                if (showActive == true)
                {
                    foreach (ActorSpy spy in listTempActive)
                    {
                        description = string.Format("ID {0,-5} {1,-26} Pos {2,2}:{3,-5} Status -> {4,-12} Known -> {5,-8} Goal -> {6, -8} Mode -> {7}", spy.ActID, Game.display.GetActorDetails(spy.ActID),
                            spy.Pos.PosX, spy.Pos.PosY, spy.Status, spy.Known, "n.a", "n.a");
                        listData.Add(new Snippet(description));
                    }
                }
                //snippets -> enemy actors
                if (showEnemy == true)
                {
                    foreach (ActorSpy spy in listTempEnemy)
                    {
                        description = string.Format("ID {0,-5} {1,-26} Pos {2,2}:{3,-5} Status -> {4,-12} Known -> {5,-8} Goal -> {6, -8} Mode -> {7}", spy.ActID, Game.display.GetActorDetails(spy.ActID), 
                            spy.Pos.PosX, spy.Pos.PosY, spy.Status, spy.Known, spy.Goal, spy.HuntMode == true ? "Hunt" : "normal");
                        listData.Add(new Snippet(description));
                    }
                }
            }
            return listData;
        }

        /// <summary>
        /// Show bloodhound data, turn by turn, for a specific active, or enemy, actor (input ActID)
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowSpyRL(int actID)
        {
            string description;
            List<Snippet> listData = new List<Snippet>();
            List<ActorSpy> tempList = new List<ActorSpy>();
            if (actID > 0)
            {
                if (actID < 10)
                {
                    //Active
                    IEnumerable<ActorSpy> actorData =
                        from bloodhound in dictBloodHound
                        from spy in bloodhound.Value.GetActiveActors()
                        where spy.ActID == actID
                        select spy;
                    tempList = actorData.ToList();
                }
                else
                {
                    //Enemy
                    IEnumerable<ActorSpy> actorData =
                        from bloodhound in dictBloodHound
                        from spy in bloodhound.Value.GetEnemyActors()
                        where spy.ActID == actID
                        select spy;
                    tempList = actorData.ToList();
                }
                //any records found?
                if (tempList.Count > 0)
                {
                    RLColor foreColor;
                    listData.Add(new Snippet(string.Format("--- Spy ACTOR ID {0}", actID), RLColor.Yellow, RLColor.Black));
                    //set up formatted Snippet list
                    foreach (ActorSpy spy in tempList)
                    {
                        if (spy.Known == true) { foreColor = Color._badTrait; }
                        else { foreColor = RLColor.White; }
                        description = string.Format("Day {0,-5} {1,-26} Pos {2,2}:{3,-5} Status -> {4,-12} Known -> {5,-8} Goal -> {6, -8} Mode -> {7}", spy.Turn, Game.display.GetActorDetails(spy.ActID),
                            spy.Pos.PosX, spy.Pos.PosY, spy.Status, spy.Known, spy.Goal, spy.HuntMode == true ? "Hunt" : "normal");
                        listData.Add(new Snippet(description, foreColor, RLColor.Black));
                    }
                }
                else
                { listData.Add(new Snippet(string.Format("No records found for ActID {0}", actID))); }
            }
            else { listData.Add(new Snippet("Warning! Invalid ActorID Input", RLColor.LightRed, RLColor.Black)); }
            return listData;
        }




        /// <summary>
        /// debug: highlights duplicate names in imported files
        /// </summary>
        /// <returns></returns>
        internal List<Snippet> ShowDuplicatesRL()
        {
            //get duplicates
            List<string> listOfStrings = new List<string>(Game.history.GetDuplicatesNames());
            List<Snippet> listOfDuplicates = new List<Snippet>();
            //convert to snippets
            foreach (string name in listOfStrings)
            { listOfDuplicates.Add(new Snippet(name)); }
            return listOfDuplicates;
        }

        /// <summary>
        /// if specified actor present at location then True
        /// </summary>
        /// <param name="actorID"></param>
        /// <param name="locID"></param>
        /// <returns></returns>
        public bool CheckActorPresent(int actorID, int locID)
        {
            Location loc = Game.network.GetLocation(locID);
            if (loc != null) { return loc.CheckActorStatus(actorID); }
            else { Game.SetError(new Error(189, "Invalid Loc (null)")); }
            return false;
        }

        /// <summary>
        /// permanently remove an actor from relevant dictionaries
        /// </summary>
        /// <param name="actorID"></param>
        public void RemovePassiveActor(int actorID)
        {
            if (!dictAllActors.Remove(actorID))
            { Game.SetError(new Error(37, "ActorID not found")); }
            if (!dictPassiveActors.Remove(actorID))
            { Game.SetError(new Error(37, "ActorID not found")); }
        }

        /// <summary>
        /// add a new actor to relevant dictionaries
        /// </summary>
        /// <param name="actor"></param>
        public void AddPassiveActor(Passive actor)
        {
            if (actor != null)
            {
                try
                {
                    dictAllActors.Add(actor.ActID, actor);
                    dictPassiveActors.Add(actor.ActID, actor);
                }
                catch (ArgumentException)
                { Game.SetError(new Error(60, string.Format("Invalid Passive ActorID (duplicate ID) for \"{0}\"", actor.Name))); }
            }
            else { Game.SetError(new Error(38, "null Actor input")); }
        }


        public void AddEnemyActor(Enemy actor)
        {
            if (actor != null)
            {
                try
                {
                    dictAllActors.Add(actor.ActID, actor);
                    dictEnemyActors.Add(actor.ActID, actor);
                }
                catch (ArgumentException)
                { Game.SetError(new Error(151, string.Format("Invalid Enemy ActorID (duplicate ID) for \"{0}\"", actor.Name))); }
            }
            else { Game.SetError(new Error(151, "Invalid Enemy Actor input (null)")); }
        }

        /// <summary>
        /// returns all availabe living Knights
        /// </summary>
        /// <returns></returns>
        public List<int> GetKnights()
        {
            List<int> listOfKnights = new List<int>();
            IEnumerable<int> knights =
                from person in dictPassiveActors
                where person.Value.Type == ActorType.Knight && person.Value.Status != ActorStatus.Gone
                orderby person.Value.ActID
                select person.Value.ActID;
            listOfKnights = knights.ToList();
            return listOfKnights;
        }

        /// <summary>
        /// handles all start (day 0) Game stuff -> NOTE: logTurn
        /// </summary>
        public void ProcessStartGame()
        {
            Game.logTurn?.Write("--- ProcessStartGame (World.cs)");
            Message message = new Message($"Game world created with seed {seed}", MessageType.System);
            SetMessage(message);
            Game.history.AgePassiveCharacters(dictPassiveActors);
            InitialiseRoyalAccounts();
            InitialiseGameVars();
            Game.director.InitialiseStartRumours(); //AFTER initialiseRoyalAccount and just about everything else
            CalculateCrows();
            //DEBUG -> populate dictionary with sample data
            for (int i = 3; i > 0; i--)
            { Game.director.AddVisitedLoc(Game.network.GetRandomLocation(), i * -1); }
            //CheckPositions(); //debug
            InitialiseFinalPlayer();
            Game.display.ShowGeneratorStatsRL();
        }

        /// <summary>
        /// handles all pre-turn stuff, part 1 (Notification messages)
        /// </summary>
        public bool ProcessStartTurnEarly()
        {
            bool notificationStatus = false; //is a notification msg needed?
            Game.infoChannel.ClearConsole(ConsoleDisplay.Event);
            Game.logTurn?.Write("--- ProcessStartTurn (World.cs)");
            Game.logTurn?.Write($"Day {Game.gameTurn}, Turn {Game.gameTurn}, Harvest in {Game.HarvestTimer} days, Winter in {Game.WinterTimer} days, SeasonTimer {Game.SeasonTimer}");
            Game.logTurn?.Write($"{Game.display.GetPlayerStatusReport()}");
            UpdateRumours();
            UpdateActorMoveStatus(MoveActors());
            if (UpdatePlayerStatus() == true) { notificationStatus = true; }
            CalculateCrows();
            if (UpdateWorldStatus() == true) { notificationStatus = true; }
            Game.ai.CheckStationaryTargetActors();

            //Enemies (if AI Controlled)
            if (Game.variable.GetValue(GameVar.Inquisitor_AI) > 0)
            {
                Game.ai.UpdateAIController();
                Game.ai.SetEnemyActivity();
            }
            //Finances
            CheckRoyalAccounts();
            
            return notificationStatus;
        }

        /// <summary>
        /// handles pre-turn stuff, part 2 (events)
        /// </summary>
        public void ProcessStartTurnLate()
        {
            //Create events
            switch (Game.gameAct)
            {
                case Act.One:
                    Game.director.CheckPlayerEvents();
                    Game.director.CheckFollowerEvents(dictActiveActors);
                    //Player events first
                    if (Game.director.ResolvePlayerEvents())
                    { Game._specialMode = SpecialMode.PlayerEvent; }
                    else
                    {
                        //Follwer events last
                        if (Game.director.ResolveFollowerEvents())
                        { Game._specialMode = SpecialMode.FollowerEvent; }
                    }
                    //update position of all key characters on map layers
                    UpdateFollowerPositions();
                    UpdateEnemiesPositions();
                    UpdateActiveActors();
                    break;
                case Act.Two:
                    Game.director.CheckPlayerEvents();
                    if (Game.director.ResolvePlayerEvents())
                    { Game._specialMode = SpecialMode.PlayerEvent; }
                    UpdateEnemiesPositions();
                    break;
            }
            //applies to both Acts
            UpdateBloodHound(); //needs to be right at the end of ProcessStartTurn
        }

        /// <summary>
        /// handles all end of turn stuff
        /// </summary>
        public void ProcessEndTurn()
        {
            Game.logTurn?.Write("--- ProcessEndTurn (World.cs)");
            Game.logTurn?.Write($"Day {Game.gameTurn + 1}, Turn {Game.gameTurn}");
            Game.map.UpdateMap();
            Game.director.HousekeepEvents();
            Game.director.CheckEventTimers();
            Game.director.InitialiseDynamicRumours();
            HousekeepActors();
            HousekeepHouses();
            HousekeepRumours();
            HousekeepGame();
            
        }

        /// <summary>
        /// handles all relevant status changes for the Player
        /// </summary>
        private bool UpdatePlayerStatus()
        {
            bool updateStatus = false; //does a message need to be shown?
            string description;
            Game.logTurn?.Write("--- UpdatePlayerStatus (World.cs)");
            Player player = GetPlayer();
            if (player != null)
            {
                //Sea Voyage Status
                if (player.Status == ActorStatus.AtSea)
                {
                    player.VoyageTimer--;
                    if (player.VoyageTimer == 0)
                    {
                        //arrived at Location
                        string locName = Game.display.GetLocationName(player.LocID);
                        description = string.Format("{0} {1} has arrived at {2} onboard the S.S \"{3}\"", player.Title, player.Name, locName, player.ShipName);
                        SetPlayerRecord(new Record(description, 1, player.LocID, CurrentActorEvent.Travel));
                        SetMessage(new Message(description, MessageType.Move));
                        //notification message
                        List<Snippet> msgList = new List<Snippet>();
                        msgList.Add(new Snippet($"The S.S \"{player.ShipName}\" has docked today with {player.Title} {player.Name} onboard", RLColor.Red, Color._background1));
                        msgList.Add(new Snippet(""));
                        msgList.Add(new Snippet("- o -", RLColor.Gray, Color._background1));
                        msgList.Add(new Snippet(""));
                        SetNotification(msgList);
                        updateStatus = true;
                        //reset actor instances
                        player.Status = ActorStatus.AtLocation;
                        player.ShipName = "Unknown";
                        player.SeaName = "Unknown";
                        player.VoyageSafe = true;
                    }
                    else
                    {
                        description = string.Format("{0} {1} is at Sea onboard the S.S \"{2}\", bound for {3}, arriving in {4} days", player.Title, player.Name, player.ShipName,
                            Game.display.GetLocationName(player.LocID), player.VoyageTimer);
                        SetMessage(new Message(description, MessageType.Move));
                    }
                    Game.logTurn?.Write(description);
                }
                //In a safe House
                if ( player.Conceal == ActorConceal.SafeHouse &&player.Status == ActorStatus.AtLocation )
                {
                    House house = GetHouse(ConvertLocToRef(player.LocID));
                    if (house != null)
                    {
                        description = string.Format("{0} {1} is laying low at a safe house at {2} ({3} stars)", player.Title, player.Name, house.LocName, house.SafeHouse);
                        SetMessage(new Message(description, MessageType.Move));
                        Game.logTurn?.Write(description);
                    }
                    else { Game.SetError(new Error(219, "Invalid house (null) -> SafeHouse message not created")); }
                }
                //Death Timer active
                if (player.DeathTimer < 999)
                {
                    player.DeathTimer--;
                    Game.logTurn?.Write($"{player.Title} {player.Name} Death Timer reduced by 1 to {player.DeathTimer}");
                    if (player.DeathTimer <= 0)
                    {
                        //end of game
                        Game.SetEndGame("Death Timer expired");
                    }
                }
            }
            else { Game.SetError(new Error(219, "Invalid Player (null)")); }
            return updateStatus;
        }

        /// <summary>
        /// checks rumours in dict Timed & Inactive, updates timers and moves & deletes rumours where appropriate
        /// </summary>
        private void UpdateRumours()
        {
            Game.logTurn?.Write("--- UpdateRumours (World.cs)");
            Game.logTurn?.Write($"dictRumoursTimed (Start) -> {dictRumoursTimed.Count} records");
            bool rumourRemoved = false;
            int numRecordsRemoved = 0;
            //Timed Rumours
            if (dictRumoursTimed.Count > 0)
            {
                int counter = 0;
                foreach (var rumour in dictRumoursTimed)
                {
                    //countdown expire timers
                    rumour.Value.TimerExpire--;
                    if (rumour.Value.TimerExpire <= 0)
                    {
                        //Rumour Expired -> remove from list
                        if (Game.director.RemoveRumourFromList(rumour.Value) == true)
                        { rumourRemoved = true; }
                    }
                    else { counter++; }
                }
                if (dictRumoursTimed.Count > 0) { Game.logTurn?.Write($"{counter} rumours -> TimerExpire decremented"); }
                if (rumourRemoved == true)
                {
                    //loop dict backwards and remove any rumours with TimerExpire <= 0
                    for (int i = dictRumoursTimed.Count - 1 ; i >= 0; i--)
                    {
                        Rumour rumour = dictRumoursTimed.ElementAt(i).Value;
                        if (rumour.TimerExpire <= 0)
                        {
                            if (dictRumoursTimed.Remove(rumour.RumourID) == true)
                            { numRecordsRemoved++; }
                            else { Game.SetError(new Error(280, $"RID {rumour.RumourID}, \"{rumour.Text}\" -> FAILED removal from dict")); }
                        }
                    }
                    Game.logTurn?.Write($"{numRecordsRemoved} records have expired and been removed");
                    Game.logTurn?.Write($"dictRumoursTimed (End) -> {dictRumoursTimed.Count} records");
                }
            }
            else { Game.logTurn?.Write("[Notification] No Timed rumours present -> dictRumoursTimed is MT"); }
        }

        /// <summary>
        /// Deletes old timed rumours from dictRumoursKnown
        /// </summary>
        private void HousekeepRumours()
        {
            Game.logTurn?.Write("--- HousekeepRumours (World.cs)");
            int timeLimit = Game.constant.GetValue(Global.ENEMY_RUMOUR_TIME) * 2;
            List<int> listOfKeysToDelete = new List<int>();
            int numRecords = dictRumoursKnown.Count;
            if (numRecords> 0)
            {
                Game.logTurn?.Write($"dictRumoursKnown has {numRecords} records");
                //find any old enemy records that need deleting
                foreach (var rumour in dictRumoursKnown)
                {
                    if (rumour.Value.Status == RumourStatus.Timed && rumour.Value.TimerExpire <= 0)
                    { listOfKeysToDelete.Add(rumour.Key); }
                }
                //delete the records from the dict
                for(int i = 0; i < listOfKeysToDelete.Count; i++)
                {
                    if (dictRumoursKnown.Remove(listOfKeysToDelete[i]) == true)
                    { Game.logTurn?.Write($"[Rumour -> Deleted] RumourID {listOfKeysToDelete[i]}");}
                    else { Game.SetError(new Error(281, $"Failed to delete RumourID {listOfKeysToDelete[i]} from dictRumoursKnown")); }
                }
            }
            else { Game.logTurn?.Write("[Notification] There are no rumours in dictRumoursKnown"); }
        }

        /// <summary>
        /// updates Movement map layer for the different actors (key is mapMarker which is also the ActID of the character moving) Enemies are only shown if known.
        /// </summary>
        private void UpdateActorMoveStatus(Dictionary<int, Position> dictMoveActors)
        {
            int marker;
            //clear out the Movement layer of the grid first
            Game.map.ClearMapLayer(MapLayer.Movement);
            //loop dictionary of move actors
            foreach (var pos in dictMoveActors)
            {
                marker = -1;
                //get actor
                Actor person = GetAnyActor(pos.Key);
                if (person != null)
                {
                    marker = pos.Key;
                    if (person is Enemy)
                    {
                        //enemies are shown as '999' indicating Known status (converted to '0' by map.DrawMapRL)
                        Enemy enemy = person as Enemy;
                        if (enemy.Known == true)
                        { marker = 999; }
                        else { marker = -1; }
                    }
                    //show on map only if known
                    if (marker > 0)
                    { Game.map.SetMapInfo(MapLayer.Movement, pos.Value.PosX, pos.Value.PosY, marker); }
                }
                else { Game.SetError(new Error(157, "Invalid key (ActID) in dictMoveActors (not found in dict)")); }
            }
        }

        /// <summary>
        /// Calculates crow %'s at start of trun
        /// </summary>
        private void CalculateCrows()
        {
            int distance, chance;
            //Player is assumed to be the first record in dictActiveActors
            Player player = GetPlayer();
            Position posPlayer = player.GetPosition();
            //Top up Player Crows to the maximum allowed
            player.CrowsNumber = Game.constant.GetValue(Global.CROW_NUMBER);
            //loop through active players
            foreach (var actor in dictActiveActors)
            {
                if (actor.Value is Follower)
                {
                    actor.Value.ClearCrowTooltips();
                    actor.Value.Activated = false;
                    Position pos = actor.Value.GetPosition();
                    distance = Game.utility.GetDistance(posPlayer.PosX, posPlayer.PosY, pos.PosX, pos.PosY);
                    chance = 100 - (distance * 2) + actor.Value.CrowBonus;
                    chance = Math.Min(100, chance);

                    if (player.Status != ActorStatus.AtLocation || player.Conceal == ActorConceal.SafeHouse)
                    {
                        //no crows can be sent if Player isn't at a Location, or is in a SafeHouse
                        actor.Value.CrowChance = 0;
                        actor.Value.CrowBonus = 0;
                        actor.Value.CrowDistance = distance;
                        //actor.Value.CrowBonus = 0;
                        actor.Value.AddCrowTooltip("No crows can be sent, or received, if the Player is travelling, or is being held");
                    }
                    else
                    {
                        if (actor.Value.Status == ActorStatus.AtLocation)
                        {
                            if (actor.Value.LocID != player.LocID)
                            {
                                //Normal operations -> Player and Follower both at a Location
                                actor.Value.CrowChance = chance;
                                actor.Value.CrowDistance = distance;
                                //actor.Value.CrowBonus = 0;
                                actor.Value.AddCrowTooltip(string.Format("Chance is {0}%  (One hundred less distance doubled plus any bonus)", chance));
                                if (actor.Value.CrowBonus > 0)
                                {
                                    actor.Value.AddCrowTooltip(string.Format("Includes a cumulative bonus of +{0}% from previous failed crows that might be delayed",
                                      Game.constant.GetValue(Global.CROW_BONUS)));
                                }
                            }
                            else
                            {
                                //both at the same location -> no crow required and automatic activation
                                actor.Value.Activated = true;
                                actor.Value.CrowChance = 100;
                                actor.Value.AddCrowTooltip("Automatic activation as at the same location as the Player");
                            }
                        }
                        else
                        {
                            //no crows can be sent if Follower isn't at a Location
                            actor.Value.CrowChance = 0;
                            actor.Value.CrowDistance = distance;
                            actor.Value.CrowBonus = 0;
                            actor.Value.AddCrowTooltip("No crows can be sent to the Follower if they are travelling");
                        }
                    }
                    if (distance > 0)
                    { actor.Value.AddCrowTooltip(string.Format("Distance from Player is {0} leagues, as the crow flies", distance)); }
                }
            }
        }

        /// <summary>
        /// Send a crow to a loyal follower
        /// </summary>
        public List<Snippet> SendCrow(int actorID)
        {
            List<Snippet> listSnippet = new List<Snippet>();
            string description, messageText, locName;
            int chance, num;
            Active actor = GetActiveActor(actorID);
            Player player = GetPlayer();
            int bonus = Game.constant.GetValue(Global.CROW_BONUS);
            if (player.Status == ActorStatus.AtLocation)
            {
                if (player.Conceal != ActorConceal.SafeHouse)
                { 
                    if (player.CrowsNumber > 0)
                    {
                        if (actor != null)
                        {
                            if (actorID != 1)
                            {
                                if (actor.Status == ActorStatus.AtLocation)
                                {
                                    if (actor.LocID != player.LocID)
                                    {
                                        if (actor.Delay == 0)
                                        {
                                            if (actor.Activated == false)
                                            {
                                                locName = Game.display.GetLocationName(actor.LocID);
                                                num = rnd.Next(100);
                                                chance = actor.CrowChance + actor.CrowBonus;
                                                description = string.Format("chance of Crow arriving {0}%, or less. Roll {1}", chance, num);
                                                listSnippet.Add(new Snippet(string.Format("Crow dispatched to {0}, Aid {1}, at {2} (distance {3} leagues)", actor.Name, actor.ActID, locName, actor.CrowDistance)));
                                                player.CrowsNumber--;
                                                messageText = string.Format("Crow sent to {0}, Aid {1}, at {2} ({3}% chance of arriving, roll {4}, {5})", actor.Name, actor.ActID, locName, chance,
                                                    num, num < chance ? "Arrived" : "Failed");
                                                Message message = new Message(messageText, actor.ActID, actor.LocID, MessageType.Crow);
                                                SetMessage(message);
                                                if (num < chance)
                                                {
                                                    //success!
                                                    actor.Activated = true;
                                                    actor.CrowBonus = 0;
                                                    listSnippet.Add(new Snippet(string.Format("Crow success! {0} activated ({1})", actor.Name, description), RLColor.Yellow, RLColor.Black));
                                                    //Game.messageLog.Add(new Snippet(string.Format("Crow arrived, {0} activated", actor.Name)));
                                                    Message message_1 = new Message(string.Format("{0}, Aid {1}, has been Activated", actor.Name, actor.ActID), MessageType.Activation);
                                                    SetMessage(message_1);
                                                }
                                                else
                                                //failed the roll, apply bonus
                                                {
                                                    actor.Activated = false;
                                                    listSnippet.Add(new Snippet(string.Format("The Crow failed to arrive ({0})", description)));
                                                    actor.CrowBonus += bonus;
                                                    actor.AddCrowTooltip(string.Format("An additional bonus of +{0}% applies from a previous failed crow that might have been delayed", bonus));
                                                }
                                                listSnippet.Add(new Snippet(string.Format("You have {0} {1} remaining", player.CrowsNumber, player.CrowsNumber == 1 ? "Crow" : "Crows")));
                                            }
                                            else
                                            //already activated
                                            { listSnippet.Add(new Snippet(string.Format("{0} is already activated and awaiting your orders!", actor.Name))); }
                                        }
                                        else
                                        {
                                            //actor delayed
                                            { listSnippet.Add(new Snippet(string.Format("Crow can NOT be dispatched to {0} as they are delayed (\"{1}\"", actor.Name, actor.DelayReason))); }
                                        }
                                    }
                                    else
                                    {
                                        //at same location as player
                                        listSnippet.Add(new Snippet(string.Format("No crow required as {0} is present at the same location as yourself", actor.Name)));
                                        actor.Activated = true;
                                    }
                                }
                                else
                                //actor not at a location
                                { listSnippet.Add(new Snippet(string.Format("Crow can NOT be dispatched to {0} as they aren't at a location", actor.Name))); }
                            }
                            else
                            //sending a crow to yourself
                            { listSnippet.Add(new Snippet("There is no need to send a crow to yourself!")); }
                        }
                        else
                        //invalid actor
                        { listSnippet.Add(new Snippet("Unknown Actor. No crow sent.")); }
                    }
                    else
                    //run out of crows
                    { listSnippet.Add(new Snippet("You have run out of crows. More will be available next turn")); }
                }
                else
                //Player at safe house
                { listSnippet.Add(new Snippet("You are unable to dispatch crows while in a Safe House", RLColor.LightRed, RLColor.Black)); }
            }
            else
            {
                //Main error states
                if (player.Status == ActorStatus.Travelling) { listSnippet.Add(new Snippet("You are unable to dispatch crows while you are Travelling", RLColor.LightRed, RLColor.Black)); }
                else if (player.Status == ActorStatus.AtSea) { listSnippet.Add(new Snippet("You are unable to dispatch crows while at Sea", RLColor.LightRed, RLColor.Black)); }
                else if (player.Status == ActorStatus.Captured) { listSnippet.Add(new Snippet("You are unable to dispatch crows while you are Incarcerated", RLColor.LightRed, RLColor.Black)); }
                else if (player.Status == ActorStatus.Gone) { listSnippet.Add(new Snippet("You are unable to dispatch crows from the AfterLife", RLColor.LightRed, RLColor.Black)); }
                else { listSnippet.Add(new Snippet(string.Format("Your Status isn't recognised (\"{0}\") and crows are consequently unavailable", player.Status), RLColor.LightRed, RLColor.Black)); }
            }
            return listSnippet;
        }

        /// <summary>
        /// provides # of crows remaining
        /// </summary>
        /// <returns></returns>
        public int GetCrowsAvailable()
        {
            Player player = GetPlayer();
            //snippet = new Snippet(string.Format("You have {0} {1} remaining", numCrows, numCrows == 1 ? "Crow" : "Crows"));
            return player.CrowsNumber;
        }

        /// <summary>
        /// handles end of turn housekeeping for all actor types
        /// </summary>
        private void HousekeepActors()
        {
            Game.logTurn?.Write("--- HouseKeepActors (World.cs)");
            //All actors -> decrement any Condition timers
            foreach (var actor in dictAllActors)
            {
                if (actor.Value.CheckConditions() == true)
                { actor.Value.UpdateConditionTimers(); }
            }
            //Active actors -> decrement any delays
            foreach (var actor in dictActiveActors)
            {
                if (actor.Value.Delay > 0)
                {
                    actor.Value.Delay--;
                    if (actor.Value.Delay == 0)
                    { actor.Value.DelayReason = null; }
                }
                //reset Found and listOfEnemies (search routines)
                actor.Value.Found = false;
                actor.Value.Capture = false;
                actor.Value.ResetEnemies();
                actor.Value.ResetSearched();
                //Player
                if (actor.Value.ActID == 1)
                {
                    Player player = actor.Value as Player;
                    //incarcerated?
                    switch (player.Status)
                    {
                        case ActorStatus.Captured:
                            //stats
                            Game.statistic.AddStat(GameStatistic.Dungeon_Days);
                            actor.Value.Known = true; actor.Value.Revert = 2;
                            //raise Legend_King each turn player is held in dungeon
                            int legendLoss = Game.constant.GetValue(Global.LEGEND_CAPTURED);
                            int currentValue = Game.director.GetGameState(GameState.Legend_King, DataState.Good);
                            int newValue = Math.Abs(Game.director.ChangeData(currentValue, legendLoss, Event_System.EventCalc.Add));
                            Game.director.SetGameState(GameState.Legend_King, DataState.Good, newValue, true);
                            //message
                            string description = string.Format("The Legend of {0} {1} grows (+{2}) while the Usurper is incarcerated", Game.lore.NewKing.Title, Game.lore.NewKing.Name, legendLoss);
                            SetMessage(new Message(description, MessageType.Incarceration));
                            break;
                        case ActorStatus.AtLocation:
                            //stats
                            Game.statistic.AddStat(GameStatistic.Location_Days);
                            //horse matters
                            switch (player.horseStatus)
                            {
                                case HorseStatus.Normal:
                                    //handles God mode moving from one to another
                                    player.horseStatus = HorseStatus.Stabled;
                                    break;
                                case HorseStatus.Lame:
                                case HorseStatus.Exhausted:
                                case HorseStatus.Gone:
                                    Game.SetError(new Error(298, $"A Horse can't be \"{player.horseStatus}\" Status while at a Location"));
                                    break;
                                case HorseStatus.Stabled:
                                    player.HorseDays++;
                                    if (player.HorseHealth < player.HorseMaxHealth)
                                    { player.HorseHealth++; SetMessage(new Message($"\"{player.HorseName}\" is recovering while stabled", 1, player.LocID, MessageType.Horse)); }
                                    break;
                            }
                            break;
                        case ActorStatus.Travelling:
                            //stats
                            Game.statistic.AddStat(GameStatistic.Travelling_Days);
                            //horse matters
                            if (player.horseStatus != HorseStatus.Gone) { player.HorseDays++; }
                            break;
                        case ActorStatus.AtSea:
                            //stats
                            Game.statistic.AddStat(GameStatistic.AtSea_Days);
                            break;
                        case ActorStatus.Adrift:
                            //stats
                            Game.statistic.AddStat(GameStatistic.Adrift_Days);
                            break;
                    }

                    //stats
                    if (player.Known == true) { Game.statistic.AddStat(GameStatistic.Known_Days); }
                    if (player.Conceal == ActorConceal.Disguise) { Game.statistic.AddStat(GameStatistic.Disguise_Days); }
                    if (player.Conceal == ActorConceal.SafeHouse) { Game.statistic.AddStat(GameStatistic.SafeHouse_Days); }
                }
            }
        }

        /// <summary>
        /// returns number of object types in dictionary
        /// </summary>
        /// <param name="possType"></param>
        /// <returns></returns>
        internal int GetPossessionsCount(PossessionType possType)
        {
            int num = 0;
            switch (possType)
            {
                case PossessionType.Item:
                    var itemResult = from possObject in dictPossessions
                                     where possObject.Value is Item
                                     select possObject;
                    num = itemResult.Count();
                    break;
                case PossessionType.Secret:
                    var secretResult = from possObject in dictPossessions
                                       where possObject.Value is Secret
                                       select possObject;
                    num = secretResult.Count();
                    break;
                case PossessionType.None:
                    Game.SetError(new Error(120, "Invalid possType Input (None)"));
                    break;
                default:
                    Game.SetError(new Error(120, string.Format("Invalid possType Input (\"{0}\")", possType)));
                    break;
            }
            return num;
        }

        internal int GetRumoursNormalCount()
        { return dictRumoursNormal.Count; }

        internal int GetRumoursTimedCount()
        { return dictRumoursTimed.Count; }

        /// <summary>
        /// returns a list of year + description of the specific object type in dictionary
        /// </summary>
        /// <param name="possType"></param>
        /// <returns></returns>
        internal List<string> GetPossessionsSummary(PossessionType possType)
        {
            List<string> tempList = new List<string>();
            switch (possType)
            {
                case PossessionType.Secret:
                    IEnumerable<string> secretList =
                    from secret in dictPossessions
                    where secret.Value is Secret
                    orderby secret.Value.Year
                    select Convert.ToString(secret.Value.Year + " " + secret.Value.Description);
                    tempList = secretList.ToList();
                    break;
                case PossessionType.Item:
                    IEnumerable<string> itemListActive =
                        from items in dictPossessions.Values.OfType<Item>()
                        where items.ItemType == PossItemType.Active && items.WhoHas > 0
                        select Convert.ToString("ItemID " + items.ItemID + ", \"" + items.Description + "\", Type: " + items.ItemType + ", " + Game.display.GetActorDetails(items.WhoHas, false));
                    tempList = itemListActive.ToList();
                    IEnumerable<string> itemListPassive =
                        from items in dictPossessions.Values.OfType<Item>()
                        where items.ItemType == PossItemType.Passive && items.WhoHas > 0
                        select Convert.ToString("ItemID " + items.ItemID + ", \"" + items.Description + "\", Type: " + items.ItemType + ", " + Game.display.GetActorDetails(items.WhoHas, false));
                    tempList.AddRange(itemListPassive.ToList());
                    break;
                case PossessionType.None:
                    Game.SetError(new Error(121, "Invalid possType Input (None)"));
                    break;
                default:
                    Game.SetError(new Error(121, string.Format("Invalid possType Input (\"{0}\")", possType)));
                    break;
            }

            return tempList;
        }

        /// <summary>
        /// checks all active followers and updates their position on the map 'Information' layer (used to show characters if the Information toggle is pressed ("I")
        /// </summary>
        private void UpdateFollowerPositions()
        {
            Game.map.ClearMapLayer(MapLayer.Followers);
            foreach (var follower in dictActiveActors)
            {
                if (follower.Key > 0 && follower.Value.Status != ActorStatus.Gone)
                {
                    Position pos = follower.Value.GetPosition();
                    if (pos != null)
                    { Game.map.SetMapInfo(MapLayer.Followers, pos.PosX, pos.PosY, follower.Key); }
                }
            }
        }

        /// <summary>
        /// shows all known enemies
        /// </summary>
        private void UpdateEnemiesPositions()
        {
            Game.map.ClearMapLayer(MapLayer.Enemies);
            Game.map.ClearMapLayer(MapLayer.EnemiesDebug);
            int expire = Game.constant.GetValue(Global.KNOWN_REVERT);
            //loop dictionary -> only place on map layer if known
            foreach (var enemy in dictEnemyActors)
            {
                if (enemy.Value.Status != ActorStatus.Gone)
                {
                    Position pos = enemy.Value.GetPosition();
                    //add to enemiesDebug layer regardless (shows all enemies at current positions)
                    Game.map.SetMapInfo(MapLayer.EnemiesDebug, pos.PosX, pos.PosY, 1);
                    //normal enemies Layer (only what is known by the player)
                    if (enemy.Value.Known == true)
                    {
                        //show enemy with a map marker indicating how many days old the information is -> 1 day old as Known
                        if (pos != null)
                        { Game.map.SetMapInfo(MapLayer.Enemies, pos.PosX, pos.PosY, 1); }
                    }
                    else if (enemy.Value.TurnsUnknown <= expire)
                    {
                        //show enemy with a map marker indicating how many days old the information is (show last known position, not current one).
                        Position pos_1 = enemy.Value.LastKnownPos;
                        if (pos_1 != null)
                        { Game.map.SetMapInfo(MapLayer.Enemies, pos_1.PosX, pos_1.PosY, enemy.Value.TurnsUnknown); }
                    }
                }
            }
        }

        /// <summary>
        /// start of turn Housekeeping for Active Actors
        /// </summary>
        private void UpdateActiveActors()
        {
            Game.logTurn?.Write("--- UpdateActiveActors (World.cs)");
            foreach (var actor in dictActiveActors)
            {
                //if Known, decrement their revert status
                if (actor.Value.Known == true)
                {
                    actor.Value.LastKnownLocID = actor.Value.LocID;
                    actor.Value.TurnsUnknown = 0;
                    actor.Value.Revert--;
                    Game.logTurn?.Write(string.Format(" {0} {1} has had their Revert Timer reduced from {2} to {3}", actor.Value.Title, actor.Value.Name, actor.Value.Revert + 1, actor.Value.Revert));
                    if (actor.Value.Revert <= 0)
                    {
                        //Reverts from Known to Unknown state
                        actor.Value.Known = false;
                        string eventText = string.Format("{0} {1} is no longer \"Known\" as sufficient time has passed", actor.Value.Title, actor.Value.Name);
                        Message message = new Message(eventText, MessageType.Known);
                        SetMessage(message);
                        int refID = ConvertLocToRef(actor.Value.LocID);
                        if (actor.Value.ActID == 1)
                        { SetPlayerRecord(new Record(eventText, actor.Value.ActID, actor.Value.LocID, CurrentActorEvent.Known)); }
                        else if (actor.Value.ActID > 1)
                        { SetCurrentRecord(new Record(eventText, actor.Value.ActID, actor.Value.LocID, CurrentActorEvent.Known)); }
                        Game.logTurn?.Write(eventText);
                    }
                }
                else if (actor.Value.Known == false)
                {
                    actor.Value.TurnsUnknown++;
                    Game.logTurn?.Write(string.Format(" {0} {1} has had their TurnsUnknown Timer increased from {2} to {3}",
                        actor.Value.Title, actor.Value.Name, actor.Value.TurnsUnknown - 1, actor.Value.TurnsUnknown));
                }
            }
        }

        /// <summary>
        /// set up the two refID -> LocID (& vice versa) dictionaries at start of game
        /// </summary>
        private void InitialiseConversionDicts()
        {
            List<Location> listOfLocations = Game.map.GetLocations();
            if (listOfLocations != null)
            {
                int refID, locID, houseID;
                //get all other Loc & Ref data directly from map
                foreach (Location loc in listOfLocations)
                {
                    locID = loc.LocationID;
                    //set up conversion dictionaries
                    refID = Game.map.GetMapInfo(MapLayer.RefID, loc.GetPosX(), loc.GetPosY());
                    houseID = Game.map.GetMapInfo(MapLayer.HouseID, loc.GetPosX(), loc.GetPosY());
                    if (refID > 0)
                    {
                        try
                        { dictConvertLocToRef.Add(locID, refID); }
                        catch (ArgumentException)
                        { Game.SetError(new Error(145, "Invalid LocID, Record already exists (LocID -> RefID)")); }
                        try
                        { dictConvertRefToLoc.Add(refID, locID); }
                        catch (ArgumentException)
                        { Game.SetError(new Error(145, "Invalid RefID, Record already exists (RefID -> LocID)")); }
                        if (houseID > 0)
                        {
                            try
                            { dictConvertRefToHouse.Add(refID, houseID); }
                            catch (ArgumentException)
                            { Game.SetError(new Error(145, "Invalid refID, Record already exists (RefID -> HouseID)")); }
                        }
                    }
                }
            }
            else { Game.SetError(new Error(145, "Invalid listOfLocations (null)")); }
        }

        /// <summary>
        /// get corresponding RefID from LocID. Returns 0 if not found.
        /// </summary>
        /// <param name="locID"></param>
        /// <returns></returns>
        internal int ConvertLocToRef(int locID)
        {
            if (locID > 0)
            {
                if (dictConvertLocToRef.ContainsKey(locID) == true)
                { return dictConvertLocToRef[locID]; }
                else { Game.SetError(new Error(146, "Invalid LocID (record not found")); }
            }
            return 0;
        }

        /// <summary>
        /// get corresponding LocID from RefID. Returns 0 if not found.
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal int ConvertRefToLoc(int refID)
        {
            if (refID > 0)
            {
                if (dictConvertRefToLoc.ContainsKey(refID) == true)
                { return dictConvertRefToLoc[refID]; }
                else { Game.SetError(new Error(147, "Invalid refID (record not found")); }
            }
            return 0;
        }

        /// <summary>
        /// get corresponding HouseID from RefID. Returns 0 if not found.
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal int ConvertRefToHouse(int refID)
        {
            if (refID > 0)
            {
                if (dictConvertRefToHouse.ContainsKey(refID) == true)
                { return dictConvertRefToHouse[refID]; }
                else { Game.SetError(new Error(236, "Invalid refID (record not found")); }
            }
            return 0;
        }



        /// <summary>
        /// All inquisitors must have the same setting (the AI needs all of them to work properly). AI Control if True, Manual if False.
        /// </summary>
        /// <param name="AIcontrol"></param>
        internal void SetInquisitorControlStatus(bool AIcontrol)
        {
            if (Game.gameAct == Act.Two)
            {
                int state;
                foreach (var enemy in dictEnemyActors)
                {
                    if (enemy.Value is Inquisitor)
                    {
                        enemy.Value.AIControl = AIcontrol;
                        Game.logTurn?.Write($"{enemy.Value.Title} {enemy.Value.Name}, ActID {enemy.Value.ActID} has AIControl -> {AIcontrol}");
                    }
                }
                state = 0;
                if (AIcontrol == true) { state = 1; }
                Game.variable.SetValue(GameVar.Inquisitor_AI, state);
            }
            else { Game.SetError(new Error(325, "[Alert] Can only change Inquisitor control status in Act Two")); }
        }


        /// <summary>
        /// handles all specific follower actions, returns a list of Snippets to World.UpdateWorldActivity (combined to generate notification message). Returns rumours only if Player at location.
        /// </summary>
        private List<Snippet> CheckFollowerActivity()
        {
            Game.logTurn?.Write("--- CheckFollowerActivity (World.cs)");
            int rumourID, refID;
            int numRumours = 0;
            RLColor backColor = Color._background4;
            List<Snippet> listData = new List<Snippet>();
            List<Snippet> listRumours = new List<Snippet>();
            //loop all active actors looking for followers
            foreach(var actor in dictActiveActors)
            {
                if (actor.Value is Follower)
                {
                    switch (actor.Value.Status)
                    {
                        case ActorStatus.AtLocation:
                            //get a rumour if in crow contact with player (any crow % > 0)
                            if (actor.Value.CrowChance > 0)
                            {
                                refID = ConvertLocToRef(actor.Value.LocID);
                                rumourID = Game.director.GetRumourUnknown(refID, actor.Value.ActID);
                                if (rumourID > 0)
                                {
                                    Rumour rumour = GetRumour(rumourID);
                                    if (rumour != null)
                                    {
                                        listRumours.Add(new Snippet(rumour.Text, RLColor.Black, backColor));
                                        listRumours.Add(new Snippet(""));
                                        AddRumourKnown(rumour.RumourID, rumour);
                                        numRumours++;
                                        Game.logTurn?.Write($"{actor.Value.Title} {actor.Value.Name}, ActID {actor.Value.ActID}, added RumourID {rumour.RumourID}");
                                        //handle special cases -> assumes that rumours are now known to the Player ('cause the Follower has auto sent a crow)
                                        Game.director.ResolveRumours(rumour);
                                        //if a timed rumour it'll need to be deleted from the dictionary
                                        if (rumour.Status == RumourStatus.Timed)
                                        { RemoveRumourTimed(rumourID); }
                                    }
                                    else { Game.SetError(new Error(276, $"Invalid rumour from RumourID {rumourID}")); }
                                }
                                else { Game.logTurn?.Write($"[Notification] No rumour returned for {actor.Value.Name} at {Game.display.GetLocationName(actor.Value.LocID)}"); }
                            }
                            else { Game.logTurn?.Write($"{actor.Value.Title} {actor.Value.Name}, ActID {actor.Value.ActID}, has no contact with the Player -> No rumours"); }
                            break;
                    }
                }
            }
            //if rumours present add to master list
            if (numRumours > 0)
            {
                listData.Add(new Snippet(string.Format("Your Followers have overheard {0} rumour{1}", numRumours, numRumours != 1 ? "s" : ""), RLColor.Red, backColor));
                listData.Add(new Snippet(""));
                listData.AddRange(listRumours);
                listData.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                listData.Add(new Snippet(""));
            }
            return listData;
        }


        /// <summary>
        /// tracks active and enemy actors at the start of each turn
        /// </summary>
        private void UpdateBloodHound()
        {
            BloodHound bloodhound = new BloodHound();
            //clear out temp lists
            listTempActiveActors.Clear();
            listTempEnemyActors.Clear();
            //active actors
            foreach (var active in dictActiveActors)
            {
                ActorSpy activeSpy = new ActorSpy(active.Value.ActID, active.Value.GetPosition(), active.Value.Status, active.Value.Known);
                listTempActiveActors.Add(activeSpy);
            }
            bloodhound.SetActiveActors(listTempActiveActors);
            //enemy actors
            foreach (var enemy in dictEnemyActors)
            {
                ActorSpy enemySpy = new ActorSpy(enemy.Value.ActID, enemy.Value.GetPosition(), enemy.Value.Status, enemy.Value.Known, enemy.Value.Goal, enemy.Value.HuntMode);
                listTempEnemyActors.Add(enemySpy);
            }
            bloodhound.SetEnemyActors(listTempEnemyActors);
            //add to dictionary
            try
            { dictBloodHound.Add(Game.gameTurn, bloodhound); }
            catch (ArgumentException)
            { Game.SetError(new Error(171, string.Format("Invalid gameTurn \"{0}\", (duplicate Entry) -> Bloodhound entry Not added", Game.gameTurn))); }
        }


        /// <summary>
        /// Places items within world
        /// </summary>
        private void InitialiseItemPlacement()
        {
            Game.logStart?.Write("--- InitialiseItemPlacement (World.cs)");
            //List of all Passive Items
            IEnumerable<Item> listItems =
                from items in dictPossessions.Values.OfType<Item>()
                where items.ItemType == PossItemType.Passive
                select items;
            List<Item> listPassiveItems = listItems.ToList();
            //get list of live Passive actors
            IEnumerable<Passive> listActors =
                from actors in dictPassiveActors
                where actors.Value.Status == ActorStatus.AtLocation && !(actors.Value is Special)
                select actors.Value;
            List<Passive> listPassiveActors = listActors.ToList();

            int rndIndex;
            int itemIndex;
            string startText;
            string endText;
            bool proceedFlag = true;
            //descriptive texts
            string[] arrayOfStartTexts = new string[] { "has been entrusted with keeping the", "has come into possession of the", "has stolen the", "is hording the" };
            string[] arrayOfEndTexts = new string[] { "safe from harm", "in mysterious circumstances", "and is desperate to keep it quiet", "safe from pyring eyes"  };
            //note that both Text arrays need to be identical lengths
            if (arrayOfStartTexts.Length != arrayOfEndTexts.Length)
            {
                proceedFlag = false;
                Game.SetError(new Error(235, "Text arrays have different lengths -> No secrets assigned"));
            }
            //assign all passive items to random actors
            for (int i = 0; i < listPassiveItems.Count; i++)
            {
                Item item = listPassiveItems[i];
                rndIndex = rnd.Next(listPassiveActors.Count);
                Passive passive = listPassiveActors[rndIndex];
                passive.AddItem(item.PossID);
                Game.logStart?.Write(string.Format("ItemID {0}, \"{1}\", given to {2} {3}, ActID {4}, at {5} {6}", item.ItemID, item.Description, passive.Title, passive.Name, passive.ActID,
                    Game.display.GetLocationName(passive.LocID), Game.display.GetLocationCoords(passive.LocID)));
                //item possession a secret? Not for a Lord (known)
                if (proceedFlag == true)
                {
                    if (passive.Type != ActorType.Lord)
                    {
                        itemIndex = rnd.Next(arrayOfStartTexts.Length);
                        startText = arrayOfStartTexts[itemIndex];
                        endText = arrayOfEndTexts[itemIndex];
                        string description = $"{passive.Name}, ActID {passive.ActID}, {startText} {item.Description}, ItemID {item.ItemID}, {endText}";
                        SecretActor secret = new SecretActor(PossSecretType.Item, Game.gameYear, description, 4, passive.ActID);
                        passive.AddSecret(secret.PossID);
                        AddPossession(secret.PossID, secret);
                        item.Active = false;
                        Game.logStart?.Write($"[Secret -> Item] {description}");
                    }
                    else { item.Active = true; }
                }
                listPassiveActors.RemoveAt(rndIndex);
            }

        }

        /// <summary>
        /// Set up a notification message (straight message, no user input). Will automatically add or append where necessary. Snippets should be pre-formatted
        /// </summary>
        /// <param name="notificationList"></param>
        public void SetNotification(List<Snippet> notificationList)
        {
            if (notificationList != null)
            {
                //take a list of snippets and set up ready to go. Might need to switch to special mode.
                if (notificationList.Count > 0)
                {
                    List<Snippet> eventList = new List<Snippet>();
                    RLColor backColor = Color._background1;
                    if (Game.infoChannel.GetListCount(ConsoleDisplay.Event) == 0)
                    {
                        //no existing records, create header
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("Hear Yea, Hear Yea, Hear Yea!", RLColor.Blue, backColor));
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                        eventList.Add(new Snippet(""));
                        eventList.AddRange(notificationList);
                        Game.infoChannel.SetInfoList(eventList, ConsoleDisplay.Event);
                    }
                    else
                    {
                        //existing records, append
                        foreach(Snippet snippet in notificationList)
                        { Game.infoChannel.AppendInfoList(snippet, ConsoleDisplay.Event);}
                    }
                    Game._specialMode = SpecialMode.Notification;
                }
                else { Game.SetError(new Error(223, "Invalid notificationList input (no records)")); }
            }
            else { Game.SetError(new Error(223, "Invalid notificationList input (null)")); }
        }

        /// <summary>
        /// Set up a confirmation message (message with Yes or No user input). Snippets should be pre-formatted. No appending takes place, one-shot only
        /// </summary>
        /// <param name="confirmationList"></param>
        public void SetConfirmation(List<Snippet> confirmationList)
        {
            if (confirmationList != null)
            {
                //take a list of snippets and set up ready to go. Might need to switch to special mode.
                if (confirmationList.Count > 0)
                {
                    List<Snippet> eventList = new List<Snippet>();
                    RLColor backColor = Color._background1;
                    //add new records
                    eventList.AddRange(confirmationList);
                    Game.infoChannel.ClearConsole(ConsoleDisplay.Event);
                    Game.infoChannel.SetInfoList(eventList, ConsoleDisplay.Event);
                    Game._specialMode = SpecialMode.Confirm;
                }
                else { Game.SetError(new Error(225, "Invalid confirmationList input (no records)")); }
            }
            else { Game.SetError(new Error(225, "Invalid confirmationList input (null)")); }
        }

        /// <summary>
        /// Updates world events and triggers a Notification message
        /// </summary>
        /// <returns></returns>
        private bool UpdateWorldStatus()
        {
            Game.logTurn?.Write("--- UpdateWorldStatus (World.cs)");
            bool notificationStatus = false;
            List<Snippet> eventList = new List<Snippet>();
            RLColor foreColor = RLColor.Black;
            RLColor backColor = Color._background1;
            //Follower Rumours
            eventList.AddRange(CheckFollowerActivity());
            //Player Rumours
            Player player = GetPlayer();
            if (player != null)
            {
                if (player.Conceal != ActorConceal.SafeHouse)
                {
                    switch (player.Status)
                    {
                        case ActorStatus.AtLocation:
                            //Market View
                            eventList.Add(new Snippet("The View from the Market", RLColor.Red, backColor));
                            eventList.Add(new Snippet(""));
                            eventList.AddRange(Game.director.GetMarketView());
                            eventList.Add(new Snippet(""));
                            break;
                        case ActorStatus.Travelling:
                            /*if (rnd.Next(100) < 20)
                            {
                                eventList.Add(new Snippet("The Word on the Road", RLColor.Red, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("A passing Merchant tells of trouble in the Court of Casterly Rock", foreColor, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                                eventList.Add(new Snippet(""));
                            }
                            break;*/
                        case ActorStatus.AtSea:
                            /*if (rnd.Next(100) < 20)
                            {
                                eventList.Add(new Snippet("The Word at Sea", RLColor.Red, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("The Captain tells tales of war in the far-off-lands", foreColor, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                                eventList.Add(new Snippet(""));
                            }
                            break;*/
                        case ActorStatus.Captured:
                            /*if (rnd.Next(100) < 20)
                            {
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("The Word in the Dungeon", RLColor.Red, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("You overhear a guard arguing with another prison about food shortages in the Castle", foreColor, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                                eventList.Add(new Snippet(""));
                            }*/
                            break;
                    }
                    //any world message to display?
                    if (eventList.Count > 0)
                    {
                        notificationStatus = true;
                        SetNotification(eventList);
                    }
                }
                else { Game.logTurn?.Write("[Notification] Player in SafeHouse -> World events cancelled"); }
            }
            else { Game.SetError(new Error(224, "Invalid player (null)")); }
            return notificationStatus;
        }


        /// <summary>
        /// Given an NPC's house, it works out another refID where the introduction can be used. 
        /// Randomly chooses from any other house where it has +rel's (first), if not then from houses with neutral relationships (zero)
        /// </summary>
        /// <param name="origRefID">RefID of house of NPC (assumed to be Major)</param>
        /// <returns></returns>
        public int GetIntroductionHouse(int origRefID)
        {
            int introRefID = 0; //introduction house (output)
            int refID = 0; //temp var
            int currentRel = 0;
            int searchRefID = origRefID; //searchRefID used for search
            //Bannerlord?
            if (origRefID > 100 && origRefID < 1000)
            { searchRefID = Game.world.GetLiegeLord(origRefID); }

            House npcHouse = GetHouse(searchRefID);
            List<int> listTempRefIDPositive = new List<int>(); //holds all Major houses where origHouse has +ve rel's (first choice for an introduction)
            List<int> listTempRefIDNeutral = new List<int>(); //holds all Major houses where origHouse has a neutral rel (second choice)
            Game.logTurn?.Write("--- GetIntroductionHouse (World.cs)");
            Player player = GetPlayer();
            if (player != null)
            {
                if (npcHouse != null)
                {
                    Game.logTurn?.Write($"Check Relations for House \"{npcHouse.Name}\" at {npcHouse.LocName}, RefID {searchRefID}");
                    //loop great Houses and get current relations
                    foreach (var house in dictMajorHouses)
                    {
                        refID = house.Value.RefID;
                        if (refID != searchRefID)
                        {
                            currentRel = npcHouse.GetCurrentRelationship(refID);
                            if (currentRel > 0)
                            {
                                listTempRefIDPositive.Add(refID);
                                Game.logTurn?.Write($"House \"{house.Value.Name}\" at {house.Value.LocName}, RefID {house.Value.RefID}, has a Rel level of +{currentRel} -> Added to List +ve's");
                            }
                            else if (currentRel == 0)
                            {
                                listTempRefIDNeutral.Add(refID);
                                Game.logTurn?.Write($"House \"{house.Value.Name}\" at {house.Value.LocName}, RefID {house.Value.RefID}, has a Rel level of {currentRel} -> Added to List Neutrals");
                            }
                            else { Game.logTurn?.Write($"House \"{house.Value.Name}\" at {house.Value.LocName}, RefID {house.Value.RefID}, has a Rel level of {currentRel} -> Ignored"); }
                        }
                    }
                    //Randomly choose one RefID from list of positive relations (first choice)
                    if (listTempRefIDPositive.Count > 0)
                    {
                        introRefID = listTempRefIDPositive[rnd.Next(listTempRefIDPositive.Count)];
                        player.AddIntroduction(introRefID);
                        Game.logTurn?.Write($"There are {listTempRefIDPositive.Count} records in listPositive to select from");
                        Game.logTurn?.Write($"House {GetHouseName(searchRefID)} has a Positive Relationship lvl with House \"{GetHouseName(introRefID)} -> Introduction Created");
                    }
                    //Look to list of houses with a neutral relationship as a second choice, if none with +ve rel's
                    else if (listTempRefIDNeutral.Count > 0)
                    {
                        introRefID = listTempRefIDNeutral[rnd.Next(listTempRefIDNeutral.Count)];
                        player.AddIntroduction(introRefID);
                        Game.logTurn?.Write($"There are {listTempRefIDNeutral.Count} records in listNeutral to select from");
                        Game.logTurn?.Write($"House {GetHouseName(searchRefID)} has a Neutral Relationship lvl with House \"{GetHouseName(introRefID)} -> Introduction Created");
                    }
                    else { Game.logTurn?.Write("[Alert] There are no Positive, or Neutral interHouse Relationships -> Introduction cancelled"); }
                }
                else { Game.SetError(new Error(240, $"Invalid npcHouse (null) for refID {searchRefID}")); }
            }
            else { Game.SetError(new Error(240, "Invalid player (null)")); }
            return introRefID;
        }

        /// <summary>
        /// Takes a BannerLord's RefID and returns the RefID of their Liege Lord. Returns '0' for an invalid conversion.
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        public int GetLiegeLord(int refID)
        {
            int liegeRefID = refID; //newRefID used for search
            //Bannerlord?
            if (refID > 100 && refID < 1000)
            {
                int houseID = ConvertRefToHouse(refID);
                if (houseID > 0)
                {
                    MajorHouse majorHouse = GetMajorHouse(houseID);
                    if (majorHouse != null)
                    {
                        //search on RefID of Bannerlord's liege Lord (introductions for a house are valid for Major and Minor houses)
                        liegeRefID = majorHouse.RefID;
                    }
                    else { Game.SetError(new Error(246, "Invalid MajorHouse (null) -> No conversion")); liegeRefID = 0; }
                }
                else { Game.SetError(new Error(246, "Invalid HouseID (zero, or less) -> No conversion")); liegeRefID = 0; }
            }
            else if (refID >= 1000)
            { Game.SetError(new Error(246, $"Invalid refID \"{refID}\" (too high) -> No conversion")); liegeRefID = 0; }
            return liegeRefID;
        }

        /// <summary>
        /// God Mode -> Change Player's known status to the opposite of whatever it is
        /// </summary>
        public List<Snippet> GodChangeKnownStatus()
        {
            Player player = GetPlayer();
            string text = "";
            List<Snippet> listText = new List<Snippet>();
            listText.Add(new Snippet("God Mode -> Change Player's Known Status", Color._godMode, RLColor.Black));
            if (player != null)
            {
                if (player.Known == true)
                {
                    //player becomes UNKNOWN
                    player.Known = false;
                    player.Revert = 0;
                    text = $"[God Mode] {player.Title} {player.Name} \"{player.Handle}\" Known Status changed to Unknown";
                    Game.world.SetMessage(new Message(text, MessageType.God));
                }
                else
                {
                    //player becomes KNOWN
                    player.Known = true;
                    player.Revert = Game.constant.GetValue(Global.KNOWN_REVERT);
                    player.TurnsUnknown = 0;
                    player.LastKnownLocID = player.LocID;
                    text = $"[God Mode] {player.Title} {player.Name} \"{player.Handle}\" Known Status changed to Known (reverts in {player.Revert} days)";
                    Game.world.SetMessage(new Message(text, MessageType.God));
                }
            }
            else { Game.SetError(new Error(248, "Invalid Player (null)"));}
            listText.Add(new Snippet(text));
            return listText;
        }


        /// <summary>
        /// Sets up Safe Houses at Game Start
        /// </summary>
        internal void InitialiseSafeHouses()
        {
            Game.logStart?.Write("--- InitialiseSafeHouse (World.cs)");
            int oldKingRefID = Game.lore.RoyalRefIDOld;
            int chanceSafeHouse = Game.constant.GetValue(Global.SAFE_HOUSE);
            //Major Houses
            for (int i = 0; i < dictAllHouses.Count; i++)
            {
                House house = dictAllHouses.ElementAt(i).Value;
                if (house != null)
                {
                    //supports old King -> automatically have a safe house and auto known
                    if (house.Loyalty_Current == KingLoyalty.Old_King && house.RefID != oldKingRefID )
                    {
                        if (house is MajorHouse)
                        {
                            //randomly allocate a safe house rating of between 3 and 5
                            house.SafeHouse = rnd.Next(3, 6);
                            Game.logStart?.Write($"House {house.Name} at \"{house.LocName}\" has a SafeHouse rating of {house.SafeHouse} stars");
                            house.SetInfoStatus(HouseInfo.SafeHouse);
                        }
                        else if (house is MinorHouse)
                        {
                            //randomly allocate a safe house rating of between 1 and 2
                            house.SafeHouse = rnd.Next(1, 3);
                            Game.logStart?.Write($"BannerLord House {house.Name} at \"{house.LocName}\" has a SafeHouse rating of {house.SafeHouse} stars");
                            house.SetInfoStatus(HouseInfo.SafeHouse);
                        }
                    }
                    //random chance of a safe house elsewhere (supporters of New King) -> Safe Houses not known about at game start (rumours)
                    else if (rnd.Next(100) <= chanceSafeHouse)
                    {
                        if (house is MajorHouse)
                        {
                            //randomly allocate a safe house rating of between 3 and 5
                            house.SafeHouse = rnd.Next(3, 6);
                            Game.logStart?.Write($"[Supports New King] House {house.Name} at \"{house.LocName}\" has a SafeHouse rating of {house.SafeHouse} stars -> Rumour created");
                        }
                        else if (house is MinorHouse)
                        {
                            //randomly allocate a safe house rating of between 1 and 2
                            house.SafeHouse = rnd.Next(1, 3);
                            Game.logStart?.Write($"[Supports New King] BannerLord House {house.Name} at \"{house.LocName}\" has a SafeHouse rating of {house.SafeHouse} stars -> Rumour created");
                        }
                    }
                }
                else { Game.SetError(new Error(249, "Invalid house (null)")); }
            }
        }


        /// <summary>
        /// Imports Disguises and seeds them with friendly advisors in the world
        /// </summary>
        internal void InitialiseDisguises()
        {
            Game.logStart?.Write("--- InitialiseDisguises (World.cs)");
            List<DisguiseStruct> listOfDisguises = Game.file.GetDisguises("Disguises.txt");
            int relThreshold = Game.constant.GetValue(Global.TALK_THRESHOLD);
            List<Advisor> listOfMaesters = new List<Advisor>();
            List<Advisor> listOfCastellans = new List<Advisor>();
            List<Advisor> listOfSeptons = new List<Advisor>();
            //Obtain a list of Friendly Noble Advisors
            IEnumerable<Advisor> advisorActors =
                from actors in dictPassiveActors.Values.OfType<Advisor>()
                where actors.advisorNoble > AdvisorNoble.None && actors.Status == ActorStatus.AtLocation && actors.Loyalty_Current == KingLoyalty.Old_King
                select actors;
            List<Advisor> listLoyalAdvisors = advisorActors.ToList();
            int numAdvisors = listLoyalAdvisors.Count();
            if (numAdvisors <= 0) { Game.SetError(new Error(259, "Invalid numAdvisors (zero) -> No disguises allocated within world")); }
            else { Game.logStart?.Write($"listLoyalAdvisors -> {numAdvisors} records"); }
            //loop advisors and assign to correct list
            foreach(var advisor in listLoyalAdvisors)
            {
                switch(advisor.advisorNoble)
                {
                    case AdvisorNoble.Maester:
                        listOfMaesters.Add(advisor);
                        break;
                    case AdvisorNoble.Castellan:
                        listOfCastellans.Add(advisor);
                        break;
                    case AdvisorNoble.Septon:
                        listOfSeptons.Add(advisor);
                        break;
                    default:
                        Game.SetError(new Error(259, $"Invalid advisorNoble type \"{advisor.advisorNoble}\" -> Advisor not placed in specailised list"));
                        break;
                }
            }
            //how many in each
            int countMaesters = listOfMaesters.Count; Game.logStart?.Write($"listOfMaesters -> {countMaesters} records");
            int countCastellans = listOfCastellans.Count; Game.logStart?.Write($"listOfCastellans -> {countCastellans} records");
            int countSeptons = listOfSeptons.Count; Game.logStart?.Write($"listOfSeptons -> {countSeptons} records");
            //loop through disguises
            foreach (var structDisguise in listOfDisguises)
            {
                //create instance of object
                Disguise disguise = new Disguise(structDisguise.Name, structDisguise.Strength);
                if (disguise != null)
                {
                    //add to Possessions dict
                    if (AddPossession(disguise.PossID, disguise) == true)
                    {
                        //assign to a random Advisor
                        if (numAdvisors > 0)
                        {
                            Advisor advisor = null;
                            switch (structDisguise.Type)
                            {
                                case AdvisorNoble.Maester:
                                    //prioritise giving disguise to a Maester
                                    if (countMaesters > 0)
                                    { advisor = listOfMaesters[rnd.Next(countMaesters)];  }
                                    break;
                                case AdvisorNoble.Castellan:
                                    //prioritise giving disguise to a Castellan
                                    if ( countCastellans > 0)
                                    { advisor = listOfCastellans[rnd.Next(countCastellans)]; }
                                    break;
                                case AdvisorNoble.Septon:
                                    //prioritise giving disguise to a Septon
                                    if (countSeptons > 0)
                                    { advisor = listOfSeptons[rnd.Next(countSeptons)]; }
                                    break;
                                default:
                                    Game.SetError(new Error(259, $"Invalid advisorNoble type \"{advisor.advisorNoble}\" -> Disguise not assigned to an Advisor"));
                                    break;
                            }
                            //found an advisor of the correct type?
                            if (advisor != null)
                            { advisor.AddDisguise(disguise.PossID); }
                            else
                            {
                                //if not then use another advisor from master list
                                advisor = listLoyalAdvisors[rnd.Next(numAdvisors)];
                                if (advisor != null)
                                { advisor.AddDisguise(disguise.PossID); }
                                else { Game.SetError(new Error(259, "Invalid advisor (null)")); }
                            }
                            //admin
                            if (advisor != null)
                            { Game.logStart?.Write($"{advisor.Title} {advisor.Name}, ActID {advisor.ActID} assigned Disguise \"{disguise.Description}\", PossID {disguise.PossID}"); }
                            else
                            { Game.logStart?.Write($"[Alert] Invalid advisor (null), Disguise \"{disguise.Description}\", PossID {disguise.PossID} Not placed in the world)"); }
                        }
                    }
                }
                else { Game.SetError(new Error(259, "Invalid disguise (null) -> not added to Dictionary")); }
            }
        }


        /// <summary>
        /// Toggles disguise on/off
        /// </summary>
        internal List<Snippet> ChangeDisguise()
        {
            Game.logTurn?.Write("--- ChangeDisguise (World.cs)");
            Player player = GetPlayer();
            List<Snippet> listToDisplay = new List<Snippet>();
            RLColor concealColor = RLColor.Yellow;
            string description = "";
            if (player != null)
            {
                if (player.ConcealDisguise > 0)
                {
                    Possession possession = GetPossession(player.ConcealDisguise);
                    if (possession is Disguise)
                    {
                        Disguise disguise = possession as Disguise;
                        switch (player.Conceal)
                        {
                            case ActorConceal.Disguise:
                                //remove disguise
                                description = $"{player.Name} \"{player.Handle}\" has removed their disguise of {disguise.Description}";
                                SetMessage(new Message(description, MessageType.Search));
                                SetPlayerRecord(new Record(description, 1, player.LocID, CurrentActorEvent.Search));
                                Game.logTurn?.Write(description);
                                player.Conceal = ActorConceal.None;
                                player.ConcealLevel = 0;
                                player.ConcealText = "None";
                                break;
                            case ActorConceal.SafeHouse:
                                //can't use disguises within a safe house
                                description = $"{player.Name} is currently at {player.ConcealText} SafeHouse and is unable to don a disguise";
                                concealColor = RLColor.LightRed;
                                break;
                            case ActorConceal.None:
                                //puts the disguise on
                                player.Conceal = ActorConceal.Disguise;
                                player.ConcealLevel = disguise.Strength;
                                player.ConcealText = disguise.Description;
                                description = $"{player.Name} \"{player.Handle}\" has assumed the disguise of {disguise.Description}";
                                SetMessage(new Message(description, MessageType.Search));
                                SetPlayerRecord(new Record(description, 1, player.LocID, CurrentActorEvent.Search));
                                //player becomes UNKNOWN, if already Known
                                if (player.Known == true)
                                {
                                    string knownText = $"{player.Name} \"{player.Handle}\" Known Status changed to Unknown as a result of assuming their Disguise";
                                    Game.world.SetMessage(new Message(knownText, MessageType.Search));
                                    player.Known = false;
                                    player.Revert = 0;
                                }
                                break;
                            default:
                                Game.SetError(new Error(253, $"Invalid player.Conceal type \"{player.Conceal}\""));
                                break;
                        }
                    }
                    else { Game.SetError(new Error(253, $"Invalid possession type (Not disguise) for player.ConcealDisguise PossID {player.ConcealDisguise}")); }
                }
                else
                {
                    description = "The Player doesn't have a disguise";
                    concealColor = RLColor.LightRed;
                    Game.logTurn?.Write($"[Alert] {description} (Player attempted to don a disguise");
                }
            }
            else { Game.SetError(new Error(253, "Invalid Player (null)")); }
            //set up snippet list
            if (description.Length > 0)
            { listToDisplay.Add(new Snippet(description, concealColor, RLColor.Black)); }
            else { listToDisplay.Add(new Snippet("Error in ChangeDisguise", RLColor.LightRed, RLColor.Black)); }
            return listToDisplay;
        }

        /// <summary>
        /// Sets the values of any GameVars at game start
        /// </summary>
        private void InitialiseGameVars()
        {
            Game.logTurn?.Write("--- InitialiseGameVars (World.cs)");
            int numOfMarketViews = 7;
            Game.variable.SetValue(GameVar.View_Index, rnd.Next(1, numOfMarketViews));
            Game.variable.SetValue(GameVar.View_Rollover, numOfMarketViews);
            Game.variable.SetValue(GameVar.Account_Timer, Game.constant.GetValue(Global.ACCOUNT_INTERVAL));
            Game.variable.SetValue(GameVar.Corruption_Factor, Game.constant.GetValue(Global.CORRUPTION_COST));
            Game.variable.SetValue(GameVar.God_PlayerLocID, 1); //set to Capital
            Game.variable.SetValue(GameVar.Inquisitor_AI, 1); //set to AI control (both Acts)
            if (Game.gameAct == Act.One)
            {
                Game.variable.SetValue(GameVar.Inquisitor_Target, 1); //player as target
            }
            else if (Game.gameAct == Act.Two)
            {
                //debug
                Game.variable.SetValue(GameVar.Inquisitor_Target, 25); //random NPC
            }
        }


        /// <summary>
        /// returns a random Major house name
        /// </summary>
        /// <returns></returns>
        internal string GetRandomMajorHouseName()
        {
            int count = dictMajorHouses.Count;
            return dictMajorHouses.ElementAt(rnd.Next(count)).Value.Name;
        }

        /// <summary>
        /// assigns LocTypes to all Houses and Loc's
        /// </summary>
        private void InitialiseLocTypes()
        {
            int locID;
            foreach(var house in dictAllHouses)
            {
                locID = house.Value.LocID;
                Location loc = Game.network.GetLocation(locID);
                if (loc != null)
                {
                    if (house.Value is MajorHouse) { loc.Type = LocType.MajorHouse; house.Value.Type = LocType.MajorHouse; }
                    else if (house.Value is MinorHouse) { loc.Type = LocType.MinorHouse; house.Value.Type = LocType.MinorHouse; }
                    else if (house.Value is InnHouse) { loc.Type = LocType.Inn; house.Value.Type = LocType.Inn; }
                }
                else { Game.SetError(new Error(294, $"Invalid Loc (null), LocID \"{locID}\" -> LocType not assigned to house or Loc")); }
            }
        }

        /// <summary>
        /// Get list of Move objects
        /// </summary>
        /// <returns></returns>
        internal List<Move> GetMoveObjects()
        { return listMoveObjects; }

        /// <summary>
        /// Run from ProcessGameStart -> handles all the last minute player stuff
        /// </summary>
        private void InitialiseFinalPlayer()
        {
            Game.logTurn?.Write("--- InitialiseFinalPlayer (World.cs)");
            //Player's start location added to dict & list
            Player player = GetPlayer();
            Game.director.AddVisitedLoc(player.LocID, 0);
            //Horse
            GetNewHorse();
        }

        /// <summary>
        /// get Player a new horse and take care of all the details
        /// </summary>
        public void GetNewHorse()
        {
            Player player = Game.world.GetPlayer();
            if (player != null)
            {
                player.HorseName = Game.director.GetAssortedRandom(Assorted.HorseName);
                player.HorseType = Game.director.GetAssortedRandom(Assorted.HorseType);
                int health = rnd.Next(1, 10);
                health = Math.Min(5, Game.constant.GetValue(Global.HORSE_HEALTH)); //max capped at 5, min capped at 1
                player.HorseHealth = health;
                player.HorseMaxHealth = health;
                if (player.Status == ActorStatus.AtLocation) { player.horseStatus = HorseStatus.Stabled; }
                else { player.horseStatus = HorseStatus.Normal; }
                player.HorseDays = 1;
                player.SetTravelMode(TravelMode.Mounted);
                //admin
                string text = $"{player.Name} has acquired a new horse, a {player.HorseType} named \"{player.HorseName}\" (stamina {player.HorseHealth})";
                SetMessage(new Message(text, 1, player.LocID, MessageType.Horse));
                SetPlayerRecord(new Record(text, 1, player.LocID, CurrentActorEvent.Horse));
            }
        }

        /// <summary>
        /// create a new record of a dead/gone horse and add to list
        /// </summary>
        /// <param name="gone"></param>
        /// <param name="locText">descriptive -> 'On the road to...', 'At ....', etc.</param>
        internal void CreateHorseRecord(HorseGone gone, string locText)
        {
            if (gone != HorseGone.None)
            {
                if (String.IsNullOrEmpty(locText) == false)
                {
                    Player player = GetPlayer();
                    if (player != null)
                    {
                        HorseRecord horseRec = new HorseRecord();
                        horseRec.Name = player.HorseName;
                        horseRec.Type = player.HorseType;
                        horseRec.Health = player.HorseMaxHealth;
                        horseRec.Days = player.HorseDays;
                        horseRec.Gone = gone;
                        horseRec.Turn = Game.gameTurn;
                        horseRec.LocText = locText;
                        //add to list
                        listHorses.Add(horseRec);
                        Game.logTurn?.Write($"[Horse Record Added] \"{horseRec.Name}\" was {horseRec.Gone} {horseRec.LocText} on turn {horseRec.Turn}");
                    }
                    else { Game.SetError(new Error(301, "Invalid Player (null) -> No record created")); }
                }
                else { Game.SetError(new Error(301, "Invalid locText (null or MT) -> No record created")); }
            }
            else { Game.SetError(new Error(301, "Invalid HorseGone reason ('None') -> No record created")); }
        }

        /// <summary>
        /// gives houses population, Men At Arms, food data, resources and castle walls
        /// </summary>
        private void InitialiseHouseData()
        {
            Game.logStart?.Write("--- InitialiseHouseData (World.cs)");
            int timeSpan = Game.constant.GetValue(Global.GAME_REVOLT) - Game.constant.GetValue(Global.GAME_PAST);
            int timeBase = Game.constant.GetValue(Global.GAME_PAST);
            //Men at Arms drives all pop matters. Assumed to be 4 other people for every able bodied man
            int menAtArms = Game.constant.GetValue(Global.MEN_AT_ARMS);
            int popFactor = Game.constant.GetValue(Global.POPULATION_FACTOR);
            int foodCapacity = Game.constant.GetValue(Global.FOOD_CAPACITY);
            int goodsMinTerrain = Game.constant.GetValue(Global.GOODS_FACTOR); //number of terrain squares in 3 x 3 grid needed to qualify for a particular good
            int goodsLow = Game.constant.GetValue(Global.GOODS_LOW); //% chance of a low probability good being present
            int goodsMed = Game.constant.GetValue(Global.GOODS_MED); //% chance of a medium probability good being present
            int loanChance = Game.constant.GetValue(Global.LOAN_CHANCE); //% chance of new king taking on loans to make up a resource shortfall
            int food, balance, absBalance, tally, resources, numLocs, modifier, granary, stockFactor;
            int overallTally = 0;
            string descriptor;
            //
            // Men At Arms and Population (MenAtArms done earlier in InitialiseHouses due to need for data then but redo here with different stats if need be)
            //
            foreach (var house in dictAllHouses)
            {
                food = 0;
                if (house.Value is MajorHouse)
                {
                    house.Value.MenAtArms = menAtArms;
                    house.Value.Population = house.Value.MenAtArms * popFactor;
                }
                else if (house.Value is MinorHouse)
                {
                    house.Value.MenAtArms = menAtArms / 2;
                    house.Value.Population = house.Value.MenAtArms * popFactor;
                }
                else if (house.Value is CapitalHouse)
                {
                    house.Value.MenAtArms = menAtArms; //City Watch
                    house.Value.Population = house.Value.MenAtArms * popFactor * 3;
                }
                //
                //Goods & food production capacity
                //
                Location loc = Game.network.GetLocation(house.Value.LocID);
                if (loc != null)
                {
                    food = loc.NumPlain * foodCapacity;
                    food += loc.NumSea * foodCapacity / 2;
                    food += loc.NumForest * foodCapacity / 4;
                    house.Value.FoodCapacity = food;
                    Game.logStart?.Write($"House {house.Value.Name} at {house.Value.LocName} -> MenAtArms {house.Value.MenAtArms}, Population {house.Value.Population}, Food Capacity {house.Value.FoodCapacity}");
                    //Importer or Exporter of food if Abs(food balance) > foodCapacity
                    balance = house.Value.FoodCapacity - house.Value.Population;
                    //Food stockpile in granary? (higher chance if an ongoing food surplus)
                    if (balance > 0) { stockFactor = foodCapacity; } else { stockFactor = foodCapacity * 3; }
                    granary = (stockFactor - rnd.Next(0, foodCapacity / 1000 * 4) * 1000);
                    if (granary > 0)
                    {
                        house.Value.FoodStockpile = granary;
                        Game.logStart?.Write($"House {house.Value.Name} at {house.Value.LocName} has a food surplus (granary) of {granary}");
                        descriptor = $"There is food in the granary as a result of astute management and a productive previous season";
                        Record record = new Record(descriptor, house.Value.LocID, house.Value.RefID, Game.gameYear, HistHouseEvent.Food);
                        SetHistoricalRecord(record);
                    }
                    
                    descriptor = "";
                    if (Math.Abs(balance) > foodCapacity)
                    {
                        if (balance > 0)
                        {
                            house.Value.AddExport(Goods.Food); Game.logStart?.Write($"{house.Value.Name} Exports Food");
                            descriptor = "Fertile fields provide a surplus of food which is exported for a profit";
                        }
                        else
                        {
                            house.Value.AddImport(Goods.Food); Game.logStart?.Write($"{house.Value.Name} Imports Food");
                            descriptor = "A shortage of arable land creates a food shortfall which is made up by imports from elsewhere at a cost to the economy";
                        }
                        if (descriptor.Length > 0)
                        {
                            //add record to house
                            Record record = new Record(descriptor, house.Value.LocID, house.Value.RefID, timeBase + rnd.Next(timeSpan), HistHouseEvent.Food);
                            SetHistoricalRecord(record);
                        }
                    }
                    if (loc.NumMountain >= goodsMinTerrain)
                    {
                        //Iron -> Medium frequency
                        if (rnd.Next(100) <= goodsMed) { house.Value.AddExport(Goods.Iron); Game.logStart?.Write($"House {house.Value.Name} Exports Iron"); }
                        //Gold -> Low frequency
                        if (rnd.Next(100) <= goodsLow) { house.Value.AddExport(Goods.Gold); Game.logStart?.Write($"House {house.Value.Name} Exports Gold"); }
                    }
                    if (loc.NumForest >= goodsMinTerrain)
                    {
                        //Timber -> Medium frequency
                        if (rnd.Next(100) <= goodsMed) { house.Value.AddExport(Goods.Timber); Game.logStart?.Write($"House {house.Value.Name} Exports Timber"); }
                        //Furs -> Low frequency
                        if (rnd.Next(100) <= goodsLow) { house.Value.AddExport(Goods.Furs); Game.logStart?.Write($"House {house.Value.Name} Exports Furs"); }
                    }
                    //Oil -> Low frequency
                    if (loc.NumSea >= goodsMinTerrain)
                    { if (rnd.Next(100) <= goodsLow) { house.Value.AddExport(Goods.Oil); Game.logStart?.Write($"House {house.Value.Name} Exports Oil"); } }

                    if (loc.NumPlain >= goodsMinTerrain)
                    {
                        //Wine -> Low frequency
                        if (rnd.Next(100) <= goodsLow) { house.Value.AddExport(Goods.Wine); Game.logStart?.Write($"House {house.Value.Name} Exports Wine"); }
                        //Wool -> Low frequency
                        if (rnd.Next(100) <= goodsLow) { house.Value.AddExport(Goods.Wool); Game.logStart?.Write($"House {house.Value.Name} Exports Wool"); }
                    }
                }
                else { Game.SetError(new Error(303, $"Invalid loc (null) for house {house.Value.Name}")); }
            }
            //
            //Adjust resource levels to reflect trade goods situation (all start from a base level of 1)
            //
            int foodLimit = 2 * foodCapacity; //threshold for the effect of food surplus/deficit being small or large
            foreach (var house in dictAllHouses)
            {
                tally = 0;
                //take care of individual house first -> food (+/- 1/2 depending on severity of balance)
                balance = house.Value.GetFoodBalance();
                absBalance = Math.Abs(balance);
                if (absBalance > foodLimit )
                {
                    if (balance < 0) { tally -= 2; arrayTradeData[(int)Goods.Food] -= 1; }
                    else { tally += 2; arrayTradeData[(int)Goods.Food] += 1; }
                }
                //must be more than a minimum and less than the limit
                else if (absBalance <= foodLimit && absBalance > (foodCapacity/2))
                {
                    if (balance < 0) { tally -= 1; arrayTradeData[(int)Goods.Food] -= 1; }
                    else { tally += 1; arrayTradeData[(int)Goods.Food] += 1; }
                }
                //goods -> exports as food is the only import and it's already been catered for
                Goods good = Goods.None;
                if (house.Value.GetNumExports() > 0)
                {
                    int[,] tempGoods = house.Value.GetExports();
                    for(int i = 0; i < tempGoods.GetUpperBound(0); i++)
                    {
                        if (tempGoods[i, 0] > 0)
                        {
                            descriptor = "";
                            good = (Goods)i;
                            //different goods have different effects
                            switch (good)
                            {
                                case Goods.Gold:
                                    tally += 3;
                                    arrayTradeData[(int)Goods.Gold] += 1;
                                    descriptor = "Rich Veins of Gold mined from within the nearby mountains provide a significant boost to the economy";
                                    break;
                                case Goods.Wine:
                                    tally += 2;
                                    arrayTradeData[(int)Goods.Wine] += 1;
                                    descriptor = "Fine Wines made from high yielding Grapes provide a sizeable boost to the economy";
                                    break;
                                case Goods.Furs:
                                    tally += 1;
                                    arrayTradeData[(int)Goods.Furs] += 1;
                                    descriptor = "Thick Furs from the hunting and trapping of animals in the nearby forests provide a boost to the economy";
                                    break;
                                case Goods.Oil:
                                    tally += 1;
                                    arrayTradeData[(int)Goods.Oil] += 1;
                                    descriptor = "Oil distilled from the hunting of Whales provide a boost to the economy";
                                    break;
                                case Goods.Iron:
                                    tally += 1;
                                    arrayTradeData[(int)Goods.Iron] += 1;
                                    descriptor = "Deposits of Iron located in the nearby mountains provide a boost to the economy";
                                    break;
                                case Goods.Timber:
                                    tally += 1;
                                    arrayTradeData[(int)Goods.Timber] += 1;
                                    descriptor = "An abundance of Timer in the nearby Forests provide a boost to the economy";
                                    break;
                            }
                            if (descriptor.Length > 0)
                            {
                                //add record to house
                                Record record = new Record(descriptor, house.Value.LocID, house.Value.RefID, timeBase + rnd.Next(timeSpan), HistHouseEvent.Goods);
                                SetHistoricalRecord(record);
                            }
                        }
                    }
                }
                //keep tabs of overallTally
                overallTally += tally;
                //adjust house Resource level (allowable range of 1 to 5)
                resources = house.Value.Resources;
                resources += tally;
                resources = Math.Min(5, resources);
                resources = Math.Max(1, resources);
                house.Value.Resources = resources;
                Game.logStart?.Write($"House {house.Value.Name} has a Resource level of {resources}");
                //
                //adjust Castle walls to reflect resource level (properous houses are more likely to have stronger castles) -> Base value from Major/Minorhouse.txt's
                //
                if (house.Value.Special == HouseSpecial.None)
                {
                    int origValue = house.Value.CastleWalls;
                    descriptor = "";
                    switch (resources)
                    {
                        case 4:
                            //DM +1
                            house.Value.CastleWalls += 1;

                            break;
                        case 5:
                            //DM +2
                            house.Value.CastleWalls += 2;
                            break;
                    }
                    //limit check
                    house.Value.CastleWalls = Math.Min(5, house.Value.CastleWalls);
                    house.Value.CastleWalls = Math.Max(1, house.Value.CastleWalls);
                    if (origValue != house.Value.CastleWalls)
                    {
                        Game.logStart?.Write($"House {house.Value.Name} -> CastleWalls Now {house.Value.CastleWalls}, Before {origValue}, Resources {house.Value.Resources} ");
                        //add record to house
                        descriptor = "A strong economy has allowed the castle walls to be upgraded";
                        Record record = new Record(descriptor, house.Value.LocID, house.Value.RefID, timeBase + rnd.Next(timeSpan / 2, timeSpan), HistHouseEvent.Goods);
                        SetHistoricalRecord(record);
                    }
                }
            }
            //end all houses loop
            arrayTradeData[0] = overallTally;
            //Capital Resources
            CapitalHouse capital = GetCapital();
            if (capital != null)
            {
                resources = capital.Resources;
                numLocs = Game.network.GetNumLocations();
                resources = overallTally / numLocs;
                resources = Math.Min(5, resources);
                resources = Math.Max(1, resources);
                capital.Resources += resources;
                Game.logStart?.Write($"Capital has resources level of {capital.Resources}, overallTally {overallTally}, Locs {numLocs}, Modifier {overallTally / numLocs}");
                //Any loans taken out by new King?
                int deficit = 5 - capital.Resources;
                if (deficit > 0)
                {
                    for (int i = 0; i < deficit; i++)
                    {
                        if (rnd.Next(100) < loanChance)
                        {
                            //king takes on a loan
                            capital.Resources++;
                            Finance loan = (Finance)rnd.Next(1, (int)Finance.Count);
                            capital.AddLoan(loan);
                            Game.logStart?.Write($"The New King has taken on a Loan with the {loan}, Capital resources now {capital.Resources}");
                        }
                    }
                }
            }
            else { Game.SetError(new Error(303, "Invalid Capital (null) -> Resources not adjusted")); }
            //
            //Major House Resources -> adjusted for wealth of bannerLords -> + (total Bannerlord Resources - Num BannerLords) / 3
            //
            foreach(var major in dictMajorHouses)
            {
                modifier = 0;
                if (major.Value.GetNumBannerLords() > 0)
                {
                    List<int> listBannerLords = major.Value.GetBannerLords();
                    for (int i = 0; i < listBannerLords.Count; i++)
                    {
                        House bannerLord = GetHouse(listBannerLords[i]);
                        modifier += bannerLord.Resources;
                    }
                }
                if (modifier > 0)
                {
                    resources = major.Value.Resources;
                    resources += (modifier - major.Value.GetNumBannerLords()) / 3;
                    resources = Math.Min(5, resources);
                    major.Value.Resources = resources;
                    Game.logStart?.Write($"House {major.Value.Name}, Resources {resources}, Modifier {modifier}, Num BannerLords {major.Value.GetNumBannerLords()}");
                    //add record to house
                    descriptor = $"Bannerlords with valuable exports have provided a boost to the House {major.Value.Name} economy";
                    Record record = new Record(descriptor, major.Value.LocID, major.Value.RefID, timeBase + rnd.Next(timeSpan/2, timeSpan), HistHouseEvent.Goods);
                    SetHistoricalRecord(record);
                }
            }
            //
            // Capital Imports (all exports other than Capitals)
            //
            CapitalHouse capitalHouse = GetCapital();
            int existing;
            if (capitalHouse != null)
            {
                int[,] arrayCapitalImports = capitalHouse.GetImports();
                int[,] arrayCapitalExports = capitalHouse.GetExports();
                //should be of identical lengths (use GetUpperBound for both as apples for apples)
                if (arrayCapitalExports.GetUpperBound(0) == arrayTradeData.GetUpperBound(0))
                {
                    Game.logStart?.Write($"- Capital Imports");
                    for (int i = 1; i < arrayTradeData.Length; i++)
                    {
                        //all other house exports become capital imports
                        existing = arrayCapitalExports[i, 0];
                        arrayCapitalImports[i, 0] += arrayTradeData[i] - arrayCapitalExports[i, 0];
                        arrayCapitalImports[i, 0] = Math.Max(0, arrayCapitalImports[i, 0]);
                        Game.logStart?.Write($"{(Goods)i} x {arrayCapitalImports[i, 0]}");
                    }
                }
                else { Game.SetError(new Error(303, "Array lengths don't match, ArrayCapitalImports & arrayTradeData -> Capital Imports not calculated")); }
                //
                // Capital Groups -> initial relationship levels
                //
                int lower, upper;
                int kingWits = Game.lore.NewKing.GetSkill(SkillType.Wits);
                //adjust range of possible relationship levels by King's wits. Higher wits, tighter lower range, lower wits, wider lower range
                lower = 0 + (kingWits - 1) * 10;
                upper = 100;
                Game.logStart?.Write($"[Group Relations] King's Wits {kingWits}, Range -> lower {lower} to upper {upper}");
                for(int i = 2; i < (int)WorldGroup.Count; i++)
                { capitalHouse.SetGroupRelations((WorldGroup)i, rnd.Next(lower, upper)); }
                //Lords is the average of all Major Lords rels
                capitalHouse.SetGroupRelations(WorldGroup.Lord, GetAverageLordRelations());
                //
                // Relationships with Lender (actual if loans and possible future lenders)
                //
                for (int i = 1; i < (int)Finance.Count; i++)
                {
                    //capital.SetLenderRelations((Finance)i, rnd.Next(100)); 
                    capitalHouse.SetFinanceData(Account.Lender, i, rnd.Next(100));
                }
                //Merchant Guild relationship  same as King's relationship with Merchants
                int relLvl = capitalHouse.GetGroupRelations(WorldGroup.Merchant);
                capitalHouse.SetFinanceData(Account.Lender, (int)Finance.Merchant_Guild, relLvl);
            }
            else { Game.SetError(new Error(303, "Invalid capitalHouse (null)")); }

        }

        /// <summary>
        /// Gets Info for ShowFoodRL
        /// </summary>
        /// <param name="mode"></param>
        /// <returns></returns>
        public List<String> GetFoodInfo(FoodInfo mode)
        {
            int food, population, balance;
            List<string> tempList = new List<String>();
            switch (mode)
            {
                case FoodInfo.Surplus:
                    IEnumerable<string> surplusHouses =
                        from house in dictAllHouses
                        let surplus = house.Value.GetFoodBalance()
                        where surplus > 0
                        orderby surplus descending
                        select Convert.ToString($"House {house.Value.Name} at {house.Value.LocName}, {Game.display.GetLocationCoords(house.Value.LocID)}, has a food Surplus of {surplus:N0}");
                    tempList = surplusHouses.ToList();
                    break;
                case FoodInfo.Deficit:
                    IEnumerable<string> deficitHouses =
                        from house in dictAllHouses
                        let deficit = house.Value.GetFoodBalance()
                        where deficit < 0
                        orderby deficit
                        select Convert.ToString($"House {house.Value.Name} at {house.Value.LocName}, {Game.display.GetLocationCoords(house.Value.LocID)}, has a food Deficit of {deficit:N0}");
                    tempList = deficitHouses.ToList();
                    break;
                case FoodInfo.House:
                    Dictionary<int, int> tempHouseDict = new Dictionary<int, int>(); //key is RefId, value is surplus
                    foreach(var house in dictMajorHouses)
                    {
                        food = house.Value.FoodCapacity;
                        population = house.Value.Population;
                        List<int> listBanners = house.Value.GetBannerLords();
                        if (listBanners != null)
                        {
                            for (int i = 0; i < listBanners.Count; i++)
                            {
                                House bannerHouse = GetHouse(listBanners[i]);
                                if (bannerHouse != null)
                                {
                                    food += bannerHouse.FoodCapacity;
                                    population += bannerHouse.Population;
                                }
                                else { Game.SetError(new Error(304, $"Invalid bannerHouse RefID {listBanners[i]}")); }
                            }
                        }
                        else { Game.SetError(new Error(304, "Invalid listBanners (null)")); }
                        balance = food - population;
                        tempHouseDict.Add(house.Value.RefID, balance);
                    }
                    //add capital
                    CapitalHouse capital = GetCapital();
                    if (capital != null)
                    { tempHouseDict.Add(9999, capital.FoodCapacity - capital.Population); }
                    //sort dictionary by balance
                    var items = from foodBalance in tempHouseDict
                                orderby foodBalance.Value descending
                                select foodBalance;
                    //place into the list
                    foreach(var houseData in items)
                    { tempList.Add($"House {GetHouseName(houseData.Key)} has a food balance of {houseData.Value:N0}"); }
                    break;
                case FoodInfo.Branch:
                    Dictionary<int, int> tempBranchDict = new Dictionary<int, int>(); //key is BranchID, value is surplus
                    int[,] branchArray = new int[5, 2]; //x -> 0 Capital, 1 north, 2 east, 3 south, 4 west [x ,0] Population [x ,1] Food
                    foreach (var house in dictAllHouses)
                    {
                        switch(house.Value.Branch)
                        {
                            case 0:
                                branchArray[0, 0] += house.Value.Population;
                                branchArray[0, 1] += house.Value.FoodCapacity;
                                break;
                            case 1:
                                branchArray[1, 0] += house.Value.Population;
                                branchArray[1, 1] += house.Value.FoodCapacity;
                                break;
                            case 2:
                                branchArray[2, 0] += house.Value.Population;
                                branchArray[2, 1] += house.Value.FoodCapacity;
                                break;
                            case 3:
                                branchArray[3, 0] += house.Value.Population;
                                branchArray[3, 1] += house.Value.FoodCapacity;
                                break;
                            case 4:
                                branchArray[4, 0] += house.Value.Population;
                                branchArray[4, 1] += house.Value.FoodCapacity;
                                break;
                            default:
                                Game.SetError(new Error(304, $"Invalid BranchID {house.Value.Branch}"));
                                break;
                        }
                    }
                    //place branch data in dictionary
                    int upper = branchArray.GetUpperBound(0);
                    for(int i = 0; i <= upper; i++)
                    { tempBranchDict.Add(i, branchArray[i, 1] - branchArray[i, 0]); }
                    //sort dictionary
                    var branches = from branchBalance in tempBranchDict
                                orderby branchBalance.Value descending
                                select branchBalance;
                    //place into the list
                    foreach (var houseData in branches)
                    { tempList.Add($"Branch {houseData.Key} has a food balance of {houseData.Value:N0}"); }
                    break;
                default:
                    Game.SetError(new Error(304, $"Invalid mode \"{mode}\""));
                    break;
            }
            return tempList;
        }


        /// <summary>
        /// royal Scribes tally up the Kingdom's financial situation (used during gamestart and throughout game)
        /// </summary>
        internal void InitialiseRoyalAccounts()
        {
            Game.logTurn?.Write("--- InitialiseRoyalAccounts (World.cs)");
            CapitalHouse capital = GetCapital();
            bool status;
            int divisor = 15; //used to work out default tax rates based on initial relationships (slightly skewed to good relations & low tax rates)
            int balance = 0;
            int cashflow = 0;
            int tally, income, expense, trade, relLvl;
            int taxRate, budget; //taxRate for Income, budget for Expenses -> both work off director.cs Rate enum
            if (capital != null)
            {
                //Income ---

                int goldAmount = Game.constant.GetValue(Global.LOAN_AMOUNT);
                int importTax = Game.constant.GetValue(Global.IMPORT_TAX);
                int exportTax = Game.constant.GetValue(Global.EXPORT_TAX);
                int churchTax = Game.constant.GetValue(Global.CHURCH_TAX);
                int crafterTax = Game.constant.GetValue(Global.CRAFTER_TAX);
                int roadTax = Game.constant.GetValue(Global.ROAD_TAX);
                int harbourTax = Game.constant.GetValue(Global.HARBOUR_TAX);
                int virginTax = Game.constant.GetValue(Global.VIRGIN_TAX);

                //Treasury at game start (one gold LOAN_AMOUNT per level + random half level)
                if (Game.gameTurn == 0)
                {
                    for (int i = 0; i < capital.Resources; i++)
                    { balance += goldAmount; }
                    balance += rnd.Next(goldAmount / 2);
                    capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Treasury, balance);
                    capital.SetFinanceData(Account.FinSummary, (int)FinSummary.Balance, balance);
                    //set key data to active status
                    capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.Treasury, true);
                    capital.SetFinanceStatus(Account.FinSummary, (int)FinSummary.CashFlow, true);
                    capital.SetFinanceStatus(Account.FinSummary, (int)FinSummary.Balance, true);
                    Game.logTurn?.Write($"Initial Treasury {balance:N0}");
                }
                //current treasury = previous balance
                int previousBalance = capital.GetFinanceInfo(Account.FinSummary, (int)FinSummary.Balance, FinArray.Data);
                capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Treasury, previousBalance);

                // Import taxes (Lords) based on num and type of imports (include any exports from Capital in this) -> Food is excluded
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Lord)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Lords, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Lords, FinArray.Rate); }
                int[,] arrayOfImports = capital.GetImports();
                int[,] arrayOfExports = capital.GetExports();
                trade = GetValueOfGoods(arrayOfImports);
                trade += GetValueOfGoods(arrayOfExports);
                income = Convert.ToInt32(trade * importTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Lords, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Lords, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Lords, trade);
                capital.SetFinanceConstant(Account.Income, (int)Income.Lords, importTax);

                // Export taxes (Merchants) base on num and type of Exports (finished products, essentially identical to above) -> Food is excluded
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Merchant)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Merchants, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Merchants, FinArray.Rate); }
                income = Convert.ToInt32(trade * exportTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Merchants, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Merchants, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Merchants, trade);
                capital.SetFinanceConstant(Account.Income, (int)Income.Merchants, exportTax);

                // Church tax (fixed amount * # Churches in Major Houses + Capital, that varies depending on tax Rate)
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Church)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Churches, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Churches, FinArray.Rate); }
                tally = 5 + GetNumMajorHouses();
                income = Convert.ToInt32(tally * churchTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Churches, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Churches, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Churches, tally);
                capital.SetFinanceConstant(Account.Income, (int)Income.Churches, churchTax);

                // Crafter tax (fixed amount * # of finished trade goods)
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Crafter)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Crafters, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Crafters, FinArray.Rate); }
                income = Convert.ToInt32(trade * crafterTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Crafters, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Crafters, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Crafters, trade);
                capital.SetFinanceConstant(Account.Income, (int)Income.Crafters, crafterTax);

                // Road tax (fixed amount * # of squares length of King's Road)
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Official)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Roads, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Roads, FinArray.Rate); }
                tally = Game.map.KingsRoadLength;
                income = Convert.ToInt32(tally * roadTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Roads, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Roads, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Roads, tally);
                capital.SetFinanceConstant(Account.Income, (int)Income.Roads, roadTax);

                // Harbour tax (fixed amount per port in the Kingdom)
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Official)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Harbours, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Harbours, FinArray.Rate); }
                tally = Game.network.GetNumPorts();
                income = Convert.ToInt32(tally * harbourTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Harbours, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Harbours, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Harbours, tally);
                capital.SetFinanceConstant(Account.Income, (int)Income.Harbours, harbourTax);

                // Virgin tax (fixed amount per two thousand population in the Kingdom)
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Peasant)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Virgins, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Virgins, FinArray.Rate); }
                tally = GetWorldPopulation() / 2000;
                income = Convert.ToInt32(tally * virginTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Virgins, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Virgins, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Virgins, tally);
                capital.SetFinanceConstant(Account.Income, (int)Income.Virgins, virginTax);

                //Expenses ---

                int cityWatchCost = Game.constant.GetValue(Global.CITYWATCH_COST);
                int officialsCost = Game.constant.GetValue(Global.OFFICIALS_COST);
                int defenceCost = Game.constant.GetValue(Global.DEFENSE_COST);
                int lifestyleCost = Game.constant.GetValue(Global.LIFESTYLE_COST);
                int loanCost = Game.constant.GetValue(Global.LOAN_COST);
                int foodCost = Game.constant.GetValue(Global.FOOD_COST);
                int essentialCost = Game.constant.GetValue(Global.ESSENTIAL_COST);
                int patrolCost = Game.constant.GetValue(Global.PATROL_COST);
                int pirateCost = Game.constant.GetValue(Global.PIRATE_COST);
                int inquisitorCost = Game.constant.GetValue(Global.INQUISITOR_COST);

                //City Watch  (MenAtArms at Capital / 2 * cost)
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.City_Watch_Wages, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.City_Watch_Wages, FinArray.Rate); }
                tally = capital.MenAtArms / 2 * cityWatchCost;
                expense = Convert.ToInt32(tally * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.City_Watch_Wages, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.City_Watch_Wages, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.City_Watch_Wages, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.City_Watch_Wages, cityWatchCost);

                //Officials (number of Major Houses + 5 for capital * cost) 
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Officials_Wages, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Officials_Wages, FinArray.Rate); }
                tally = 5 + GetNumMajorHouses();
                expense = Convert.ToInt32(tally * officialsCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Officials_Wages, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Officials_Wages, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Officials_Wages, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Officials_Wages, officialsCost);

                //Maintain Castle Defences (capital.CastleWalls * cost) 
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Capital_Defenses, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Capital_Defenses, FinArray.Rate); }
                tally = capital.CastleWalls;
                expense = Convert.ToInt32(tally * defenceCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Capital_Defenses, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Capital_Defenses, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Capital_Defenses, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Capital_Defenses, defenceCost);

                //Royal Lifestyle (12 - (Queen wits + kings wits) * cost) -> if Queen dead then King's wits x 2
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Royal_Lifestyle, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Royal_Lifestyle, FinArray.Rate); }
                int witsTally = Game.lore.NewKing.GetSkill(SkillType.Wits);
                if (Game.lore.NewQueen.Status != ActorStatus.Gone) { witsTally += Game.lore.NewQueen.GetSkill(SkillType.Wits); } else { witsTally *= 2; }
                tally = 12 - witsTally;
                expense = Convert.ToInt32(tally * lifestyleCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Royal_Lifestyle, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Royal_Lifestyle, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Royal_Lifestyle, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Royal_Lifestyle, lifestyleCost);

                //Loan interest (cost varies depending on who the loan was from -> Gold Bank is Normal, Merchant Guild is High and Goblin Bank is Excessive)
                List<Finance> listOfLoans = capital.GetLoans();
                expense = 0;
                int averageInterestRate = 0;
                int numLoans = listOfLoans.Count;
                if (numLoans > 0)
                {
                    for (int i = 0; i < numLoans; i++)
                    {
                        switch (listOfLoans[i])
                        {
                            case Finance.Gold_Bank: budget = (int)Rate.Normal; break;
                            case Finance.Merchant_Guild: budget = (int)Rate.High; break;
                            case Finance.Goblin_Bank: budget = (int)Rate.Excessive; break;
                            default:
                                Game.SetError(new Error(310, $"Invalid Loan type \"{listOfLoans[i]}\""));
                                break;
                        }
                        expense += Convert.ToInt32(loanCost * GetRate((Rate)budget));
                        averageInterestRate += budget;
                        cashflow -= expense;
                    }
                    averageInterestRate /= numLoans;
                }
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Loan_Interest, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Loan_Interest, status);
                capital.SetFinanceRate(Account.Expense, (int)Expense.Loan_Interest, averageInterestRate);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Loan_Interest, numLoans);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Loan_Interest, loanCost);

                //Food imports (kingdom food deficit / 2 * cost, not required if a food surplus) 
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Food_Imports, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Food_Imports, FinArray.Rate); }
                tally = GetWorldFoodBalance();
                if (tally < 0) { expense = Convert.ToInt32(Math.Abs(tally) / 2 *  foodCost * GetRate((Rate)budget)); cashflow -= expense; }
                else { expense = 0; }
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Food_Imports, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Food_Imports, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Food_Imports, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Food_Imports, foodCost);


                //Essential Goods Imports (must one each available of all goods except wine and gold, number of unique imported goods * cost)
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Essential_Goods, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Essential_Goods, FinArray.Rate); }
                int[,] arrayImports = capital.GetImports();
                int[,] arrayExports = capital.GetExports();
                int[] arrayGoods = new int[(int)Goods.Count];
                for (int i = 1; i < arrayGoods.Length; i++)
                {
                    //tally up number of goods 
                    if (arrayImports[i, 0] > 0) { arrayGoods[i]++; }
                    if (arrayExports[i, 0] > 0) { arrayGoods[i]++; }
                }
                //loop through looking for empty goods
                tally = 0;
                for (int i = 1; i < arrayGoods.Length; i++)
                {
                    //exclude luxury goods
                    if ((Goods)i != Goods.Wine && (Goods)i != Goods.Gold)
                    { if (arrayGoods[i] == 0) { tally++; } }
                }
                expense = Convert.ToInt32(tally * essentialCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Essential_Goods, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Essential_Goods, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Essential_Goods, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Essential_Goods, essentialCost);

                //Road Patrols (Length of King's road * cost) 
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Road_Patrols, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Road_Patrols, FinArray.Rate); }
                tally = Game.map.KingsRoadLength;
                expense = Convert.ToInt32(tally * patrolCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Road_Patrols, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Road_Patrols, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Road_Patrols, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Road_Patrols, patrolCost);

                //Pirate Patrol Subsidy (Number of ports * cost) 
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Pirate_Patrols, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Pirate_Patrols, FinArray.Rate); }
                tally = Game.network.GetNumPorts();
                expense = Convert.ToInt32(tally * pirateCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Pirate_Patrols, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Pirate_Patrols, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Pirate_Patrols, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Pirate_Patrols, pirateCost);

                //Inquisitors (Number of Inquisitors * cost) 
                if (Game.gameAct == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Inquisitors, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Inquisitors, FinArray.Rate); }
                tally = 0;
                foreach (var enemy in dictEnemyActors)
                { if (enemy.Value is Inquisitor) { tally++; } }
                expense = Convert.ToInt32(tally * inquisitorCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Inquisitors, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Inquisitors, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Inquisitors, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Inquisitors, inquisitorCost);

                //LumpSums & Summary ---

                //current treasury = previous balance
                balance = capital.GetFinanceInfo(Account.LumpSum, (int)LumpSum.Treasury, FinArray.Data);

                //Corruption
                /*int previousData = capital.GetFinanceInfo(Account.LumpSum, (int)LumpSum.Corruption, FinArray.Reference);
                capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Corruption, previousData);*/
                int previousData = capital.GetFinanceInfo(Account.LumpSum, (int)LumpSum.Corruption, FinArray.Data);
                int newData = CheckCorruption();
                newData *= -1;
                if (newData != 0)
                { balance += newData; capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.Corruption, true); }
                else { capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.Corruption, false); }
                capital.SetFinanceReference(Account.LumpSum, (int)LumpSum.Corruption, previousData); //used to enable previous period comparisons
                capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Corruption, newData);

                //Appropriations
                /*previousData = capital.GetFinanceInfo(Account.LumpSum, (int)LumpSum.Appropriations, FinArray.Reference);
                capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Appropriations, previousData);*/
                previousData = capital.GetFinanceInfo(Account.LumpSum, (int)LumpSum.Appropriations, FinArray.Data);
                newData = 0; //to do -> latest financial appropriations
                if (newData != 0)
                { balance += newData; capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.Appropriations, true); }
                else { capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.Appropriations, false); }
                capital.SetFinanceReference(Account.LumpSum, (int)LumpSum.Appropriations, previousData); //used to enable previous period comparisons
                capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Appropriations, newData);

                //Loan Data
                /*previousData = capital.GetFinanceInfo(Account.LumpSum, (int)LumpSum.New_Loans, FinArray.Reference);
                capital.SetFinanceData(Account.LumpSum, (int)LumpSum.New_Loans, previousData);*/
                previousData = capital.GetFinanceInfo(Account.LumpSum, (int)LumpSum.New_Loans, FinArray.Data);
                newData = 0; //to do -> latest loans
                if (newData != 0)
                { balance += newData; capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.New_Loans, true); }
                else { capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.New_Loans, false); }
                capital.SetFinanceReference(Account.LumpSum, (int)LumpSum.New_Loans, previousData); //used to enable previous period comparisons
                capital.SetFinanceData(Account.LumpSum, (int)LumpSum.New_Loans, newData);

                //update cashflow with current data
                capital.SetFinanceData(Account.FinSummary, (int)FinSummary.CashFlow, cashflow);
                balance += cashflow;
                //update Balance
                capital.SetFinanceData(Account.FinSummary, (int)FinSummary.Balance, balance);
                //admin
                SetMessage(new Message($"Royal Scribes have update the Kingdom Accounts to show a Balance of {balance:N0} gold coins", MessageType.Finance));
            }
            else { Game.SetError(new Error(310, "Invalid Capital (null) -> Royal Accounts not initialised")); }
        }

        /// <summary>
        /// returns multiplier for the Rate (taxRate or budget Rate)
        /// </summary>
        /// <param name="rate"></param>
        /// <returns></returns>
        private float GetRate(Rate rate)
        {
            float value = 0;
            switch (rate)
            {
                case Rate.Excessive:    value = 3;      break;
                case Rate.High:         value = 1.5f;   break;
                case Rate.Normal:       value = 1;      break;
                case Rate.Low:          value = 0.5f;   break;
                case Rate.Minimal:      value = 0.25f;  break;
            }
            return value;
        }

        /// <summary>
        /// returns expected income from taxing a particular income item at a given tax rate
        /// </summary>
        /// <param name="income"></param>
        /// <param name="rate"></param>
        /// <returns></returns>
        private int GetTaxableIncome(Income income, Rate rate)
        {
            int amount = 0;
            CapitalHouse capital = GetCapital();
            if (capital != null)
            {
                switch (income)
                {
                    case Income.Lords:
                    case Income.Merchants:
                    case Income.Crafters:
                        //calculate trade 
                        int[,] arrayOfImports = capital.GetImports();
                        int[,] arrayOfExports = capital.GetExports();
                        int trade = GetValueOfGoods(arrayOfImports);
                        trade += GetValueOfGoods(arrayOfExports);
                        //apply constant
                        switch (income)
                        {
                            case Income.Lords:
                                amount = trade * Game.constant.GetValue(Global.IMPORT_TAX);
                                break;
                            case Income.Merchants:
                                amount = trade * Game.constant.GetValue(Global.EXPORT_TAX);
                                break;
                            case Income.Crafters:
                                amount = trade * Game.constant.GetValue(Global.CRAFTER_TAX);
                                break;
                        }
                        break;
                    case Income.Churches:
                        int tally = 5 + GetNumMajorHouses();
                        amount = tally * Game.constant.GetValue(Global.CHURCH_TAX);
                        break;
                    case Income.Roads:
                        tally = Game.map.KingsRoadLength;
                        amount = tally * Game.constant.GetValue(Global.ROAD_TAX);
                        break;
                    case Income.Harbours:
                        tally = Game.network.GetNumPorts();
                        amount = tally * Game.constant.GetValue(Global.HARBOUR_TAX);
                        break;
                    case Income.Virgins:
                        tally = GetWorldPopulation() / 1000;
                        amount = tally * Game.constant.GetValue(Global.VIRGIN_TAX);
                        break;
                    default:
                        Game.SetError(new Error(318, $"Invalid Income \"{income}\" -> Default taxable income of Zero returned"));
                        break;
                }
                //adjust for tax rate
                amount = Convert.ToInt32(amount * GetRate((Rate)rate));
            }
            else { Game.SetError(new Error(318, "Invalid capital (null) -> default zero income returned")); }

            return amount;
        }

        /// <summary>
        /// returns expected cost from budgeting a particular expense item at a given rate
        /// </summary>
        /// <param name="expense"></param>
        /// <param name="budget"></param>
        /// <returns></returns>
        private int GetExpenseCost(Expense expense, Rate budget)
        {
            int tally = 0;
            CapitalHouse capital = GetCapital();
            if (capital != null)
            {
                switch (expense)
                {
                    case Expense.City_Watch_Wages:
                        tally = capital.MenAtArms / Game.constant.GetValue(Global.CITYWATCH_COST);
                        break;
                    case Expense.Capital_Defenses:
                        tally = capital.CastleWalls * Game.constant.GetValue(Global.DEFENSE_COST);
                        break;
                    case Expense.Officials_Wages:
                        tally = 5 + GetNumMajorHouses();
                        tally *= Game.constant.GetValue(Global.OFFICIALS_COST);
                        break;
                    case Expense.Royal_Lifestyle:
                        int witsTally = Game.lore.NewKing.GetSkill(SkillType.Wits);
                        if (Game.lore.NewQueen.Status != ActorStatus.Gone) { witsTally += Game.lore.NewQueen.GetSkill(SkillType.Wits); } else { witsTally *= 2; }
                        tally = (12 - witsTally) * Game.constant.GetValue(Global.LIFESTYLE_COST);
                        break;
                    case Expense.Loan_Interest:
                        //budget is ignored for loans as the cost depends on their interest rates which vary depending on the source of finance
                        List<Finance> listOfLoans = capital.GetLoans();
                        tally = 0;
                        int interestRate = 0;
                        int numLoans = listOfLoans.Count;
                        if (numLoans > 0)
                        {
                            for (int i = 0; i < numLoans; i++)
                            {
                                switch (listOfLoans[i])
                                {
                                    case Finance.Gold_Bank: interestRate = (int)Rate.Normal; break;
                                    case Finance.Merchant_Guild: interestRate = (int)Rate.High; break;
                                    case Finance.Goblin_Bank: interestRate = (int)Rate.Excessive; break;
                                    default:
                                        Game.SetError(new Error(310, $"Invalid Loan type \"{listOfLoans[i]}\""));
                                        break;
                                }
                                tally += Game.constant.GetValue(Global.LOAN_COST) * interestRate / 2;
                            }
                        }
                        break;
                    case Expense.Food_Imports:
                        int balance = GetWorldFoodBalance();
                        if (balance < 0) { tally = Math.Abs(balance) / Game.constant.GetValue(Global.FOOD_COST); }
                        else { tally = 0; }
                        break;
                    case Expense.Essential_Goods:
                        int[,] arrayImports = capital.GetImports();
                        int[,] arrayExports = capital.GetExports();
                        int[] arrayGoods = new int[(int)Goods.Count];
                        for (int i = 1; i < arrayGoods.Length; i++)
                        {
                            //add up number of goods 
                            if (arrayImports[i, 0] > 0) { arrayGoods[i]++; }
                            if (arrayExports[i, 0] > 0) { arrayGoods[i]++; }
                        }
                        //loop through looking for empty goods
                        for (int i = 1; i < arrayGoods.Length; i++)
                        {
                            //exclude luxury goods
                            if ((Goods)i != Goods.Wine && (Goods)i != Goods.Gold)
                            { if (arrayGoods[i] == 0) { tally++; } }
                        }
                        tally *= Game.constant.GetValue(Global.ESSENTIAL_COST);
                        break;
                    case Expense.Road_Patrols:
                        tally = Game.map.KingsRoadLength;
                        tally *= Game.constant.GetValue(Global.PATROL_COST);
                        break;
                    case Expense.Pirate_Patrols:
                        tally = Game.network.GetNumPorts();
                        tally *= Game.constant.GetValue(Global.PIRATE_COST);
                        break;
                    case Expense.Inquisitors:
                        foreach (var enemy in dictEnemyActors)
                        { if (enemy.Value is Inquisitor) { tally++; } }
                        tally *= Game.constant.GetValue(Global.INQUISITOR_COST);
                        break;
                    default:
                        Game.SetError(new Error(319, $"Invalid Expense \"{expense}\" -> default zero cost returned"));
                        break;
                }
                //adjust for budget rate 
                if (expense != Expense.Loan_Interest)
                { tally = Convert.ToInt32(tally * GetRate((Rate)budget)); }
            }
            else { Game.SetError(new Error(319, "Invalid capital (null) -> default zero cost returned")); }
            return tally;
        }

        /// <summary>
        /// Updates countdown timer and, if zero, resets and initiates a new set of Royal accounts
        /// </summary>
        private void CheckRoyalAccounts()
        {
            Game.logTurn?.Write("--- CheckRoyalAccounts (World.cs)");
            int timer = Game.variable.GetValue(GameVar.Account_Timer);
            timer--;
            Game.logTurn?.Write($"New Accounts tallied in {timer} days");
            if (timer > 0)
            { Game.variable.SetValue(GameVar.Account_Timer, timer); }
            else
            {
                int oldData, newData, adjustment, chance, rndNum, amount;
                string description;
                //new set of accounts
                InitialiseRoyalAccounts();
                //reset timer
                Game.variable.SetValue(GameVar.Account_Timer, Game.constant.GetValue(Global.ACCOUNT_INTERVAL));
                //
                //updates as a result of accounts
                //
                //King legend adjusted as a result of the budget allocation to Royal lifestyle (+ve adjustment if budget > normal, -ve if less, no effect if budget normal)
                adjustment = Game.variable.GetValue(GameVar.Lifestyle_Budget) - (int)Rate.Normal;
                adjustment *= Game.constant.GetValue(Global.LEGEND_LIFESTYLE);
                if (adjustment != 0)
                {
                    DataState state = DataState.Good;
                    if (adjustment < 0) { state = DataState.Bad; }
                    oldData = Game.director.GetGameState(GameState.Legend_King, state);
                    newData = oldData + Math.Abs(adjustment);
                    Game.director.SetGameState(GameState.Legend_King, state, newData, true);
                    description = $"King {Game.lore.NewKing.Name}'s, \"{Game.lore.NewKing.Handle}\", Royal Lifestyle has affected how people view him (Legend {state} +{adjustment})";
                    SetMessage(new Message(description, MessageType.Finance));
                }
                //Official wages -> can extort money from people they deal with. Chance of relationship change with group (higher wage allocation the less chance of them extorting to supplement their income)
                CapitalHouse capital = GetCapital();
                if (capital != null)
                {
                    amount = Game.constant.GetValue(Global.OFFICIALS_EFFECT) * -1;
                    chance = 5 - Game.variable.GetValue(GameVar.Official_Budget);
                    for (int i = 1; i < (int)WorldGroup.Count; i++)
                    {
                        rndNum = rnd.Next(10);
                        if (rndNum< chance)
                        {
                            //exclude officials extorting money from officials
                            if (i != (int)WorldGroup.Official)
                            {
                                capital.ChangeGroupRelations((WorldGroup)i, amount);
                                description = $"{(WorldGroup)i} relationship level has deteriorated {amount} due to Officials extorting money from them";
                                SetMessage(new Message(description, MessageType.Finance));
                            }
                        }
                    }
                }
                else { Game.SetError(new Error(320, "Invalid capital (null) -> Official Wages effect cancelled")); }
            }
        }

        /// <summary>
        /// private submethod to calculate the value of trade goods in capital (used for Imports/Exports). All goods are value 1 except wine being 2 and gold is worth 3. Food is excluded.
        /// </summary>
        /// <param name="tempGoods">arrayOfImports or arrayOfExports</param>
        /// <returns></returns>
        private int GetValueOfGoods(int[,] tempGoods)
        {
            Goods good;
            
            int total = 0;
            for (int i = 0; i < tempGoods.GetUpperBound(0); i++)
            {
                int tally = 0;
                if (tempGoods[i, 0] > 0)
                {
                    good = (Goods)i;
                    //different goods have different effects
                    switch (good)
                    {
                        case Goods.Gold:
                            tally += 3;
                            break;
                        case Goods.Wine:
                            tally += 2;
                            break;
                        case Goods.Furs:
                        case Goods.Oil:
                        case Goods.Iron:
                        case Goods.Timber:
                            tally += 1;
                            break;
                    }
                    total += tally * tempGoods[i, 0];
                }
            }
            return total;
        }

        /// <summary>
        /// Returns total world population
        /// </summary>
        /// <returns></returns>
        internal int GetWorldPopulation()
        {
            int population = 0;
            foreach (var house in dictAllHouses)
            { population += house.Value.Population; }
            return population;
        }

        /// <summary>
        /// Returns total world food capacity (ignores stockpiles)
        /// </summary>
        /// <returns></returns>
        internal int GetWorldFoodCapacity()
        {
            int capacity = 0;
            foreach (var house in dictAllHouses)
            { capacity += house.Value.FoodCapacity; }
            return capacity;
        }

        /// <summary>
        /// Returns total world food surplus / deficit (1 food feeds 1 person through winter)
        /// </summary>
        /// <returns></returns>
        internal int GetWorldFoodBalance()
        {
            int population = 0; int food = 0;
            foreach (var house in dictAllHouses)
            { population += house.Value.Population; food += house.Value.FoodCapacity; }
            return food - population;
        }

        /// <summary>
        /// End of Game Turn Game related housekeeping
        /// </summary>
        private void HousekeepGame()
        {
            //update Game timers
            Game.gameTurn++;
            Game.HarvestTimer--;
            Game.WinterTimer--;
            Game.SeasonTimer--;
            Game.PlantTimer--;
            //rollover timers
            if (Game.SeasonTimer <= 0) { Game.SeasonTimer = 360; Game.WinterTimer = 270; }
            if (Game.HarvestTimer == 0) { Game.HarvestTimer = 360; Game.PlantTimer = 35; }
            //determine season
            Game.UpdateSeason();
        }

        /// <summary>
        /// End of Game turn House related housekeeping
        /// </summary>
        private void HousekeepHouses()
        {
            Game.logTurn?.Write("--- HouseKeepHouses (world.cs)");
            //capital
            CapitalHouse capital = GetCapital();
            if (capital != null)
            {
                int lordRel = GetAverageLordRelations();
                //Lords is the average of all Major Lords rels
                capital.SetGroupRelations(WorldGroup.Lord, lordRel );
                Game.logTurn?.Write($"Average Lord Relations updated, now {lordRel}");
            }
            else { Game.SetError(new Error(311, "Invalid capital (null)")); }
        }


        internal int[] GetTradeData()
        { return arrayTradeData; }


        internal Dictionary<int, int> GetHousePower()
        { return dictHousePower; }


        internal List<HorseRecord> GetHorses()
        { return listHorses; }

        internal int GetNumMajorHouses()
        { return dictMajorHouses.Count; }

        /// <summary>
        /// Returns the average relationship value (0 - 100) with Lords from all Major Houses
        /// </summary>
        /// <returns></returns>
        public int GetAverageLordRelations()
        {
            int averageRel = 0;
            float totalRel = 0;
            float numLords = 0;
            int kingID = Game.lore.NewKing.ActID;
            foreach (var house in dictMajorHouses)
            {
                Passive lord = Game.world.GetPassiveActor(house.Value.LordID);
                if (lord != null)
                {
                    //exclude king from calcs
                    if (lord.ActID != kingID)
                    {
                        totalRel += (100 - lord.GetRelPlyr());
                        numLords++;
                    }
                }
                else { Game.SetError(new Error(308, $"Invalid Lord (null) from house.Value.LordID {house.Value.LordID}")); }
            }
            averageRel = Convert.ToInt32(totalRel / numLords);
            averageRel = Math.Min(100, averageRel);
            averageRel = Math.Max(0, averageRel);
            return averageRel;
        }

        /// <summary>
        /// Returns the amount of corruption (in gold coins) taken from the Kingdom Coffers by the Royal Council of Advisors
        /// </summary>
        /// <returns></returns>
        private int CheckCorruption()
        {
            Game.logTurn?.Write("--- CheckCorruption (World.cs)");
            int corruption = 0;
            int treachery, wits, rndNum, amount;
            int factor = Game.variable.GetValue(GameVar.Corruption_Factor);
            //due to sequencing issues
            if (Game.gameTurn == 0) { factor = Game.constant.GetValue(Global.CORRUPTION_COST); }
            string description;
            foreach(var advisor in dictRoyalCourt)
            {
                amount = 0;
                rndNum = rnd.Next(10);
                Advisor actor = advisor.Value as Advisor;
                //chance of corruption is treachery * 10 %
                treachery = actor.GetSkill(SkillType.Treachery);
                if (rndNum <= treachery)
                {
                    //amount of treachery is wits * corruption_factor
                    wits = actor.GetSkill(SkillType.Wits);
                    amount = wits * factor;
                    //update actor
                    actor.CorruptionRecent = amount;
                    actor.CorruptionTotal += amount;
                    corruption += amount;
                    description = $"{actor.Title} {actor.Name} is corrupt (treachery {treachery}, rolled {rndNum}), amount taken {amount} (Wits {wits} * factor {factor}), Total {actor.CorruptionTotal}";
                    Game.logTurn?.Write(description);
                }
                else
                {
                    //no corruption occurred, zero recent amount
                    actor.CorruptionRecent = amount;
                }
            }
            return corruption;
        }


        public Dictionary<int, Message> GetMessages()
        { return dictMessages; }

        public List<Snippet> GetMessageQueue()
        { return messageQueue.ToList(); }

        /// <summary>
        /// Toggles Game Act between One & Two and handles are game state changes -> God Mode
        /// </summary>
        public List<Snippet> GodChangeGameAct()
        {
            Game.logTurn?.Write("--- GodChangeGameAct (World.cs)");
            List<Snippet> listDisplay = new List<Snippet>();
            RLColor goodColor = Color._goodTrait;
            RLColor badColor = Color._badTrait;
            RLColor displayColor = RLColor.White;
            int locID;
            listDisplay.Add(new Snippet("God Mode -> Toggle Game Act", Color._godMode, RLColor.Black));
            Player player = GetPlayer();
            if (player != null)
            {
                CapitalHouse capital = GetCapital();
                if (capital != null)
                {
                    Location locCapital = Game.network.GetLocation(capital.LocID);
                    if (locCapital != null)
                    {
                        Position posCapital = locCapital.GetPosition();
                        if (posCapital != null)
                        {
                            //
                            //Act Two -> Player as King ---
                            //
                            if (Game.gameAct == Act.One)
                            {
                                displayColor = goodColor;
                                //store current player position to enable seamless transition back to Act 1 if required
                                Game.variable.SetValue(GameVar.God_PlayerLocID, player.LocID);
                                //teleport player to Capital
                                InitialiseMoveActor(1, player.GetPosition(), posCapital);
                                Game.logTurn?.Write("Player teleported to Capital");
                                //take care of all necessary details -> keep as much stuff here as possible, only God mode specifics in this method
                                InitialiseChangeOver();
                                //New Enemy -> DEBUG (temporary) -> find Lord, alive, At Location who dislikes player NOTE: Do AFTER InitialiseChangeOver
                                int targetActID = 0;
                                for (int i = 20; i < dictPassiveActors.Count; i++)
                                {
                                    Actor target = dictPassiveActors[i];
                                    if (target is Noble && target.Type == ActorType.Lord && target.Status == ActorStatus.AtLocation)
                                    {
                                        if (target.GetRelPlyr() < 40)
                                        {
                                            targetActID = target.ActID;
                                            target.Goal = ActorAIGoal.Wait;
                                            target.LastKnownGoal = ActorAIGoal.Wait;
                                            target.GoalTurns = 0;
                                            Location loc = Game.network.GetLocation(target.LocID);
                                            target.Known = false;
                                            target.TurnsUnknown = 1;
                                            if (loc != null)
                                            {
                                                target.AssignedBranch = loc.GetBranch();
                                                target.LastKnownPos = target.GetPosition();
                                                target.LastKnownLocID = loc.LocationID;
                                            }
                                            else { Game.SetError(new Error(323, $"Invalid Location for target LocID \"{target.LocID}\"")); }
                                            break;
                                        }
                                    }
                                }
                                //give a default value, just in case
                                if (targetActID == 0) { targetActID = 40; Game.logTurn?.Write("[Alert] No viable Lord found, default ActID 40 used"); } 
                                Game.variable.SetValue(GameVar.Inquisitor_Target, targetActID);
                            }
                            //
                            //Act One -> Player as Usurper ---
                            //
                            else
                            {
                                //Reset Inquisitors to AI control -> needs to be BEFORE gameAct is swung over to Act.One
                                SetInquisitorControlStatus(true);
                                Game.gameAct = Act.One;
                                Game.logTurn?.Write($"[Notification] Game now in Act {Game.gameAct}");
                                displayColor = badColor;
                                //get player's previous position in Act One
                                locID = Game.variable.GetValue(GameVar.God_PlayerLocID);
                                //retore player as target, ensure inquisitors are  AI control
                                Game.variable.SetValue(GameVar.Inquisitor_Target, 1);
                                Game.variable.SetValue(GameVar.Inquisitor_AI, 1);
                                //check that there is a viable, non-Capital location available
                                if (locID > 1)
                                {
                                    Location locReturn = Game.network.GetLocation(locID);
                                    if (locReturn != null)
                                    {
                                        //teleport Player back to previous location prior to ActTwo
                                        InitialiseMoveActor(1, player.GetPosition(), locReturn.GetPosition());
                                        Game.logTurn?.Write($"Player teleported back to {locReturn.LocName}, LocID {locID}");
                                        Game.gameReturn = 0; //reset
                                        //change Title and Office
                                        player.Office = ActorOffice.Usurper;
                                        player.Title = $"{player.Office}";
                                        //Set Inquisitors back to 'BadEnemies'
                                        foreach (var enemy in dictEnemyActors)
                                        {
                                            if (enemy.Value is Inquisitor)
                                            { enemy.Value.GoodEnemy = false; Game.logTurn?.Write($"Inquisitor {enemy.Value.Name}, ActID {enemy.Value.ActID}, GoodEnemy -> {enemy.Value.GoodEnemy}"); }
                                        }
                                        //repopulate Royal Family and Advisors to Capital with correct Status
                                        foreach(var passive in dictRoyalBackUp)
                                        {
                                            passive.Value.Status = ActorStatus.AtLocation;
                                            Game.logTurn?.Write($"{passive.Value.Title} {passive.Value.Name}, \"{passive.Value.Handle}\", ActID {passive.Value.ActID}, has been restored to the Capital");
                                        }
                                        //clear dictionary
                                        dictRoyalBackUp.Clear();
                                        
                                    }
                                    else { Game.SetError(new Error(323, $"Invalid locReturn (null) for LocID \"{locReturn}\"")); }
                                }
                                else { Game.logTurn?.Write($"Player remains in capital due to previous LocID \"{locID}\""); }
                            }
                            // ---
                        }
                        else { Game.SetError(new Error(323, "Invalid Location (null) for Act Two")); }
                    }
                    else { Game.SetError(new Error(323, "Invalid Capital position (null)")); }
                }
                else { Game.SetError(new Error(323, "Invalid Capital (null)")); }
            }
            else { Game.SetError(new Error(323, "Invalid player (null)")); }
            listDisplay.Add(new Snippet($"Game changed to Act {Game.gameAct}", displayColor, RLColor.Black));
            Game.world.SetMessage(new Message($"Game changed to Act {Game.gameAct}", MessageType.God));
            return listDisplay;
        }

        
        /// <summary>
        /// Handles all matters for when the Player first takes power at start of Act 2
        /// </summary>
        public void InitialiseChangeOver()
        {
            Game.logTurn?.Write("--- InitialiseChangeOver (World.cs)");
            Player player = GetPlayer();
            if (player != null)
            {
                CapitalHouse capital = GetCapital();
                if (capital != null)
                {
                    Location locCapital = Game.network.GetLocation(capital.LocID);
                    if (locCapital != null)
                    {
                        Game.gameAct = Act.Two;
                        Game.logTurn?.Write($"[Notification] Game now in Act {Game.gameAct}");
                        Game.gameReturn = Game.gameTurn;
                        //change Title and Office
                        player.Office = ActorOffice.King;
                        player.Title = $"{player.Office}";
                        //Set Inquisitors to 'GoodEnemies'
                        foreach (var enemy in dictEnemyActors)
                        {
                            if (enemy.Value is Inquisitor)
                            { enemy.Value.GoodEnemy = true; Game.logTurn?.Write($"Inquisitor {enemy.Value.Name}, ActID {enemy.Value.ActID}, GoodEnemy -> {enemy.Value.GoodEnemy}"); }
                        }
                        //Populate dictRoyalBackUp
                        List<int> listOfActors = locCapital.GetActorList();
                        int newKingHouseID = Game.lore.NewKing.HouseID;
                        for (int i = 0; i < listOfActors.Count; i++)
                        {
                            Actor actor = GetAnyActor(listOfActors[i]);
                            if (actor != null)
                            {
                                //actor passive and a royal (if they come from the Loc list of Actors then can be assumed to be alive)
                                if (actor is Passive)
                                {
                                    Passive passive = actor as Passive;
                                    if (passive.HouseID == 9999 || passive.HouseID == newKingHouseID)
                                    {
                                        //DEBUG -> set all Royal Family to Captured and keep Advisors in their jobs
                                        if (!(passive is Advisor)) { passive.Status = ActorStatus.Captured; }
                                        dictRoyalBackUp.Add(actor.ActID, passive);
                                        Game.logTurn?.Write($"{passive.Title} {passive.Name}, \"{passive.Handle}\", ActID {passive.ActID}, has been added to dictRoyalBackUp");
                                    }
                                }
                            }
                        }
                        
                      
                        //debug
                        //SetInquisitorControlStatus(false);
                        //
                    }
                    else { Game.SetError(new Error(324, "Invalid locCapital (null)")); }
                }
                else { Game.SetError(new Error(324, "Invalid Capital (null)")); }
            }
            else { Game.SetError(new Error(324, "Invalid player (null)")); }
        }


        /// <summary>
        /// debug method to check all passive actors are assigned positions at start of game
        /// </summary>
        internal void CheckPositions()
        {
            Game.logTurn?.Write("--- CheckPositions (History.cs)");
            string alertText;
            foreach (var actor in dictPassiveActors)
            {
                Position pos = actor.Value.GetPosition();
                if (pos.PosX == 0 && pos.PosY == 0) { alertText = "{Alert]"; } else { alertText = ""; }
                Game.logTurn?.Write($"{alertText} {actor.Value.Title} {actor.Value.Name}, ActID {actor.Value.ActID}, Position {pos.PosX}:{pos.PosY}");
            }
        }

        /// <summary>
        /// returns Inquisitor.ActID given their TempActID. Returns '0' if not found
        /// </summary>
        /// <param name="tempActID"></param>
        /// <returns></returns>
        internal int GetInquisitorActID(int tempActID)
        {
            foreach(var enemy in dictEnemyActors)
            {
                if (enemy.Value is Inquisitor)
                {
                    Inquisitor inquisitor = enemy.Value as Inquisitor;
                    if (inquisitor.TempActID == tempActID)
                    { return inquisitor.ActID; }
                }
            }
            return 0;
        }

        //new Methods above here
    }
}