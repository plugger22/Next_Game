using System;
using System.Collections.Generic;
using Next_Game.Cartographic;
using System.Linq;
using RLNET;
using System.Diagnostics;

namespace Next_Game
{
    //handles living world for the game (data generated by History.cs at game start)
    public class World
    {
        static Random rnd;
        private int seed;
        private List<Move> listMoveObjects; //actors moving through the world
        private List<ActorSpy> listTempActiveActors; //bloodhound temp lists
        private List<ActorSpy> listTempEnemyActors; //bloodhound temp lists
        private List<HorseRecord> listHorses; //record of all Player's past horses
        private int[,] arrayAI; //'0' -> # enemies at capital, '1,2,3,4' -> # enemies patrolling each branch, [0,] -> actual, [1,] -> desired [2,] -> temp data
        private int[] arrayTradeData; //0 -> Total Wealth, 1 # of Food, 2 # Iron, 3 # Timber, 4 # Gold, 5 # Wine, 6 # Oil, 7 # Wool, 8 # Furs
        private readonly Queue<Snippet> messageQueue; //short term queue to display recent messages
        private Dictionary<int, Active> dictActiveActors; //list of all Player controlled actors keyed off actorID (non-activated followers aren't in dictionary)
        private Dictionary<int, Passive> dictPassiveActors; //list of all NPC actors keyed of actorID
        private Dictionary<int, Enemy> dictEnemyActors; //list of all Enemy actors keyed of actorID
        private Dictionary<int, Special> dictSpecialActors; //list of all Special NPC actors -> key is SpecialID
        private Dictionary<int, Actor> dictAllActors; //list of all Actors keyed of actorID
        private Dictionary<int, MajorHouse> dictMajorHouses; //list of all Greathouses keyed off houseID (Does NOT contain CapitalHouse)
        private Dictionary<int, House> dictAllHouses; //list of all houses & special locations keyed off RefID (Does contain CapitalHouse)
        private Dictionary<int, int> dictMajorHouseID; //list of Great Houses, unsorted (Key is House ID, value is # of bannerlords)
        private Dictionary<int, int> dictHousePower; // list of Great Houses, Sorted (key is House ID, value is # of bannerlords (power))
        private Dictionary<int, Record> dictHistoricalRecords; //all historical records (including Players) in a central collection (key is trackerID)
        private Dictionary<int, Record> dictCurrentRecords; //all current records (non-Player) in a central collection (key is trackerID)
        private Dictionary<int, Record> dictPlayerRecords; //all current Player records, (key is trackerID)
        private Dictionary<int, Message> dictMessages; //all Player to Game & Game to Player messages
        private Dictionary<int, GeoCluster> dictGeoClusters; //all GeoClusters (key is geoID)
        private Dictionary<int, Skill> dictTraits; //all triats (key is traitID)
        private Dictionary<int, Rumour> dictRumoursNormal; //all normal rumours (key is rumourID)
        private Dictionary<int, Rumour> dictRumoursTimed; //all timed (TimerExpire > 0) rumours (key is rumourID)
        private Dictionary<int, Rumour> dictRumoursInactive; //all inactive (TimerStart > 0) rumours (key is rumourId)
        private Dictionary<int, Rumour> dictRumoursKnown; //all rumours known to the Player (key is rumourID)
        private Dictionary<int, Possession> dictPossessions; //all possession (key is PossID)
        private Dictionary<int, Passive> dictRoyalCourt; //advisors and royal retainers (assumed to always be at Kingskeep) excludes family
        private Dictionary<int, int> dictConvertLocToRef; //dictionary to convert LocID's to RefID's (key is LocID, value is RefID)
        private Dictionary<int, int> dictConvertRefToLoc; //dictionary to convert RefID's to LocID's (key is RefID, value is LocID)
        private Dictionary<int, int> dictConvertRefToHouse; //dictionary to convert RefID's to HouseID's (key is RefID, value is HouseID)
        private Dictionary<int, BloodHound> dictBloodHound; //dictionary of all active & enemy actors movements (key is Turn #)

        //default constructor
        /// <summary>
        /// o
        /// </summary>
        /// <param name="seed"></param>
        public World(int seed)
        {
            this.seed = seed;
            rnd = new Random(seed);
            listMoveObjects = new List<Move>();
            listTempActiveActors = new List<ActorSpy>();
            listTempEnemyActors = new List<ActorSpy>();
            listHorses = new List<HorseRecord>();
            arrayAI = new int[3, 5];
            arrayTradeData = new int[(int)Goods.Count];
            messageQueue = new Queue<Snippet>();
            dictActiveActors = new Dictionary<int, Active>();
            dictPassiveActors = new Dictionary<int, Passive>();
            dictEnemyActors = new Dictionary<int, Enemy>();
            dictSpecialActors = new Dictionary<int, Special>();
            dictAllActors = new Dictionary<int, Actor>();
            dictMajorHouses = new Dictionary<int, MajorHouse>();
            dictAllHouses = new Dictionary<int, House>();
            dictMajorHouseID = new Dictionary<int, int>();
            dictHousePower = new Dictionary<int, int>();
            dictHistoricalRecords = new Dictionary<int, Record>();
            dictCurrentRecords = new Dictionary<int, Record>();
            dictPlayerRecords = new Dictionary<int, Record>();
            dictMessages = new Dictionary<int, Message>();
            dictGeoClusters = new Dictionary<int, GeoCluster>();
            dictTraits = new Dictionary<int, Skill>();
            dictRumoursNormal = new Dictionary<int, Rumour>();
            dictRumoursTimed = new Dictionary<int, Rumour>();
            dictRumoursInactive = new Dictionary<int, Rumour>();
            dictRumoursKnown = new Dictionary<int, Rumour>();
            dictPossessions = new Dictionary<int, Possession>();
            dictRoyalCourt = new Dictionary<int, Passive>();
            dictConvertLocToRef = new Dictionary<int, int>();
            dictConvertRefToLoc = new Dictionary<int, int>();
            dictConvertRefToHouse = new Dictionary<int, int>();
            dictBloodHound = new Dictionary<int, BloodHound>();
        }


        /// <summary>
        /// main method to initialise all world collections
        /// </summary>
        public void InitialiseWorld()
        {
            Game.logStart?.Write("--- InitialiseWorld (World.cs)");
            Stopwatch timer_2 = new Stopwatch();
            timer_2.Start();
            InitialiseGeoClusters();
            Game.StopTimer(timer_2, "W: InitialiseGeoClusters");
            timer_2.Start();
            InitialiseHouses();
            Game.StopTimer(timer_2, "W: InitialiseHouses");
            timer_2.Start();
            InitialiseItems();
            InitialiseActiveActors(Game.history.GetActiveActors());
            Game.StopTimer(timer_2, "W: InitiatePlayerActors");
            timer_2.Start();
            InitialiseTraits();
            Game.StopTimer(timer_2, "W: InitialiseTraits");
            timer_2.Start();
            //need to be here for sequencing issues
            Game.history.InitialiseOverthrow(dictPassiveActors);
            Game.history.InitialisePastHistoryHouses();
            Game.history.InitialiseLordRelations();
            Game.history.InitialiseSpecialCharacters(Game.file.GetCharacters("Characters.txt"));
            Game.history.InitialiseBeasts(Game.file.GetFollowers("Beasts.txt"));
            Game.StopTimer(timer_2, "W: InitialiseHistory");
            timer_2.Start();
            InitialiseHouseData(); //needs to be BEFORE InitialiseDesires but AFTER InitialiseOverthrow
            InitialiseConversionDicts(); //needs to be AFTER history methods (above) & BEFORE InitialiseEnemyActors (below)
            InitialiseSecrets();
            InitialiseDesires();
            InitialiseSafeHouses();
            InitialiseDisguises();
            Game.StopTimer(timer_2, "W: InitialiseVarious");
            timer_2.Start();
            InitialiseAI();
            InitialiseEnemyActors();
            InitialiseItemPlacement();
            InitialiseLocTypes();
            Game.StopTimer(timer_2, "W: InitialiseAI");
        }

        /// <summary>
        /// Sets up actors in dictionaries and places them on the map.
        /// </summary>
        /// <param name="listOfActiveActors"></param>
        internal void InitialiseActiveActors(List<Active> listOfActiveActors)
        {
            Game.logStart?.Write("--- InitialiseActiveActors (World.cs)");
            int numFollowers = Game.constant.GetValue(Global.START_FOLLOWERS);
            int locID, index;

            for (int i = 0; i <= numFollowers; i++)
            {
                if (i > 0)
                {
                    //choose a random follower
                    index = rnd.Next(0, listOfActiveActors.Count);
                    Follower follower = (Follower)listOfActiveActors[index];
                    if (follower != null)
                    {
                        //remove from list
                        listOfActiveActors.RemoveAt(index);
                        //add to list and Dictionaries in World
                        SetActiveActor(follower);
                        //assign to random location on map
                        locID = Game.network.GetRandomLocation();
                        Location loc = Game.network.GetLocation(locID);
                        if (loc != null)
                        {
                            //place characters at Location
                            follower.LocID = locID;
                            follower.LastKnownLocID = locID;
                            follower.SetActorPosition(loc.GetPosition());
                            //set to activated
                            follower.Activated = true;
                            //add to Location list of Characters
                            loc.AddActor(follower.ActID);
                            Game.logStart?.Write($"Follower {follower.Name}, ActorID {follower.ActID}, added and placed at {loc.LocName}, LocID {loc.LocationID}");
                        }
                        else { Game.SetError(new Error(63, "Invalid Loc (null) Active Actor not placed on map")); }
                    }
                    else
                    { Game.SetError(new Error(63, "Invalid Actor in listOfActiveActors")); }
                }
                else
                {
                    //player (first in list)
                    Player player = (Player)listOfActiveActors[0];
                    if (player != null)
                    {
                        //player goes in first
                        SetActiveActor(player);
                        listOfActiveActors.RemoveAt(0);
                        //assign to random location on map -> EDIT: Already done in history.cs InitialisePlayer

                        //DEBUG ---- (start) ---
                        //
                        //Add an random, active, Item to the Player at game start that has a challenge effect
                        List<Possession> listPossessions = new List<Possession>(dictPossessions.Values);
                        List<Item> listItems = new List<Item>();
                        {
                            for (int k = 0; k < listPossessions.Count; k++)
                            {
                                Possession possObject = listPossessions[k];
                                if (possObject.Active == true && possObject is Item)
                                {
                                    Item itemObject = possObject as Item;
                                    if (itemObject.ChallengeFlag == true)
                                    { listItems.Add(itemObject); }
                                }
                            }
                        }
                        //randomly choose one item from list
                        if (listItems.Count > 0)
                        {
                            int rndIndex = rnd.Next(listItems.Count);
                            int itemID = listItems[rndIndex].PossID;
                            if (itemID > 0)
                            {
                                player.AddItem(itemID);
                                Game.logStart?.Write(string.Format("[Item] {0}, PossID {1}, ItemID {2} added to Player's Inventory", listItems[rndIndex].Description, listItems[rndIndex].PossID,
                                    listItems[rndIndex].ItemID));
                            }
                        }
                        /*//Create a disguise, add to dictionary, give to Player
                        Disguise disguise = new Disguise("a Novice belonging to the Holy Faith", 2);
                        AddPossession(disguise.PossID, disguise);
                        player.ConcealDisguise = disguise.PossID;
                        Game.logStart?.Write($"[Disguise] \"{disguise.Description}\", PossID {disguise.PossID}, added to the Player's Inventory");*/
                        //
                        //DEBUG --- (end) ---
                    }
                    else
                    { Game.SetError(new Error(63, "Invalid Player in listOfActiveActors")); }
                }
            }
            //get list of Inns
            IEnumerable<InnHouse> inns =
                from houses in dictAllHouses.Values.OfType<InnHouse>()
                select houses;
            List<InnHouse> listOfInns = inns.ToList();
            //loop list again and assign all remaining followers to inns
            if (listOfInns.Count > 0)
            {
                Game.logStart?.Write("--- Assign LeftOver Followers to Inns (World.cs)");
                int indexInns = 0;
                for (int i = 0; i < listOfActiveActors.Count; i++)
                {
                    Active actor = listOfActiveActors[i];
                    listOfInns[indexInns].AddFollower(actor.ActID);
                    indexInns++;
                    //rollover index if end of Inns reached
                    if (indexInns == listOfInns.Count) { indexInns = 0; }
                }
            }
            else { Game.SetError(new Error(63, "No Inns present on Map -> No followers available to recruit")); }
        }

        /// <summary>
        /// set up inquisitors and any other enemies -> NOTE: must come AFTER InitialiseAI
        /// </summary>
        private void InitialiseEnemyActors()
        {
            Game.logStart?.Write("--- InitialiseEnemyActors (World.cs)");
            int numInquisitors = Game.constant.GetValue(Global.INQUISITORS);
            //loop for # of inquisitors
            for (int i = 0; i < numInquisitors; i++)
            {
                //create at capital
                Game.history.CreateInquisitor(1);
            }
            //create The Nemesis
            Game.history.CreateNemesis(1);
            //assign specific enemies to tasks (based on InitialiseAI)
            Game.logStart?.Write("- Assign Enemies");

            foreach (var enemy in dictEnemyActors)
            {
                enemy.Value.MoveOut = true;
                enemy.Value.HuntMode = false;
                if (enemy.Value is Nemesis)
                {
                    enemy.Value.AssignedBranch = 0;
                    Game.logStart?.Write(string.Format(" [Goal -> {0}] {1}, ActID {2} Branch -> {3}", enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID, enemy.Value.AssignedBranch));
                }
                else
                {
                    for (int i = 0; i <= arrayAI.GetUpperBound(1); i++)
                    {
                        if (enemy.Value is Inquisitor)
                        {
                            if (arrayAI[2, i] > 0)
                            {
                                enemy.Value.AssignedBranch = i;
                                arrayAI[2, i]--;
                                Game.logStart?.Write(string.Format(" [Goal -> {0}] {1}, ActID {2} Branch -> {3}", enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID, i));
                                break;
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Initiate character Movement (creates a Move object)
        /// </summary>
        /// <param name="charID">Character</param>
        /// <param name="posOrigin"></param>
        /// <param name="posDestination"></param>
        /// <param name="path">sequenced List of Positions to destination</param>
        internal string InitialiseMoveActor(int charID, Position posOrigin, Position posDestination/*, List<Position> path*/)
        {
            Game.logTurn?.Write("--- InitiateMoveActor (World.cs)");
            string returnText = "Error in World.InitiateMoveCharacters";
            //viable Character & Position?
            if (charID > 0 && posOrigin != null && posDestination != null /* && path != null*/)
            {
                //find in dictionary
                if (dictAllActors.ContainsKey(charID))
                {
                    Game.logTurn?.Write("--- Move Actor (Director.cs)");
                    Actor person = dictAllActors[charID];
                    if (person != null)
                    {
                        if (person.Status == ActorStatus.AtLocation)
                        {
                            List<Position> path = Game.network.GetPathAnywhere(posOrigin, posDestination);
                            List<int> party = new List<int>(); //list of charID's of all characters in party
                            party.Add(charID);
                            string name = person.Name;
                            bool playerInParty = false;
                            if (charID == 1)
                            { playerInParty = true; }
                            int speed = person.Speed;
                            int distance = path.Count;
                            int time = (distance / speed) + 1; //prevents 0 result
                                                               //return string
                            string originLocation = GetLocationName(posOrigin);
                            string destinationLocation = GetLocationName(posDestination);
                            returnText = string.Format("{0} commences a {1} day journey from {2} to {3}", name, time, originLocation, destinationLocation);
                            //remove character from current location 
                            int locID_Origin = Game.map.GetMapInfo(MapLayer.LocID, posOrigin.PosX, posOrigin.PosY);
                            Location loc = Game.network.GetLocation(locID_Origin);
                            if (loc != null)
                            {
                                //normal travel
                                if (Game._menuMode != MenuMode.God)
                                {
                                    //check an existing Move object doesn't already exist, e.g if user issued > 1 move orders during a turn
                                    //reverse loop, deleting any that contain the Player as you go
                                    for (int i = listMoveObjects.Count - 1; i >= 0; i--)
                                    {
                                        Move tempMove = listMoveObjects[i];
                                        if (tempMove.GetPrimaryCharacter() == charID)
                                        {
                                            Position pos = tempMove.GetCurrentPosition();
                                            Game.logTurn?.Write(string.Format("[Move -> Alert] Move Object DELETED PlayerInParty -> {0}, charID {1} at Loc {2}:{3}", tempMove.PlayerInParty, tempMove.GetPrimaryCharacter(),
                                                pos.PosX, pos.PosY));
                                            Active tempActive = Game.world.GetActiveActor(charID);
                                            if (tempActive != null)
                                            {
                                                Game.world.SetMessage(new Message(string.Format("{0} {1}'s journey to {2} has been cancelled", tempActive.Title, tempActive.Name, tempMove.GetDestination()),
                                                  MessageType.Move));
                                            }
                                            else { Game.SetError(new Error(175, "Invalid Player (null)")); }
                                            listMoveObjects.RemoveAt(i);
                                        }
                                    }
                                    //housekeep all move tasks
                                    loc.RemoveActor(charID);
                                    //create new move object
                                    Move moveObject = new Move(path, party, speed, playerInParty, Game.gameTurn);
                                    //insert into moveList
                                    listMoveObjects.Add(moveObject);
                                    //update character status to 'travelling'
                                    person.Status = ActorStatus.Travelling;
                                    //update characterLocationID (now becomes destination)
                                    int locID_Destination = Game.map.GetMapInfo(MapLayer.LocID, posDestination.PosX, posDestination.PosY);
                                    person.LocID = locID_Destination;
                                    //admin
                                    SetMessage(new Message(returnText, person.ActID, locID_Destination, MessageType.Move));
                                    int refID = ConvertLocToRef(locID_Destination);
                                    if (charID == 1)
                                    { Game.world.SetPlayerRecord(new Record(returnText, charID, locID_Destination, CurrentActorEvent.Travel)); }
                                    else if (charID > 1)
                                    { Game.world.SetCurrentRecord(new Record(returnText, charID, locID_Destination, CurrentActorEvent.Travel)); }
                                }
                                //God Mode Teleport Travel
                                else
                                {
                                    returnText = string.Format("{0} instantly Teleports from {2} to {3}", name, time, originLocation, destinationLocation);
                                    //place character at destination
                                    if (CharacterAtDestination(posDestination, charID) == false)
                                    { Game.SetError(new Error(175, $"ActorID {charID} has not had their details updated upon arriving at their Destination")); }
                                    else { Game.logTurn?.Write($"[God Mode] Player teleports from {originLocation} to {destinationLocation}"); }
                                }
                                //show route (Player only)
                                if (person is Player)
                                {
                                    Game.map.UpdateMap();
                                    Game.map.DrawRoutePath(path);
                                    //update Horse status
                                    Player player = person as Player;
                                    if (player.horseStatus != HorseStatus.Gone)
                                    { player.horseStatus = HorseStatus.Normal; }
                                }
                            }
                            else
                            { returnText = "ERROR: The Journey has been cancelled (Destination not Found)"; }
                        }
                        else
                        {
                            //main error conditions
                            if (person.Status == ActorStatus.Travelling)
                            { Game.logTurn?.Write(string.Format("[Move -> Error] {0} {1}, ActID {2}, currently Travelling. Move Cancelled", person.Title, person.Name, person.ActID));
                                returnText = "ERROR: The Journey has been cancelled (Actor Travelling))"; }
                            else if (person.Status == ActorStatus.Captured)
                            { Game.logTurn?.Write(string.Format("[Move -> Error] {0} {1}, ActID {2}, currently Captured. Move Cancelled", person.Title, person.Name, person.ActID));
                                returnText = "ERROR: The Journey has been cancelled (Actor Captured))"; }
                            else if (person.Status == ActorStatus.Gone)
                            { Game.logTurn?.Write(string.Format("[Move -> Error] {0} {1}, ActID {2}, is Deceased. Move Cancelled", person.Title, person.Name, person.ActID));
                                returnText = "ERROR: The Journey has been cancelled (Actor Deceased))"; }
                            else
                            { Game.SetError(new Error(175, string.Format("{0} {1}, ActID {2} Status \"{3}\" Unknown. Move Cancelled", person.Title, person.Name, person.ActID, person.Status)));
                                returnText = "ERROR: The Journey has been cancelled (Actor Status Unknown)"; }
                        }
                    }
                    else { Game.SetError(new Error(175, "Invalid Actor (null) Move Cancelled")); returnText = "ERROR: The Journey has been cancelled (Actor not Found)"; }
                }
            }
            return returnText;
        }

        /// <summary>
        /// Handles movement of all Player characters througout world
        /// </summary>
        /// <returns>returns a dictionary of mapMarkers and coordinates for the "Movement" mapGrid layer</returns>
        internal Dictionary<int, Position> MoveActors()
        {
            //create a dictionary of position and map markers to return (passed up to game thence to map to update mapgrid
            Dictionary<int, Position> dictMapMarkers = new Dictionary<int, Position>();
            Game.logTurn?.Write(string.Format("--- MoveActors -> {0} Records (World.cs)", listMoveObjects.Count));
            //loop moveList. Update each move object - update Character Location ID
            for (int i = 0; i < listMoveObjects.Count; i++)
            {

                //get move object
                Move moveObject = listMoveObjects[i];
                //debug
                int actorID = moveObject.GetPrimaryCharacter();
                Actor actor = GetAnyActor(actorID);
                if (actor != null)
                {
                    Position pos = moveObject.GetCurrentPosition();
                    if (pos != null)
                    {
                        Game.logTurn?.Write(string.Format(" [Move -> MoveObject] {0} {1}, ActID {2} travelling to {3} (current Loc {4}:{5})", actor.Title, actor.Name, actor.ActID,
                            moveObject.GetDestination(), pos.PosX, pos.PosY));
                    }
                    else { Game.SetError(new Error(42, "Invalid pos (null) in actor console printout")); }
                }
                else { Game.SetError(new Error(42, "Invalid Actor (null) in actor console printout")); }
                //move speed clicks down list of positions (ignore locations at present)
                moveObject.UpdatePartyStatus();
                if (moveObject.Status == PartyStatus.Active)
                {
                    //Arrived at Destination
                    if (moveObject.MoveParty() == true)
                    {
                        //update all relevant details for character arriving at destination
                        Position posDestination = moveObject.GetCurrentPosition();
                        /*int locID = Game.map.GetMapInfo(MapLayer.LocID, posDestination.PosX, posDestination.PosY);
                        Location loc = Game.network.GetLocation(locID);*/
                        List<int> charListMoveObject = new List<int>(moveObject.GetCharacterList());
                        //find location, get list, update for each character
                        /*if (loc != null)
                        {*/
                        foreach (int charID in charListMoveObject)
                        {
                            if (CharacterAtDestination(posDestination, charID) == false)
                            { Game.SetError(new Error(42, $"ActorID {actorID} has not had their details updated upon arriving at their Destination")); }
                        }
                        moveObject.Status = PartyStatus.Done;
                    }
                    else
                    //still enroute
                    {
                        //update dictionary
                        try
                        { dictMapMarkers.Add(moveObject.MapMarker, moveObject.GetCurrentPosition()); }
                        catch (ArgumentException)
                        { Game.SetError(new Error(42, "Error adding to dictMapMarkers (duplicate key -> Normal)")); }
                        //update Characters in list (charPos)
                        Position pos = moveObject.GetCurrentPosition();
                        List<int> characterList = new List<int>(moveObject.GetCharacterList());
                        for (int j = 0; j < characterList.Count; j++)
                        {
                            int charID = characterList[j];
                            //find in dictionary
                            if (dictAllActors.ContainsKey(charID))
                            {
                                Actor person = dictAllActors[charID];
                                person.SetActorPosition(pos);
                            }
                        }
                    }
                }
                else if (moveObject.Status == PartyStatus.Delayed)
                {
                    /*message about delay?*/
                    try
                    { dictMapMarkers.Add(moveObject.MapMarker, moveObject.GetCurrentPosition()); }
                    catch (ArgumentException)
                    { Game.SetError(new Error(42, "Error adding to dictMapMarkers (duplicate key -> Delayed)")); }
                }
            }
            //reverse loop through list of Moveobjects and delete any that are marked as 'Done'
            for (int i = listMoveObjects.Count; i > 0; i--)
            {
                if (listMoveObjects[i - 1].Status == PartyStatus.Done)
                {
                    try
                    { listMoveObjects.RemoveAt(i - 1); }
                    catch (Exception e)
                    { Game.SetError(new Error(61, e.Message)); }
                }
            }
            //pass dictionary of markers back to map object via Game
            return dictMapMarkers;
        }

        /// <summary>
        /// internal method to handle an active actor arriving at a destination (updates all relevant details). Returns true if all O.K
        /// </summary>
        /// <param name="posDestination"></param>
        /// <param name="actorID"></param>
        private bool CharacterAtDestination(Position posDestination, int actorID)
        {
            if (posDestination != null)
            {
                //active actor?
                if (actorID > 0)
                {
                    int locID = Game.map.GetMapInfo(MapLayer.LocID, posDestination.PosX, posDestination.PosY);
                    Location locDestination = Game.network.GetLocation(locID);
                    if (locDestination != null)
                    {
                        MessageType messageType = MessageType.Move;
                        //add character to destination
                        locDestination.AddActor(actorID);
                        //find character and update details
                        if (dictAllActors.ContainsKey(actorID))
                        {
                            Actor person = new Actor();
                            person = dictAllActors[actorID];
                            person.Status = ActorStatus.AtLocation;
                            person.SetActorPosition(posDestination);
                            person.LocID = locID;
                            int refID = ConvertLocToRef(locID);
                            string tempText = string.Format("{0}, Aid {1}, has arrived safely at {2}", person.Name, person.ActID, locDestination.LocName);
                            if (Game._menuMode == MenuMode.God && actorID < 10)
                            {
                                tempText = string.Format("[GodMode] {0}, Aid {1}, has teleported safely to {2}", person.Name, person.ActID, locDestination.LocName);
                                messageType = MessageType.God;
                            }

                            Message message = new Message(tempText, person.ActID, locDestination.LocationID, messageType);
                            SetMessage(message);
                            // Player
                            if (person.ActID == 1)
                            {
                                SetPlayerRecord(new Record(tempText, person.ActID, person.LocID, CurrentActorEvent.Travel));
                                Game.director.AddVisitedLoc(locID, Game.gameTurn);
                                Player player = person as Player;
                                switch (player.horseStatus)
                                {
                                    case HorseStatus.Normal:
                                        player.horseStatus = HorseStatus.Stabled;
                                        break;
                                    case HorseStatus.Exhausted:
                                    case HorseStatus.Lame:
                                    case HorseStatus.Gone:
                                        CreateHorseRecord(HorseGone.Abandoned, $"at {GetLocationName(player.LocID)}");
                                        GetNewHorse();
                                        break;
                                }
                            }
                            else if (person.ActID > 1)
                            { SetCurrentRecord(new Record(tempText, person.ActID, person.LocID, CurrentActorEvent.Travel)); }
                            //enemy -> arrives at destination, assign goal
                            if (person is Enemy)
                            {
                                Enemy enemy = person as Enemy;
                                if (enemy.HuntMode == true) { enemy.Goal = ActorAIGoal.Search; }
                                else { enemy.Goal = ActorAIGoal.Wait; }
                                Game.logTurn?.Write(string.Format(" [Goal -> Arrival] {0} {1}, ActID {2}, currently at {3}, new Goal -> {4}", enemy.Title, enemy.Name, enemy.ActID, locDestination.LocName, enemy.Goal));
                            }
                        }
                        else
                        { Game.SetError(new Error(247, $"Character not found, actorID {actorID}")); return false; }
                    }
                    else { Game.SetError(new Error(247, "Invalid locDestination (null)")); return false; }
                }
                else { Game.SetError(new Error(247, $"Invalid actorID \"{actorID}\"-> must be > 0")); return false; }
            }
            else { Game.SetError(new Error(247, "Invalid posDestination (null)")); return false; }
            return true;
        }


        internal string GetLocationName(int locID)
        {
            string locName = "Unknown";
            Location loc = Game.network.GetLocation(locID);
            if (loc != null)
            { locName = loc.LocName; }
            else { Game.SetError(new Error(185, "Invalid Loc (null) -> By LocID")); }
            return locName;
        }

        /// <summary>
        /// returns 'Unknown' string if not found
        /// </summary>
        /// <param name="pos"></param>
        /// <returns></returns>
        internal string GetLocationName(Position pos)
        {
            string locName = "Unknown";
            int locID = Game.map.GetMapInfo(MapLayer.LocID, pos.PosX, pos.PosY);
            if (locID > 0)
            {
                Location loc = Game.network.GetLocation(locID);
                if (loc != null) { locName = loc.LocName; }
                else { Game.SetError(new Error(185, "Invalid Loc (null) -> By Position")); }
            }
            return locName;
        }

        /// <summary>
        /// Get location coords in a formatted string
        /// </summary>
        /// <param name="locID"></param>
        /// <returns>returns '(loc 20:4)' format string</returns>
        public string GetLocationCoords(int locID)
        {
            string coords = "Unknown";
            Location loc = Game.network.GetLocation(locID);
            if (loc != null) { coords = string.Format("(loc {0}:{1})", loc.GetPosX(), loc.GetPosY()); }
            else { Game.SetError(new Error(186, "Invalid Loc (null) Unknown Coordinates")); }
            return coords;
        }

        /// <summary>
        /// Display Major House data to main infoConsole (input either houseID or refID, will check houseID first)
        /// </summary>
        /// <param name="houseID"></param>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal List<Snippet> ShowMajorHouseRL(int refID)
        {
            MajorHouse majorHouse = null;
            if (refID > 0)
            { House house = GetHouse(refID); majorHouse = house as MajorHouse; }
            else
            { Game.SetError(new Error(36, "Invalid input RefID (zero, or less)")); return null; }
            List<Snippet> houseList = new List<Snippet>();
            RLColor unknownColor = RLColor.LightGray;
            RLColor knownColor = RLColor.White;
            RLColor displayColor;
            if (majorHouse != null)
            {
                List<int> listLordLocations = majorHouse.GetBannerLordLocations();
                //details
                houseList.Add(new Snippet("House " + majorHouse.Name, RLColor.Yellow, RLColor.Black));
                string motto = string.Format("Motto \"{0}\"", majorHouse.Motto);
                houseList.Add(new Snippet(motto));
                string banner = string.Format("Banner \"{0}\"", majorHouse.Banner);
                houseList.Add(new Snippet(banner));
                string seat = string.Format("Seated at {0} {1}", majorHouse.LocName, GetLocationCoords(majorHouse.LocID));
                houseList.Add(new Snippet(seat));
                string loyalty = string.Format("Loyal to the {0} (originally: {1})", majorHouse.Loyalty_Current, majorHouse.Loyalty_AtStart);
                houseList.Add(new Snippet(loyalty));
                string population = string.Format("Populatinn {0:N0} at {1}", majorHouse.Population, majorHouse.LocName);
                houseList.Add(new Snippet(population));
                int bannerTotal = listLordLocations.Count * Game.constant.GetValue(Global.MEN_AT_ARMS) / 2;
                int armyTotal = bannerTotal + majorHouse.MenAtArms;
                displayColor = unknownColor; if (majorHouse.GetInfoStatus(HouseInfo.Military) == true) { displayColor = knownColor; }
                string army = string.Format("Can call upon {0:N0} Men At Arms in Total ({1:N0} from Lord, {2:N0} from Bannerlords)", armyTotal, majorHouse.MenAtArms, bannerTotal);
                houseList.Add(new Snippet(army, displayColor, RLColor.Black));
                displayColor = unknownColor; if (majorHouse.GetInfoStatus(HouseInfo.CastleWalls) == true) { displayColor = knownColor; }
                houseList.Add(new Snippet(string.Format("Strength of Castle Walls ({0}) ", (CastleDefences)majorHouse.CastleWalls), displayColor, RLColor.Black, false));
                displayColor = unknownColor; if (majorHouse.GetInfoStatus(HouseInfo.CastleWalls) == true) { displayColor = RLColor.LightRed; }
                houseList.Add(new Snippet(string.Format("{0}", Game.display.GetStars(majorHouse.CastleWalls)), displayColor, RLColor.Black));
                displayColor = unknownColor; if (majorHouse.GetInfoStatus(HouseInfo.Resources) == true) { displayColor = knownColor; }
                houseList.Add(new Snippet(string.Format("House Resources ({0}) ", (ResourceLevel)majorHouse.Resources), displayColor, RLColor.Black, false));
                displayColor = unknownColor; if (majorHouse.GetInfoStatus(HouseInfo.Resources) == true) { displayColor = RLColor.LightRed; }
                houseList.Add(new Snippet(string.Format("{0}", Game.display.GetStars((int)majorHouse.Resources)), displayColor, RLColor.Black));
                //bannerlords
                int food = majorHouse.FoodCapacity; int granary = majorHouse.FoodStockpile; int popTotal = majorHouse.Population;
                if (listLordLocations.Count > 0)
                {
                    houseList.Add(new Snippet("BannerLords", RLColor.Yellow, RLColor.Black));
                    string bannerLord;
                    foreach (int locID in listLordLocations)
                    {
                        Location loc = Game.network.GetLocation(locID);
                        if (loc != null)
                        {
                            refID = Game.map.GetMapInfo(MapLayer.RefID, loc.GetPosX(), loc.GetPosY());
                            House house = GetHouse(refID);
                            bannerLord = string.Format("House {0} at {1} {2}", house.Name, GetLocationName(locID), GetLocationCoords(locID));
                            houseList.Add(new Snippet(bannerLord));
                            food += house.FoodCapacity;
                            granary += house.FoodStockpile;
                            popTotal += house.Population;
                        }
                        else { Game.SetError(new Error(36, "Invalid Loc (null) BannerLord not added to list")); }
                    }
                }
                //Food and pop realm summary
                houseList.Add(new Snippet("House Realm", RLColor.Yellow, RLColor.Black));
                displayColor = unknownColor; if (majorHouse.GetInfoStatus(HouseInfo.Food) == true) { displayColor = knownColor; }
                houseList.Add(new Snippet($"Realm Population: {popTotal:N0} Realm Harvest: {food:N0} Food Balance: {food - popTotal:N0} Realm Granary: {granary:N0}", displayColor, RLColor.Black));
                //imports & exports
                if (majorHouse.GetNumImports() > 0 || majorHouse.GetNumExports() > 0)
                {
                    int upper, sumGoods;
                    bool newLine;
                    //Imports
                    int numGoods = majorHouse.GetNumImports();
                    if (numGoods > 0)
                    {
                        sumGoods = 0;
                        houseList.Add(new Snippet("Imports -> ", false));
                        int[,] tempImports = majorHouse.GetImports();
                        upper = tempImports.GetUpperBound(0);
                        for (int i = 0; i <= upper; i++)
                        {
                            //at least one present and is known
                            if (tempImports[i, 0] > 0)
                            {
                                sumGoods++;
                                displayColor = unknownColor;
                                if (tempImports[i, 1] > 0) { displayColor = knownColor; }
                                newLine = true;
                                if (sumGoods < numGoods) { newLine = false; }
                                houseList.Add(new Snippet($"{(Goods)i} x {tempImports[i, 0]} ", displayColor, RLColor.Black, newLine));
                            }
                        }
                    }
                    //Exports
                    numGoods = majorHouse.GetNumExports();
                    if (numGoods > 0)
                    {
                        sumGoods = 0;
                        houseList.Add(new Snippet("Exports -> ", false));
                        int[,] tempExports = majorHouse.GetExports();
                        upper = tempExports.GetUpperBound(0);
                        for (int i = 0; i <= upper; i++)
                        {
                            //at least one present and is known
                            if (tempExports[i, 0] > 0)
                            {
                                sumGoods++;
                                displayColor = unknownColor;
                                if (tempExports[i, 1] > 0) { displayColor = knownColor; }
                                newLine = true;
                                if (sumGoods < numGoods) { newLine = false; }
                                houseList.Add(new Snippet($"{(Goods)i} x {tempExports[i, 0]} ", displayColor, RLColor.Black, newLine));
                            }
                        }
                    }
                }
                //family - get list of all actorID's in family
                houseList.Add(new Snippet("Family", RLColor.Brown, RLColor.Black));
                List<int> listOfFamily = new List<int>();
                refID = majorHouse.RefID;
                IEnumerable<int> familyMembers =
                    from person in dictPassiveActors
                    where person.Value.RefID == refID && person.Value is Noble
                    orderby person.Value.ActID
                    select person.Value.ActID;
                listOfFamily = familyMembers.ToList();
                //loop list and display each actor appropriately (dead, or missing, in Lt.Gray)
                string personText;
                string actorType;
                if (listOfFamily.Count > 0)
                {
                    foreach (int actorID in listOfFamily)
                    {
                        Passive person = GetPassiveActor(actorID);
                        if ((int)person.Office > 0) { actorType = Convert.ToString(person.Office); }
                        else { actorType = Convert.ToString(person.Type); }
                        personText = string.Format("Aid {0} {1} {2}, age {3}, ", person.ActID, actorType, person.Name, person.Age);
                        //valid actor?
                        if (person.Name != null)
                        {
                            RLColor locColor = RLColor.White;
                            string locString = "?";
                            //location descriptor
                            switch (person.Status)
                            {
                                case ActorStatus.AtLocation:
                                    locString = string.Format("at {0} {1}", GetLocationName(person.LocID), GetLocationCoords(person.LocID));
                                    break;
                                case ActorStatus.Travelling:
                                    Position pos = person.GetActorPosition();
                                    locString = string.Format("travelling to {0} {1}", GetLocationName(person.LocID), GetLocationCoords(person.LocID));
                                    break;
                                case ActorStatus.Gone:
                                    locString = string.Format("Passed away ({0}) in {1}", person.ReasonGone, person.Gone);
                                    locColor = RLColor.LightGray;
                                    break;
                            }
                            houseList.Add(new Snippet(personText + locString, locColor, RLColor.Black));
                        }
                    }
                }
                else if (majorHouse.RefID == Game.lore.RoyalRefIDCurrent)
                { houseList.Add(new Snippet("Family members are in residence at KingsKeep (Capital)")); }
                //House Retainers - get list of all actorID's
                houseList.Add(new Snippet("Retainers", RLColor.Brown, RLColor.Black));
                List<int> listOfRetainers = new List<int>();
                refID = majorHouse.RefID;
                IEnumerable<int> Retainers =
                    from person in dictPassiveActors
                    where person.Value.RefID == refID && !(person.Value is Noble)
                    orderby person.Value.ActID
                    select person.Value.ActID;
                listOfRetainers = Retainers.ToList();
                // loop list and display each actor appropriately (dead in Lt.Gray)
                string type;
                foreach (int actorID in listOfRetainers)
                {
                    Passive person = GetPassiveActor(actorID);
                    //advisors can be one of three different categories
                    if (person is Advisor) { type = GetAdvisorType((Advisor)person); }
                    else { type = Convert.ToString(person.Type); }
                    personText = string.Format("Aid {0} {1} {2}, age {3}, ", person.ActID, type, person.Name, person.Age);
                    //valid actor?
                    if (person.Name != null)
                    {
                        RLColor locColor = RLColor.White;
                        string locString = "?";
                        //location descriptor
                        switch (person.Status)
                        {
                            case ActorStatus.AtLocation:
                                locString = string.Format("at {0} {1}", GetLocationName(person.LocID), GetLocationCoords(person.LocID));
                                break;
                            case ActorStatus.Travelling:
                                Position pos = person.GetActorPosition();
                                locString = string.Format("travelling to {0} {1}", GetLocationName(person.LocID), GetLocationCoords(person.LocID));
                                break;
                            case ActorStatus.Gone:
                                locString = string.Format("passed away ({0}) in {1}", person.ReasonGone, person.Gone);
                                locColor = RLColor.LightGray;
                                break;
                        }
                        houseList.Add(new Snippet(personText + locString, locColor, RLColor.Black));
                    }
                }
                //Relationships
                List<Relation> tempListRelations = majorHouse.GetRelations();
                if (tempListRelations != null && tempListRelations.Count > 0)
                {
                    houseList.Add(new Snippet("Relations with Other Houses", RLColor.Brown, RLColor.Black));
                    //display relations in chronological order
                    IEnumerable<Relation> relOrdered =
                        from relation in tempListRelations
                        orderby relation.Year
                        select relation;
                    List<Relation> tempRelRecords = relOrdered.ToList();
                    //add snippets
                    string relText;
                    foreach (var relation in tempRelRecords)
                    {
                        if (relation.Known == true) { displayColor = knownColor; } else { displayColor = unknownColor; }
                        relText = string.Format("{0}  {1} {2}, \"{3}\", Rel {4}{5}", relation.Year, relation.RefID >= 100 ? "(Minor)" : "(Major)",
                        GetHouseName(relation.RefID), relation.Text, relation.Change > 0 ? "+" : "", relation.Change);
                        houseList.Add(new Snippet(relText, displayColor, RLColor.Black));
                    }
                }
                //house history
                if (majorHouse.GetInfoStatus(HouseInfo.History) == true) { displayColor = knownColor; } else { displayColor = unknownColor; }
                List<string> houseHistory = GetHistoricalHouseRecords(majorHouse.RefID);
                if (houseHistory.Count > 0)
                {
                    houseList.Add(new Snippet("House History", RLColor.Brown, RLColor.Black));
                    foreach (string text in houseHistory)
                    { houseList.Add(new Snippet(text, displayColor, RLColor.Black)); }
                }
            }
            return houseList;
        }

        /// <summary>
        /// Display Minor House data to main infoConsole (input either houseID or refID, will check houseID first)
        /// </summary>
        /// <param name="houseID"></param>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal List<Snippet> ShowMinorHouseRL(int refID)
        {
            MinorHouse minorHouse = null;
            if (refID > 0)
            { House house = GetHouse(refID); minorHouse = house as MinorHouse; }
            else
            { Game.SetError(new Error(306, "Invalid input RefID (Zero, or less)")); return null; }
            List<Snippet> houseList = new List<Snippet>();
            RLColor unknownColor = RLColor.LightGray;
            RLColor knownColor = RLColor.White;
            RLColor displayColor;
            if (minorHouse != null)
            {
                //details
                houseList.Add(new Snippet("House " + minorHouse.Name, RLColor.Yellow, RLColor.Black));
                string motto = string.Format("Motto \"{0}\"", minorHouse.Motto);
                houseList.Add(new Snippet(motto));
                string banner = string.Format("Banner \"{0}\"", minorHouse.Banner);
                houseList.Add(new Snippet(banner));
                string seat = string.Format("Seated at {0} {1}", minorHouse.LocName, GetLocationCoords(minorHouse.LocID));
                houseList.Add(new Snippet(seat));
                string loyalty = string.Format("Loyal to the {0} (originally: {1})", minorHouse.Loyalty_Current, minorHouse.Loyalty_AtStart);
                houseList.Add(new Snippet(loyalty));
                string population = string.Format("Populatinn {0:N0} at {1}", minorHouse.Population, minorHouse.LocName);
                houseList.Add(new Snippet(population));
                displayColor = unknownColor; if (minorHouse.GetInfoStatus(HouseInfo.Military) == true) { displayColor = knownColor; }
                houseList.Add(new Snippet($"Can call upon {minorHouse.MenAtArms:N0} Men At Arms", displayColor, RLColor.Black));
                displayColor = unknownColor; if (minorHouse.GetInfoStatus(HouseInfo.CastleWalls) == true) { displayColor = knownColor; }
                houseList.Add(new Snippet(string.Format("Strength of Castle Walls ({0}) ", (CastleDefences)minorHouse.CastleWalls), displayColor, RLColor.Black, false));
                displayColor = unknownColor; if (minorHouse.GetInfoStatus(HouseInfo.CastleWalls) == true) { displayColor = RLColor.LightRed; }
                houseList.Add(new Snippet(string.Format("{0}", Game.display.GetStars(minorHouse.CastleWalls)), displayColor, RLColor.Black));
                displayColor = unknownColor; if (minorHouse.GetInfoStatus(HouseInfo.Resources) == true) { displayColor = knownColor; }
                houseList.Add(new Snippet(string.Format("House Resources ({0}) ", (ResourceLevel)minorHouse.Resources), displayColor, RLColor.Black, false));
                displayColor = unknownColor; if (minorHouse.GetInfoStatus(HouseInfo.Resources) == true) { displayColor = RLColor.LightRed; }
                houseList.Add(new Snippet(string.Format("{0}", Game.display.GetStars((int)minorHouse.Resources)), displayColor, RLColor.Black));
                //bannerlords
                int food = minorHouse.FoodCapacity; int granary = minorHouse.FoodStockpile; int popTotal = minorHouse.Population;
                //Food and pop realm summary
                houseList.Add(new Snippet("House Realm", RLColor.Yellow, RLColor.Black));
                food = minorHouse.FoodCapacity; popTotal = minorHouse.Population; granary = minorHouse.FoodStockpile;
                displayColor = unknownColor; if (minorHouse.GetInfoStatus(HouseInfo.Food) == true) { displayColor = knownColor; }
                houseList.Add(new Snippet($"Population: {popTotal:N0} Harvest: {food:N0} Food Balance: {food - popTotal:N0} Realm Granary: {granary:N0}", displayColor, RLColor.Black));
                //imports & exports
                if (minorHouse.GetNumImports() > 0 || minorHouse.GetNumExports() > 0)
                {
                    int upper, sumGoods;
                    bool newLine;
                    //Imports
                    int numGoods = minorHouse.GetNumImports();
                    if (numGoods > 0)
                    {
                        sumGoods = 0;
                        houseList.Add(new Snippet("Imports -> ", false));
                        int[,] tempImports = minorHouse.GetImports();
                        upper = tempImports.GetUpperBound(0);
                        for (int i = 0; i <= upper; i++)
                        {
                            //at least one present and is known
                            if (tempImports[i, 0] > 0)
                            {
                                sumGoods++;
                                displayColor = unknownColor;
                                if (tempImports[i, 1] > 0) { displayColor = knownColor; }
                                newLine = true;
                                if (sumGoods < numGoods) { newLine = false; }
                                houseList.Add(new Snippet($"{(Goods)i} x {tempImports[i, 0]} ", displayColor, RLColor.Black, newLine));
                            }
                        }
                    }
                    //Exports
                    numGoods = minorHouse.GetNumExports();
                    if (numGoods > 0)
                    {
                        sumGoods = 0;
                        houseList.Add(new Snippet("Exports -> ", false));
                        int[,] tempExports = minorHouse.GetExports();
                        upper = tempExports.GetUpperBound(0);
                        for (int i = 0; i <= upper; i++)
                        {
                            //at least one present and is known
                            if (tempExports[i, 0] > 0)
                            {
                                sumGoods++;
                                displayColor = unknownColor;
                                if (tempExports[i, 1] > 0) { displayColor = knownColor; }
                                newLine = true;
                                if (sumGoods < numGoods) { newLine = false; }
                                houseList.Add(new Snippet($"{(Goods)i} x {tempExports[i, 0]} ", displayColor, RLColor.Black, newLine));
                            }
                        }
                    }
                }

                //family - get list of all actorID's in family
                houseList.Add(new Snippet("Family", RLColor.Brown, RLColor.Black));
                List<int> listOfFamily = new List<int>();
                refID = minorHouse.RefID;
                IEnumerable<int> familyMembers =
                    from person in dictPassiveActors
                    where person.Value.RefID == refID && person.Value is BannerLord
                    orderby person.Value.ActID
                    select person.Value.ActID;
                listOfFamily = familyMembers.ToList();
                //loop list and display each actor appropriately (dead, or missing, in Lt.Gray)
                string personText;
                string actorType;
                foreach (int actorID in listOfFamily)
                {
                    Passive person = GetPassiveActor(actorID);
                    if ((int)person.Office > 0) { actorType = Convert.ToString(person.Office); }
                    else { actorType = Convert.ToString(person.Type); }
                    personText = string.Format("Aid {0} {1} {2}, age {3}, ", person.ActID, actorType, person.Name, person.Age);
                    //valid actor?
                    if (person.Name != null)
                    {
                        RLColor locColor = RLColor.White;
                        string locString = "?";
                        //location descriptor
                        switch (person.Status)
                        {
                            case ActorStatus.AtLocation:
                                locString = string.Format("at {0} {1}", GetLocationName(person.LocID), GetLocationCoords(person.LocID));
                                break;
                            case ActorStatus.Travelling:
                                Position pos = person.GetActorPosition();
                                locString = string.Format("travelling to {0} {1}", GetLocationName(person.LocID), GetLocationCoords(person.LocID));
                                break;
                            case ActorStatus.Gone:
                                locString = string.Format("Passed away ({0}) in {1}", person.ReasonGone, person.Gone);
                                locColor = RLColor.LightGray;
                                break;
                        }
                        houseList.Add(new Snippet(personText + locString, locColor, RLColor.Black));
                    }
                }
                //house history
                if (minorHouse.GetInfoStatus(HouseInfo.History) == true) { displayColor = knownColor; } else { displayColor = unknownColor; }
                List<string> houseHistory = GetHistoricalHouseRecords(minorHouse.RefID);
                if (houseHistory.Count > 0)
                {
                    houseList.Add(new Snippet("House History", RLColor.Brown, RLColor.Black));
                    foreach (string text in houseHistory)
                    { houseList.Add(new Snippet(text, displayColor, RLColor.Black)); }
                }
            }
            return houseList;
        }


        /// <summary>
        /// display Royal Court, retainers and others at Kingskeep
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowCapitalRL()
        {
            CapitalHouse capital = GetCapital();
            List<Snippet> capitalList = new List<Snippet>();
            RLColor unknownColor = RLColor.LightGray;
            RLColor knownColor = RLColor.White;
            RLColor displayColor;
            capitalList.Add(new Snippet(string.Format("Kingskeep, Kingdom Capital {0}", GetLocationCoords(1)), RLColor.Yellow, RLColor.Black));
            int capitalWalls = capital.CastleWalls;
            int capitalResources = capital.Resources;
            displayColor = unknownColor; if (capital.GetInfoStatus(HouseInfo.Military) == true) { displayColor = knownColor; }
            capitalList.Add(new Snippet(string.Format("City Watch has {0:N0} Men At Arms", capital.MenAtArms), displayColor, RLColor.Black));
            displayColor = unknownColor; if (capital.GetInfoStatus(HouseInfo.CastleWalls) == true) { displayColor = knownColor; }
            capitalList.Add(new Snippet(string.Format("Strength of Castle Walls ({0}) ", (CastleDefences)capitalWalls), displayColor, RLColor.Black, false));
            displayColor = unknownColor; if (capital.GetInfoStatus(HouseInfo.CastleWalls) == true) { displayColor = RLColor.LightRed; }
            capitalList.Add(new Snippet(string.Format("{0}", Game.display.GetStars(capitalWalls)), displayColor, RLColor.Black));
            displayColor = unknownColor; if (capital.GetInfoStatus(HouseInfo.Resources) == true) { displayColor = knownColor; }
            capitalList.Add(new Snippet(string.Format("Kingdom Treasury Resources ({0}) ", (ResourceLevel)capitalResources), displayColor, RLColor.Black, false));
            displayColor = unknownColor; if (capital.GetInfoStatus(HouseInfo.Resources) == true) { displayColor = RLColor.LightRed; }
            capitalList.Add(new Snippet(string.Format("{0}", Game.display.GetStars(capitalResources)), displayColor, RLColor.Black));
            capitalList.Add(new Snippet("Kingdom Realm", RLColor.Yellow, RLColor.Black));
            displayColor = unknownColor; if (capital.GetInfoStatus(HouseInfo.Food) == true) { displayColor = knownColor; }
            capitalList.Add(new Snippet(string.Format("Population: {0:N0} Harvest: {1:N0} Food Balance: {2:N0} Granary: {3:N0} ", capital.Population, capital.FoodCapacity, 
                capital.FoodCapacity - capital.Population, capital.FoodStockpile ), displayColor, RLColor.Black));
            //imports & exports
            if (capital.GetNumImports() > 0 || capital.GetNumExports() > 0)
            {
                int upper, sumGoods;
                bool newLine;
                //Imports
                int numGoods = capital.GetNumImports();
                if (numGoods > 0)
                {
                    sumGoods = 0;
                    capitalList.Add(new Snippet("Imports -> ", false));
                    int[,] tempImports = capital.GetImports();
                    upper = tempImports.GetUpperBound(0);
                    for (int i = 0; i <= upper; i++)
                    {
                        //at least one present and is known
                        if (tempImports[i, 0] > 0)
                        {
                            sumGoods++;
                            displayColor = unknownColor;
                            if (tempImports[i, 1] > 0) { displayColor = knownColor; }
                            newLine = true;
                            if (sumGoods < numGoods) { newLine = false; }
                            capitalList.Add(new Snippet($"{(Goods)i} x {tempImports[i, 0]} ", displayColor, RLColor.Black, newLine));
                        }
                    }
                }
                //Exports
                numGoods = capital.GetNumExports();
                if (numGoods > 0)
                {
                    sumGoods = 0;
                    capitalList.Add(new Snippet("Exports -> ", false));
                    int[,] tempExports = capital.GetExports();
                    upper = tempExports.GetUpperBound(0);
                    for (int i = 0; i <= upper; i++)
                    {
                        //at least one present and is known
                        if (tempExports[i, 0] > 0)
                        {
                            sumGoods++;
                            displayColor = unknownColor;
                            if (tempExports[i, 1] > 0) { displayColor = knownColor; }
                            newLine = true;
                            if (sumGoods < numGoods) { newLine = false; }
                            capitalList.Add(new Snippet($"{(Goods)i} x {tempExports[i, 0]} ", displayColor, RLColor.Black, newLine));
                        }
                    }
                }
            }
            //ROYAL FAMILY
            capitalList.Add(new Snippet("Royal Family", RLColor.Brown, RLColor.Black));
            //query royal family members at capital
            List<Passive> royalFamily = new List<Passive>();
            IEnumerable<Passive> listOfNobles =
                from actor in dictPassiveActors
                where actor.Value.LocID == 1 && actor.Value is Noble && actor.Value.Status == ActorStatus.AtLocation
                orderby actor.Value.ActID
                select actor.Value;
            royalFamily = listOfNobles.ToList();
            //add to list
            string actorOffice;
            foreach (Passive actor in royalFamily)
            {
                Noble noble = actor as Noble;
                if (noble.Office > ActorOffice.None)
                { actorOffice = Convert.ToString(noble.Office); }
                else { actorOffice = Convert.ToString(noble.Type); }
                capitalList.Add(new Snippet(string.Format("Aid {0} {1} {2}, age {3} at Kingskeep {4}", noble.ActID, actorOffice, noble.Name, noble.Age, GetLocationCoords(1))));
            }
            //ROYAL COURT
            capitalList.Add(new Snippet("Royal Court", RLColor.Brown, RLColor.Black));
            foreach (KeyValuePair<int, Passive> kvp in dictRoyalCourt)
            {
                if (kvp.Value is Advisor)
                {
                    Advisor advisor = kvp.Value as Advisor;
                    actorOffice = Convert.ToString(advisor.advisorRoyal);
                }
                else { actorOffice = Convert.ToString(kvp.Value.Office); }
                capitalList.Add(new Snippet(string.Format("Aid {0} {1} {2}, age {3} at Kingskeep {4}", kvp.Value.ActID, actorOffice, kvp.Value.Name, kvp.Value.Age, GetLocationCoords(1))));
            }
            //OTHERS
            List<Actor> assortedActors = new List<Actor>();
            IEnumerable<Actor> listOfActors =
                from actor in dictActiveActors
                where actor.Value.LocID == 1
                orderby actor.Value.ActID
                select actor.Value;
            assortedActors = listOfActors.ToList();
            //add to list
            if (assortedActors.Count > 0)
            {
                capitalList.Add(new Snippet("Others", RLColor.Brown, RLColor.Black));
                RLColor textColor;
                foreach (Actor actor in assortedActors)
                {
                    if (actor.Office > ActorOffice.None)
                    { actorOffice = Convert.ToString(actor.Office); }
                    else { actorOffice = Convert.ToString(actor.Type); }
                    //highlight active players
                    textColor = RLColor.White;
                    if (actor is Active)
                    {
                        if (actor is Player)
                        { textColor = Color._player; }
                        else
                        { textColor = Color._active; }
                    }
                    capitalList.Add(new Snippet(string.Format("Aid {0} {1} {2}, age {3} at Kingskeep {4}", actor.ActID, actorOffice, actor.Name, actor.Age, GetLocationCoords(1)),
                        textColor, RLColor.Black));
                }
            }
            //Relationships (identical for the King's house)
            MajorHouse majorHouse = (MajorHouse)GetHouse(Game.lore.RoyalRefIDNew);
            if (majorHouse != null)
            {
                List<Relation> tempListRelations = majorHouse.GetRelations();
                if (tempListRelations != null && tempListRelations.Count > 0)
                {
                    string relText;
                    capitalList.Add(new Snippet("Relations with Other Houses", RLColor.Brown, RLColor.Black));
                    //display relations in chronological order
                    /*IEnumerable<string> relRecords =
                        from relation in tempListRelations
                        orderby relation.Year
                        select string.Format("{0}  {1} {2}, \"{3}\", Rel {4}{5}", relation.Year, relation.RefID >= 100 ? "(Minor)" : "(Major)",
                        GetHouseName(relation.RefID), relation.Text, relation.Change > 0 ? "+" : "", relation.Change);
                    List<string> tempRelRecords = relRecords.ToList();
                    //add snippets
                    foreach (string relText in tempRelRecords)
                    {
                        
                        capitalList.Add(new Snippet(relText));
                    }*/

                    IEnumerable<Relation> relOrdered =
                        from relation in tempListRelations
                        orderby relation.Year
                        select relation;
                    List<Relation> tempRelRecords = relOrdered.ToList();
                    //add snippets
                    foreach (var relation in tempRelRecords)
                    {
                        if (relation.Known == true) { displayColor = knownColor; } else { displayColor = unknownColor; }
                        relText = string.Format("{0}  {1} {2}, \"{3}\", Rel {4}{5}", relation.Year, relation.RefID >= 100 ? "(Minor)" : "(Major)",
                        GetHouseName(relation.RefID), relation.Text, relation.Change > 0 ? "+" : "", relation.Change);
                        capitalList.Add(new Snippet(relText, displayColor, RLColor.Black));
                    }
                }
            }
            else { Game.SetError(new Error(136, "New King's House not found (null)")); }

            return capitalList;
        }

        /// <summary>
        /// Select a Player Character from the displayed list
        /// </summary>
        /// <returns>Character ID</returns>
        public int ChooseActor()
        {
            Game.logTurn?.Write("--- ChooseActor (World.cs)");
            Game.logTurn?.Write("Which Character do you want to move (Enter ID #)? ");
            //Console.WriteLine("Which Character do you want to move (Enter ID #)? ");
            int charID = Convert.ToInt32(Console.ReadLine());
            Active person = new Active();
            //check character exists
            if (dictActiveActors.ContainsKey(charID))
            {
                person = dictActiveActors[charID];
                if (person.Status != ActorStatus.AtLocation)
                {
                    Game.logTurn?.Write("That Character isn't at a Location and can't be selected");
                    //Console.WriteLine("That Character isn't at a Location and can't be selected");
                    charID = 0;
                }
            }
            else
            {
                Game.logTurn?.Write("Character doesn't exist!");
                //Console.WriteLine("Character doesn't exist!");
                charID = 0;
            }
            return charID;
        }

        /// <summary>
        /// return a Passive actor from dictPassiveActors
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Passive GetPassiveActor(int actorID)
        {
            Passive person = new Passive();
            if (dictPassiveActors.ContainsKey(actorID))
            { person = dictPassiveActors[actorID]; }
            return person;
        }

        internal Dictionary<int, Passive> GetAllPassiveActors()
        { return dictPassiveActors; }

        /// <summary>
        /// return an Active actor from dictActiveActors, otherwise null
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Active GetActiveActor(int actorID)
        {
            Active person = new Active();
            if (dictActiveActors.ContainsKey(actorID))
            { person = dictActiveActors[actorID]; }
            else { person = null; }
            return person;
        }

        /// <summary>
        /// returns Player player, otherwise null
        /// </summary>
        /// <returns></returns>
        internal Player GetPlayer()
        {
            Player player = new Player();
            if (dictActiveActors.ContainsKey(1))
            { player = (Player)dictActiveActors[1]; }
            else { player = null; }
            return player;
        }

        /// <summary>
        /// return an Enemy actor from dictenemyActors, otherwise null
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Enemy GetEnemyActor(int actorID)
        {
            Enemy person = new Enemy();
            if (dictEnemyActors.ContainsKey(actorID))
            { person = dictEnemyActors[actorID]; }
            else { person = null; }
            return person;
        }


        internal Dictionary<int, Enemy> GetEnemyActors()
        { return dictEnemyActors; }

        /// <summary>
        /// returns any actor -> Passive or Active
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Actor GetAnyActor(int actorID)
        {
            Actor person = new Actor();
            if (dictAllActors.ContainsKey(actorID))
            { person = dictAllActors[actorID]; }
            else { person = null; }
            return person;
        }

        internal Dictionary<int, Actor> GetAllActors()
        { return dictAllActors; }

        /// <summary>
        /// returns dictionary of Active Actors
        /// </summary>
        /// <returns></returns>
        internal Dictionary<int, Active> GetAllActiveActors()
        { return dictActiveActors; }

        /// <summary>
        /// returns string showing character name (at 'x' loc)
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public Snippet GetActorStatusRL(int actID)
        {
            Actor person = new Actor();
            RLColor foreColor = RLColor.White;
            string charReturn = "Character doesn't exist!";
            //check character exists
            if (dictActiveActors.ContainsKey(actID))
            {
                person = dictActiveActors[actID];
                charReturn = person.Name;
                if (person.Status != ActorStatus.AtLocation)
                { charReturn += " isn't currently available (must be at a Location in order to be Moved)"; foreColor = RLColor.LightRed; }
                else
                {
                    Position pos = person.GetActorPosition();
                    charReturn += " is awaiting your orders at ";
                    charReturn += GetLocationName(person.LocID);
                    charReturn += string.Format(" (loc {0}:{1})", pos.PosX, pos.PosY);
                }
            }
            return new Snippet(charReturn, foreColor, RLColor.Black);
        }

        /// <summary>
        /// returns true if Player at specified location and their status is 'AtLocation' (used by DrawMapRL)
        /// </summary>
        /// <param name="locID"></param>
        /// <returns></returns>
        public bool GetPlayerLocStatus(int locID)
        {
            //check player in dictionary
            if (dictActiveActors.ContainsKey(1))
            {
                Active player = dictActiveActors[1];
                if (player.Status == ActorStatus.AtLocation)
                {
                    if (player.LocID == locID)
                    { return true; }
                }
            }
            return false;
        }

        /// <summary>
        /// returns Revert # of days for specified active actor. A value of 0 indicates a status of Unknown (eg. 'Known' = false)
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public int GetActiveActorKnownStatus(int actID)
        {
            //check active actor in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active active = dictActiveActors[actID];
                if (active.Status != ActorStatus.Gone)
                { return active.Revert; }
                else { Game.SetError(new Error(137, string.Format("Active Actor, actID {0},  \"Gone\"", active.ActID))); }
            }
            else { Game.SetError(new Error(137, "Active Actor not found in dictActiveActors")); }
            return 0;
        }

        /// <summary>
        /// returns true if specified actor has the indicated status, otherwise false
        /// </summary>
        /// <param name="actorID"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        public bool CheckActorStatus(int actorID, ActorStatus status)
        {
            Actor actor = GetAnyActor(actorID);
            if (actor != null)
            { if (actor.Status == status) { return true; } }
            else { Game.SetError(new Error(191, string.Format("Invalid Actor input (null), ActID {0}, status {1}", actorID, status))); }
            return false;
        }


        /// <summary>
        /// nameOnly true -> actor.Name, nameOnly false -> actors Title + Name + ActID + 'at' + Location ('Coords)
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public string GetActorDetails(int actID, bool nameOnly = true)
        {
            string details = "";
            //check active actor in dictionary
            if (dictAllActors.ContainsKey(actID))
            {
                Actor actor = dictAllActors[actID];
                if (nameOnly == true)
                { return actor.Name; }
                else
                { return string.Format("{0} {1}, ActID {2} at {3} {4}", actor.Title, actor.Name, actor.ActID, GetLocationName(actor.LocID), GetLocationCoords(actor.LocID)); }
            }
            else { Game.SetError(new Error(172, string.Format("Actor not found in dictAllActors (ActID {0})", actID))); }
            return details;
        }

        /// <summary>
        /// returns num days since player was last Known
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public int GetActiveActorTrackingStatus(int actID)
        {
            //check active actor in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active active = dictActiveActors[actID];
                if (active.Status != ActorStatus.Gone)
                { return active.TurnsUnknown; }
                else { Game.SetError(new Error(137, string.Format("Active Actor, actID {0},  \"Gone\"", active.ActID))); }
            }
            else { Game.SetError(new Error(137, "Active Actor not found in dictActiveActors")); }
            return 0;
        }

        /// <summary>
        /// change an Active Actors known status -> data +ve then switch to UNKNOWN, if -ve then KNOWN (if already Known then reset Revert timer to 0). Returns MT if insuccessful
        /// </summary>
        /// <param name="actID"></param>
        /// <param name="data">data +ve then switch to UNKNOWN, if -ve then KNOWN</param>
        /// <returns></returns>
        public string SetActiveActorKnownStatus(int actID, int data)
        {
            string resultText = "";
            int maxRevert = Game.constant.GetValue(Global.KNOWN_REVERT);
            //check active actor in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active active = dictActiveActors[actID];
                if (active.Status != ActorStatus.Gone)
                {
                    if (data < 0)
                    {
                        bool disguiseFlag = false;
                        //Known -> if already known resert Revert timer to the max.
                        if (active is Player)
                        {
                            //player in disguise? -> serves to soak up the hit (disguise loses a level)
                            Player player = active as Player;
                            if (player.Conceal == ActorConceal.Disguise)
                            { CheckConcealment(); disguiseFlag = true; }
                        }
                        //Non-Player, or player who isn't in Disguise
                        if (active.Known == true)
                        { resultText = string.Format("{0} {1} has had their Known timer increased to the maximum ({2} days)", active.Title, active.Name, maxRevert); }
                        else
                        {
                            active.Known = true;
                            if (disguiseFlag == false)
                            { resultText = string.Format("{0} {1} is now KNOWN ({2} days)", active.Title, active.Name, maxRevert); }
                            else
                            { resultText = $"{active.Title} {active.Name}'s disguise has prevented {active.SexText} from becoming Known"; }
                        }
                        active.Revert = maxRevert;
                        //reset TurnsUnknown timer back to zero
                        active.TurnsUnknown = 0;
                        active.LastKnownLocID = active.LocID;
                    }
                    else if (data > 0)
                    {
                        //Unknown
                        active.Known = false;
                        active.Revert = 0;
                        resultText = string.Format("{0} {1} is now UNKNOWN", active.Title, active.Name);
                    }
                    else { Game.SetError(new Error(138, "Invalid Data Input (zero)")); }
                    return resultText;
                }
                else { Game.SetError(new Error(138, string.Format("Active Actor, actID {0},  \"Gone\"", active.ActID))); }
            }
            else { Game.SetError(new Error(138, "Active Actor not found in dictActiveActors")); }
            return resultText;
        }

        /// <summary>
        /// selects an active actor for movement orders if at a location and activated, returns null otherwise
        /// </summary>
        /// <param name="charID"></param>
        /// <returns></returns>
        internal Position GetActiveActorLocationByPos(int charID)
        {
            Position pos = new Position();
            //find in dictionary
            if (dictActiveActors.ContainsKey(charID))
            {
                Active person = dictActiveActors[charID];
                pos = person.GetActorPosition();
                //can't be selected if not at a Location
                if (person.Status != ActorStatus.AtLocation) { pos = null; }
                //can't be selected if not activated
                if (person.Activated == false) { pos = null; }
            }
            else
            { pos = null; }
            return pos;
        }


        /// <summary>
        /// returns current Loc (their destination if travelling)
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public int GetActiveActorLocByID(int actID)
        {
            int locID = 0;
            //find in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active person = dictActiveActors[actID];
                locID = person.LocID;
            }
            return locID;
        }

        /// <summary>
        /// returns Last Known Loc of Active Actor (their destination if travelling)
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public int GetActiveActorLastKnownLoc(int actID)
        {
            int locID = 0;
            //find in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active person = dictActiveActors[actID];
                locID = person.LastKnownLocID;
            }
            return locID;
        }

        /// <summary>
        /// Checks dictSpecialActors and, if found, returns ActorID, otherwise '0'
        /// </summary>
        /// <param name="specialID"></param>
        /// <returns></returns>
        internal int GetSpecialActorID(int specialID)
        {
            int actorID = 0;
            if (specialID > 0)
            {
                if (dictSpecialActors.ContainsKey(specialID))
                {
                    Special person = dictSpecialActors[specialID];
                    return person.ActID;
                }
            }
            else { Game.SetError(new Error(213, "Invalid specialID (zero, or less)")); }
            return actorID;
        }

        /// <summary>
        /// receives list of Houses from Network and places in releveant House Dictionaries for permanent use
        /// </summary>
        /// <param name="listOfHouses"></param>
        internal void InitialiseHouses()
        {
            int menAtArms = Game.constant.GetValue(Global.MEN_AT_ARMS);
            Game.network.UpdateHouses(Game.history.GetMajorHouses());
            Game.logStart?.Write("---  InitialiseHouses (World.cs) ---");
            //great houses
            List<MajorHouse> listOfMajorHouses = Game.history.GetMajorHouses();
            foreach (MajorHouse house in listOfMajorHouses)
            { AddMajorHouse(house); }
            //populate sorted dictionary (descending) of house ID's by Power (# of BannerLords)
            SortMajorHouses();
            //minor houses
            List<House> listOfMinorHouses = Game.history.GetMinorHouses();
            foreach (House house in listOfMinorHouses)
            { dictAllHouses.Add(house.RefID, house); }
            //capital
            List<CapitalHouse> listOfCapitalHouses = Game.history.GetCapitalHouses();
            foreach (House house in listOfCapitalHouses)
            { dictAllHouses.Add(house.RefID, house); house.MenAtArms = menAtArms; }
            //initialise Special Locations
            Game.history.InitialiseSpecialHouses();
            //update Map layer for RefID
            int locID = 0;
            int refID = 0;
            foreach (KeyValuePair<int, House> record in dictAllHouses)
            {
                locID = record.Value.LocID;
                refID = record.Value.RefID;
                Location loc = Game.network.GetLocation(locID);
                if (loc != null) { Game.map.SetMapInfo(MapLayer.RefID, loc.GetPosX(), loc.GetPosY(), refID); }
                else { Game.SetError(new Error(188, "Invalid Loc (null) Map Layer not updated")); }
            }
            //populate list of Bannerlord RefID's in Major Houses
            foreach (MajorHouse house in listOfMajorHouses)
            {
                List<int> bannerLords = house.GetBannerLordLocations();
                int minorRefID;
                if (bannerLords.Count > 0)
                {
                    foreach (int minorLocID in bannerLords)
                    {
                        Location loc = Game.network.GetLocation(minorLocID);
                        if (loc != null)
                        {
                            minorRefID = Game.map.GetMapInfo(MapLayer.RefID, loc.GetPosX(), loc.GetPosY());
                            house.AddBannerLord(minorRefID);
                        }
                        else { Game.SetError(new Error(188, "Invalid minorLoc (null) Bannerlord not added to Great House list")); }
                    }
                }
            }
            //fill Great Houses with Lords and Ladies
            Game.logStart?.Write("- House Genetics (add Lords and Ladies)");
            foreach (KeyValuePair<int, MajorHouse> kvp in dictMajorHouses)
            {
                //create Lord and Lady for house
                Location loc = Game.network.GetLocation(kvp.Value.LocID);
                if (loc != null)
                {
                    Position pos = loc.GetPosition();
                    Noble actorLord = (Noble)Game.history.CreateStartingHouseActor(kvp.Value.Name, ActorType.Lord, pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID);
                    Noble actorLady = (Noble)Game.history.CreateStartingHouseActor(kvp.Value.Name, ActorType.Lady, pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID,
                        ActorSex.Female, WifeStatus.First_Wife);
                    //add Lord to House
                    kvp.Value.LordID = actorLord.ActID;
                    //create a knight, castellan and maester for each Major house
                    Knight actorKnight = Game.history.CreateKnight(pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID);
                    Advisor actorCastellan = Game.history.CreateAdvisor(pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID, ActorSex.Male, AdvisorNoble.Castellan);
                    Advisor actorMaester = Game.history.CreateAdvisor(pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID, ActorSex.Male, AdvisorNoble.Maester);
                    Advisor actorSepton = Game.history.CreateAdvisor(pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID, ActorSex.Male, AdvisorNoble.Septon);
                    //add to dictionaries of actors
                    SetPassiveActor(actorLord);
                    SetPassiveActor(actorLady);
                    SetPassiveActor(actorKnight);
                    SetPassiveActor(actorCastellan);
                    SetPassiveActor(actorMaester);
                    SetPassiveActor(actorSepton);
                    //create family
                    Game.history.CreateFamily(actorLord, actorLady);
                    //add MenAtArms (needed to be done here -> sequence issues with history. InitialisePastHistory)
                    kvp.Value.MenAtArms = menAtArms;

                }
                else { Game.SetError(new Error(188, "Invalid Loc (null) Lord and Lady not created")); }
                //check if lady died in childbirth
                /* if (actorLady.Status == ActorStatus.Gone)
                 {
                     int yearWifeDied = actorLady.Died;
                     //40% chance of remarrying
                     if (rnd.Next(100) < 40)
                     {
                         //new wife
                         Passive actor2ndWife = Game.history.CreatePassiveActor(kvp.Value.Name, ActorTitle.Lady, pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID, 
                             ActorSex.Female, WifeStatus.Second_Wife);
                         //add to dictionaries of actors
                         dictPassiveActors.Add(actor2ndWife.ActID, actor2ndWife);
                         dictAllActors.Add(actor2ndWife.ActID, actor2ndWife);
                         //location born (different for lady)
                         House wife2ndHouse = GetHouse(actor2ndWife.BornRefID);
                         Location loc2ndWife = Game.network.GetLocation(wife2ndHouse.LocID);
                         descriptor = string.Format("{0} (nee {1}, Aid {2}) born at {3}", actor2ndWife.Name, actor2ndWife.MaidenName, actor2ndWife.ActID, loc2ndWife.LocName);
                         Record record2ndWife = new Record(descriptor, actor2ndWife.ActID, loc2ndWife.LocationID, actor2ndWife.BornRefID, actor2ndWife.Born, HistEvent.Born);
                         //create records of being born
                         SetRecord(record2ndWife);
                         //store actor in location
                         loc.AddActor(actor2ndWife.ActID);
                         //create family
                         Game.history.CreatePassiveFamily(actorLord, actor2ndWife);
                     }
                 }*/
            }
            //hand out bastards and adopted sons to lords with no heirs
            CheckGreatLords();
            //fill minor houses with BannerLords
            foreach (KeyValuePair<int, House> kvp in dictAllHouses)
            {
                //minor houses only
                if (kvp.Value is MinorHouse)
                {
                    //create BannerLord for house
                    Location loc = Game.network.GetLocation(kvp.Value.LocID);
                    if (loc != null)
                    {
                        Position pos = loc.GetPosition();
                        BannerLord bannerLord = (BannerLord)Game.history.CreateStartingHouseActor(kvp.Value.Name, ActorType.BannerLord, pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID);
                        //add to dictionaries of actors
                        dictPassiveActors.Add(bannerLord.ActID, bannerLord);
                        dictAllActors.Add(bannerLord.ActID, bannerLord);
                        //add Lord to house
                        kvp.Value.LordID = bannerLord.ActID;
                        //add MenAtArms (needed to be done here -> sequence issues with history. InitialisePastHistory)
                        kvp.Value.MenAtArms = menAtArms / 2;
                    }
                    else { Game.SetError(new Error(188, "Invalid Loc (null) Bannerlord not created")); }
                }
            }
            //assign 9999 refId to the capital
            Location capital = Game.network.GetLocation(1);
            if (capital != null)
            { Game.map.SetMapInfo(MapLayer.RefID, capital.GetPosX(), capital.GetPosY(), 9999); }
            else { Game.SetError(new Error(188, "Invalid CapitalLoc (null) RefID not updated")); }
        }

        /// <summary>
        /// creates dictHousePower of strongest to weakest houses
        /// </summary>
        internal void SortMajorHouses()
        {
            dictHousePower.Clear();
            foreach (KeyValuePair<int, int> kvp in dictMajorHouseID.OrderByDescending(key => key.Value))
            { dictHousePower.Add(kvp.Key, kvp.Value); }
        }


        /// <summary>
        /// adds a Major House to all relevant dictionaries
        /// </summary>
        /// <param name="house"></param>
        internal void AddMajorHouse(MajorHouse house)
        {
            try
            {
                dictMajorHouses.Add(house.HouseID, house);
                dictAllHouses.Add(house.RefID, house);
                dictMajorHouseID.Add(house.HouseID, house.GetNumBannerLords());
            }
            catch (Exception e)
            { Game.SetError(new Error(34, e.Message)); }
        }

        /// <summary>
        /// Add non-Major house to the only relevant dictionary
        /// </summary>
        /// <param name="house"></param>
        internal void AddOtherHouse(House house)
        { dictAllHouses.Add(house.RefID, house); }

        /// <summary>
        /// Add a possession to the dictionary, return true if successful
        /// </summary>
        /// <param name="possID"></param>
        /// <param name="possObject"></param>
        /// <returns></returns>
        public bool AddPossession(int possID, Possession possObject)
        {
            try
            { dictPossessions.Add(possID, possObject); return true; }
            catch (ArgumentNullException)
            { Game.SetError(new Error(123, "Invalid Possession Object (null), possID")); }
            catch (ArgumentException)
            { Game.SetError(new Error(123, string.Format("Invalid possessionID (duplicate ID), possID {0}", possID))); }
            return false;
        }


        /// <summary>
        /// Add a rumour to the dictRumoursKnown (to Player), returns true if successful
        /// </summary>
        /// <param name="rumourID"></param>
        /// <param name="rumourObject"></param>
        /// <returns></returns>
        internal bool AddRumourKnown(int rumourID, Rumour rumourObject)
        {
            try
            { dictRumoursKnown.Add(rumourID, rumourObject); return true; }
            catch (ArgumentNullException)
            { Game.SetError(new Error(273, $"Invalid Rumour Object (null), rumourID {rumourID}")); }
            catch (ArgumentException)
            { Game.SetError(new Error(273, $"Invalid rumourID (duplicate ID), rumourID {rumourID}")); }
            return false;
        }

        /// <summary>
        /// Add a rumour to the dictRumoursNormal, returns true if successful
        /// </summary>
        /// <param name="rumour"></param>
        /// <returns></returns>
        internal bool AddRumourNormal(Rumour rumour)
        {
            try
            { dictRumoursNormal.Add(rumour.RumourID, rumour); return true; }
            catch (ArgumentNullException)
            { Game.SetError(new Error(273, $"Invalid Rumour (null), Normal rumourID {rumour.RumourID}")); }
            catch (ArgumentException)
            { Game.SetError(new Error(273, $"Invalid rumourID (duplicate ID), Normal rumourID {rumour.RumourID}")); }
            return false;
        }

        /// <summary>
        /// Add a rumour to the dictRumoursTimed, returns true if successful
        /// </summary>
        /// <param name="rumour"></param>
        /// <returns></returns>
        internal bool AddRumourTimed(Rumour rumour)
        {
            try
            { dictRumoursTimed.Add(rumour.RumourID, rumour); return true; }
            catch (ArgumentNullException)
            { Game.SetError(new Error(290, $"Invalid Rumour (null), Timed rumourID {rumour.RumourID}")); }
            catch (ArgumentException)
            { Game.SetError(new Error(290, $"Invalid rumourID (duplicate ID), Timed rumourID {rumour.RumourID}")); }
            return false;
        }

        /// <summary>
        /// Add a rumour to the dictRumoursInactive, returns true if successful
        /// </summary>
        /// <param name="rumour"></param>
        /// <returns></returns>
        internal bool AddRumourInactive(Rumour rumour)
        {
            try
            { dictRumoursInactive.Add(rumour.RumourID, rumour); return true; }
            catch (ArgumentNullException)
            { Game.SetError(new Error(291, $"Invalid Rumour (null), Inactive rumourID {rumour.RumourID}")); }
            catch (ArgumentException)
            { Game.SetError(new Error(291, $"Invalid rumourID (duplicate ID), Inactive rumourID {rumour.RumourID}")); }
            return false;
        }

        /// <summary>
        /// remove a Timed rumour if it exists in dictRumoursTimed
        /// </summary>
        /// <param name="rumourID"></param>
        /// <returns></returns>
        internal bool RemoveRumourTimed(int rumourID)
        {
            if (dictRumoursTimed.ContainsKey(rumourID) == true)
            {
                dictRumoursTimed.Remove(rumourID);
                Game.logTurn?.Write($"[Rumour -> Deleted] Timed RumourID {rumourID} removed from dictRumoursTimed");
                return true;
            }
            return false;
        }

        internal Dictionary<int, Rumour> GetRumoursKnown()
        { return dictRumoursKnown; }

        /// <summary>
        /// find entry with same RefID in dictAllHouses and removes it if present (used by lore.cs CreateNewMajorHouse)
        /// </summary>
        /// <param name="refID"></param>
        internal void RemoveMinorHouse(int refID)
        {
            if (!dictAllHouses.Remove(refID))
            { Game.SetError(new Error(35, "House not found")); }
        }

        /// <summary>
        /// find and remove Great House from all relevant dictionaries
        /// </summary>
        /// <param name="refID"></param>
        internal void RemoveMajorHouse(House house)
        {
            //if (!dictAllHouses.Remove(house.RefID)) -> leave this as it doesn't affect major house calculations and retains house records
            //{ Game.SetError(new Error(35, "House not found")); }
            if (!dictMajorHouses.Remove(house.HouseID))
            { Game.SetError(new Error(35, "House not found")); }
            if (!dictMajorHouseID.Remove(house.HouseID))
            { Game.SetError(new Error(35, "House not found")); }
        }

        /// <summary>
        /// checks GreatLords for having no sons at Game Start
        /// </summary>
        private void CheckGreatLords()
        {
            //loop all passive actors
            bool foundSon;
            int wifeID = 0;
            int yearUpper; //upper and lower bounds for determining what year child is born
            int yearLower;
            int yearBorn;
            List<int> listOfLords = new List<int>(); //ActID of lords who are in need of a son
            List<int> listOfLadies = new List<int>(); //ActID of ladies who are in need of a son (lord and lady have identical indexes)
            foreach (KeyValuePair<int, Passive> kvp in dictPassiveActors)
            {
                foundSon = false;
                //lord?
                if (kvp.Value.Type == ActorType.Lord && kvp.Value.Status != ActorStatus.Gone)
                {
                    //Loop family looking for a son
                    Noble noble = kvp.Value as Noble;
                    SortedDictionary<int, ActorRelation> tempDictFamily = noble.GetFamily();
                    foreach (KeyValuePair<int, ActorRelation> family_kvp in tempDictFamily)
                    {
                        if (family_kvp.Value == ActorRelation.Son)
                        { foundSon = true; }
                        else if (family_kvp.Value == ActorRelation.Wife)
                        { wifeID = family_kvp.Key; }
                    }
                    //if no son provide one
                    if (foundSon == false)
                    {
                        listOfLords.Add(kvp.Value.ActID);
                        listOfLadies.Add(wifeID);
                    }
                }
            }
            //who needs a son?
            if (listOfLords.Count > 0)
            {
                for (int i = 0; i < listOfLords.Count; i++)
                {
                    //50/50 bastard or adopted
                    ActorParents parents = ActorParents.Bastard;
                    if (rnd.Next(100) < 50)
                    { parents = ActorParents.Adopted; }
                    //create a child
                    Noble Lord = (Noble)GetPassiveActor(listOfLords[i]);
                    Noble Lady = (Noble)GetPassiveActor(listOfLadies[i]);
                    //get year
                    yearUpper = Game.gameRevolt;
                    if (Lady.Status == ActorStatus.Gone)
                    { yearUpper = Lady.Gone; }
                    yearLower = Lady.Married;
                    yearBorn = rnd.Next(yearLower, yearUpper);
                    Game.history.CreateChild(Lord, Lady, yearBorn, ActorSex.Male, parents);
                }
            }
        }


        /// <summary>
        /// populates dictionary of GeoLocations
        /// </summary>
        private void InitialiseGeoClusters()
        {
            List<GeoCluster> tempList = Game.history.GetGeoClusters();
            foreach (GeoCluster cluster in tempList)
            { dictGeoClusters.Add(cluster.GeoID, cluster); }
        }

        /// <summary>
        /// populates dictionary of Traits
        /// </summary>
        private void InitialiseTraits()
        {
            List<Skill> tempList = Game.history.GetTraits();
            foreach (Skill trait in tempList)
            { dictTraits.Add(trait.SkillID, trait); }
        }


        /// <summary>
        /// assigns each Passive character a desire
        /// </summary>
        private void InitialiseDesires()
        {
            Game.logStart?.Write("--- InitialiseDesires (World.cs)");
            List<PossPromiseType> listOfPossibleDesires = new List<PossPromiseType>();
            //list to hold specific desires
            List<int> listOfSonsAndBrothers = new List<int>();
            List<int> listOfDaughters = new List<int>();
            List<int> listOfMinorHouses = new List<int>();
            //Land
            int[,] networkAnalysis = Game.network.GetNetworkAnalysis();
            //item reason texts, 'because it...'
            string[] itemReasons = new string[] { "is their birthright", "was forseen", "has been predicted by prophecy", "is an ancestral heirloom", "belongs to their house", "belongs to them",
                "might help their enemies", "is their destiny" };
            string reason;
            bool itemProceed = true;
            //Royal household (new King)
            MajorHouse royalHouse = (MajorHouse)GetHouse(Game.lore.RoyalRefIDNew);
            //List of all Passive Items
            IEnumerable<Item> listItems =
                from items in dictPossessions.Values.OfType<Item>()
                where items.ItemType == PossItemType.Passive
                select items;
            List<Item> listOfPassiveItems = listItems.ToList();
            int possID;
            //note array should correspond exactly to enum PossPromiseType
            for (int i = 0; i < dictPassiveActors.Count; i++)
            {
                //clear out lists
                listOfPossibleDesires.Clear();
                listOfSonsAndBrothers.Clear();
                listOfMinorHouses.Clear();
                listOfDaughters.Clear();
                Passive actor = dictPassiveActors.ElementAt(i).Value;
                //Item (applies to all but is assigned seperately)
                Item item = listOfPassiveItems[rnd.Next(listOfPassiveItems.Count)];
                possID = item.PossID;
                //check item not already owned by actor
                if (actor.CheckItems(PossItemType.Passive) == true)
                {
                    List<int> tempList = actor.GetItems(PossItemType.Passive);
                    foreach (var objectID in tempList)
                    {
                        if (objectID == item.PossID)
                        { itemProceed = false; break; }
                    }
                }
                if (actor.Status != ActorStatus.Gone)
                {
                    //load up listOfPossibleDesires with relevant Desires
                    switch (actor.Type)
                    {
                        case ActorType.Lord:
                            //King is also a Lord
                            if (actor.Office != ActorOffice.King)
                            {
                                Noble lord = actor as Noble;
                                House house = GetHouse(actor.RefID);
                                if (house != null)
                                {
                                    //Land
                                    if (house is MajorHouse)
                                    {
                                        MajorHouse majorHouse = house as MajorHouse;
                                        List<int> listBannerLords = majorHouse.GetBannerLordLocations();
                                        int numHouses = listBannerLords.Count;
                                        int branch = majorHouse.Branch;
                                        int majorHouses = networkAnalysis[branch, (int)NetGrid.MajorHouses];
                                        int totalLocs = networkAnalysis[branch, (int)NetGrid.Locations];
                                        int specials = networkAnalysis[branch, (int)NetGrid.Specials];
                                        int locID = majorHouse.LocID;
                                        int index = 999;
                                        int houseID = majorHouse.HouseID;
                                        //are there any houses on the same branch of a different house?
                                        if ((totalLocs - majorHouses - specials - numHouses) > 0)
                                        {
                                            Game.logStart?.Write($"There are enough houses on branch {house.Branch} for \"{house.Name}\" to desire Land");

                                            List<Location> listBranchLocs = Game.network.GetBranchLocs(branch);
                                            //find major house position in list (sorted by distance from capital)
                                            if (listBranchLocs != null)
                                            {
                                                for (int j = 0; j < listBranchLocs.Count; j++)
                                                {
                                                    Location loc = listBranchLocs[j];
                                                    if (loc.LocationID == locID)
                                                    { index = j; break; }
                                                }
                                                //found MajorHouse?
                                                if (index < 999)
                                                {
                                                    if ((index + 1) < listBranchLocs.Count)
                                                    {
                                                        //loop forward looking for first minor House belonging to someone else
                                                        for (int m = index + 1; m < listBranchLocs.Count; m++)
                                                        {
                                                            Location loc = listBranchLocs[m];
                                                            if (loc.HouseID != houseID)
                                                            {
                                                                House searchHouse = GetHouse(loc.RefID);
                                                                if (searchHouse != null)
                                                                {
                                                                    if (searchHouse is MinorHouse)
                                                                    {
                                                                        listOfMinorHouses.Add(searchHouse.RefID);
                                                                        Game.logStart?.Write($"[Alert -> Out Neighbour] MinorHouse \"{searchHouse.Name}\", RefID {searchHouse.RefID}, added to listOfMinorHouses");
                                                                        break;
                                                                    }
                                                                }
                                                                else { Game.SetError(new Error(234, "Invalid searchHouse (null) -> Out")); }
                                                            }
                                                        }
                                                    }
                                                    else { Game.logStart?.Write("[Alert -> Index] listOfBranchLocs Index is too high"); }
                                                    if ((index - 1) >= 0)
                                                    {
                                                        //loop backwards looking for first minor House belonging to someone else
                                                        for (int m = index - 1; m >= 0; m--)
                                                        {
                                                            Location loc = listBranchLocs[m];
                                                            if (loc.HouseID != houseID)
                                                            {
                                                                House searchHouse = GetHouse(loc.RefID);
                                                                if (searchHouse != null)
                                                                {
                                                                    if (searchHouse is MinorHouse)
                                                                    {
                                                                        listOfMinorHouses.Add(searchHouse.RefID);
                                                                        Game.logStart?.Write($"[Alert -> In Neighbour] MinorHouse \"{searchHouse.Name}\", RefID {searchHouse.RefID}, added to listOfMinorHouses");
                                                                        break;
                                                                    }
                                                                }
                                                                else { Game.SetError(new Error(234, "Invalid searchHouse (null) -> In")); }
                                                            }
                                                        }
                                                    }
                                                    else { Game.logStart?.Write("[Alert -> Index] listOfBranchLocs Index is too low"); }
                                                    //if two possible minor houses delete the one that is furthest away
                                                    if (listOfMinorHouses.Count > 1)
                                                    {
                                                        Game.logStart?.Write("There are two minor houses, furthest will be eliminated");
                                                        Location locMajor = Game.network.GetLocation(majorHouse.LocID);
                                                        int[] arrayDistance = new int[listOfMinorHouses.Count];
                                                        for (int p = 0; p < listOfMinorHouses.Count; p++)
                                                        {
                                                            //work out distances
                                                            House checkHouse = GetHouse(listOfMinorHouses[p]);
                                                            if (checkHouse != null)
                                                            {
                                                                Location locMinor = Game.network.GetLocation(checkHouse.LocID);
                                                                List<Route> route = Game.network.GetRouteAnywhere(locMajor.GetPosition(), locMinor.GetPosition());
                                                                arrayDistance[p] = Game.network.GetDistance(route);
                                                                Game.logStart?.Write($"[Alert -> Distance] MinorHouse \"{checkHouse.Name}\", RefID {checkHouse.RefID}, (Loc {locMinor.GetPosX()}:{locMinor.GetPosY()}) -> Distance {arrayDistance[p]}");
                                                            }
                                                        }
                                                        //find shortest distance
                                                        int minDistance = 999;
                                                        int minIndex = 999;
                                                        for (int q = 0; q < arrayDistance.Length; q++)
                                                        {
                                                            if (arrayDistance[q] < minDistance)
                                                            {
                                                                minDistance = arrayDistance[q];
                                                                minIndex = q;
                                                            }
                                                        }
                                                        //make sure only the shortest distance minorHouse loc remains in the list
                                                        if (minIndex < 999)
                                                        {
                                                            int shortestRefID = listOfMinorHouses[minIndex];
                                                            listOfMinorHouses.Clear();
                                                            listOfMinorHouses.Add(shortestRefID);
                                                            Game.logStart?.Write($"Minor House RefID {shortestRefID} retained, others deleted");
                                                        }
                                                        else { Game.SetError(new Error(234, "Invalid minIndex (999)")); }
                                                    }
                                                }
                                                else { Game.SetError(new Error(234, $"Major House \"{majorHouse.Name}\" not found in listOfBranchLocs")); }
                                            }
                                            else { Game.SetError(new Error(234, "Invalid listBranchLocs (null)")); }
                                            //if no neighbours have been found on straight shot routes then need to get a random minor house from the branch
                                            if (listOfMinorHouses.Count == 0)
                                            { Game.logStart?.Write($"[Alert -> Cancelled] No neighbouring minor houses found"); }
                                        }
                                        else
                                        {
                                            Game.logStart?.Write($"Insufficient houses for \"{house.Name}\", branch {house.Branch} -> totalLoc {totalLocs} MajorH {majorHouses} Specials {specials} ActorH {numHouses}");
                                            //only one house on branch
                                            if (majorHouses == 1)
                                            {
                                                //Is there a connector to another branch?
                                                int[,] connectorAnalysis = Game.map.GetArrayOfConnectors();
                                                int branchConnection = connectorAnalysis[branch, 0];
                                                if (branchConnection > 0)
                                                {
                                                    Game.logStart?.Write($"[Alert] Connection exists between branch {branch} and {branchConnection}");
                                                    //is the location on the other end of the connection a minor house?
                                                    int posX = connectorAnalysis[branch, 4];
                                                    int posY = connectorAnalysis[branch, 5];
                                                    int refID = Game.map.GetMapInfo(MapLayer.RefID, posX, posY);
                                                    if (refID > 0)
                                                    {
                                                        House connHouse = GetHouse(refID);
                                                        if (connHouse != null)
                                                        {
                                                            if (connHouse is MinorHouse)
                                                            {
                                                                //this minor house is the only possibility
                                                                Game.logStart?.Write($"[Alert -> Connector] Minor House \"{connHouse.Name}\" exists at end of Connector");
                                                                listOfMinorHouses.Add(connHouse.RefID);
                                                            }
                                                            else { Game.logStart?.Write($"[Alert -> Connector] A minor house does NOT exist at the end of the connector"); }
                                                        }
                                                        else { Game.SetError(new Error(234, "Invalid connHouse (null)")); }
                                                    }
                                                    else { Game.SetError(new Error(234, "Invalid refID (zero, or less)")); }
                                                }
                                                else { Game.logStart?.Write($"[Alert] NO Connection exists on branch {branch}"); }
                                            }
                                        }
                                    }
                                    //Family
                                    SortedDictionary<int, ActorRelation> dictFamily = lord.GetFamily();
                                    //Game.logStart?.Write($"Lord {lord.Name}  \"{lord.Handle}\" of House {house.Name}, ActID {lord.ActID}");
                                    foreach (var familyMember in dictFamily)
                                    {
                                        Passive relative = GetPassiveActor(familyMember.Key);
                                        if (relative != null)
                                        {
                                            if (relative.Status != ActorStatus.Gone)
                                            {
                                                //Game.logStart?.Write($"ActID {familyMember.Key} Relationship {familyMember.Value}, {relative.Title} {relative.Name} Age {relative.Age}");
                                                //Court Position for a brother or son, or Marriage for a daughter
                                                if ((relative.Age + Game.gameExile) >= 15)
                                                {
                                                    switch (familyMember.Value)
                                                    {
                                                        case ActorRelation.Brother:
                                                        case ActorRelation.Half_Brother:
                                                            //store brothers as a negative ActID to differentiate between Sons (two entries for each brother)
                                                            listOfSonsAndBrothers.Add(familyMember.Key * -1);
                                                            listOfPossibleDesires.Add(PossPromiseType.Court);
                                                            listOfPossibleDesires.Add(PossPromiseType.Court);
                                                            //Game.logStart?.Write($"  Desire -> Court, Brother {relative.Name} ActID {relative.ActID}");
                                                            break;
                                                        case ActorRelation.Son:
                                                            //store Sons as a positive (normal) ActID (two entries for each son)
                                                            listOfSonsAndBrothers.Add(familyMember.Key);
                                                            //Game.logStart?.Write($"  Desire -> Court, Son {relative.Name} ActID {relative.ActID}");
                                                            listOfPossibleDesires.Add(PossPromiseType.Court);
                                                            listOfPossibleDesires.Add(PossPromiseType.Court);
                                                            break;
                                                        case ActorRelation.Daughter:
                                                            Noble daughter = relative as Noble;
                                                            //check that she is available
                                                            if (daughter.Married == 0)
                                                            {
                                                                //store Daughter's ActID (two entries for each daughter)
                                                                listOfDaughters.Add(familyMember.Key);
                                                                //Game.logStart?.Write($"  Desire -> Marriage, Daughter {relative.Name} ActID {relative.ActID}");
                                                                listOfPossibleDesires.Add(PossPromiseType.Marriage);
                                                                listOfPossibleDesires.Add(PossPromiseType.Marriage);
                                                            }
                                                            else { Game.logStart?.Write($"[Alert -> Daughter] {daughter.Title} {daughter.Name}, ActID {daughter.ActID} already Married in {daughter.Married}"); }
                                                            break;
                                                    }
                                                }
                                            }
                                        }
                                        else { Game.SetError(new Error(234, $"Invalid Passive relative (null) {familyMember.Value}, ActID {familyMember.Key} -> Family member not checked")); }
                                    }
                                    //Gold -> lvl 1 gives 3 entries, lvl 2 gives 2, lvl 3 gives 1
                                    if (house.Resources <= 3)
                                    {
                                        for (int k = 0; k < (4 - house.Resources); k++)
                                        {
                                            listOfPossibleDesires.Add(PossPromiseType.Gold);
                                            //Game.logStart?.Write("   Desire -> Gold");
                                        }
                                    }
                                    //Item
                                    if (itemProceed == true)
                                    { listOfPossibleDesires.Add(PossPromiseType.Item); }
                                    //Land -> 4 entries
                                    if (listOfMinorHouses.Count > 0)
                                    {
                                        listOfPossibleDesires.Add(PossPromiseType.Land);
                                        listOfPossibleDesires.Add(PossPromiseType.Land);
                                        listOfPossibleDesires.Add(PossPromiseType.Land);
                                        listOfPossibleDesires.Add(PossPromiseType.Land);
                                    }
                                }
                                else { Game.SetError(new Error(234, $"Invalid House (null) for {actor.Name} ActID {actor.ActID}")); }
                            }
                            break;
                        case ActorType.BannerLord:
                            House tempHouse = GetHouse(actor.RefID);
                            if (tempHouse != null)
                            {
                                //Gold (if poor), Lordship (if treacherous)
                                if (tempHouse.Resources <= 2)
                                { listOfPossibleDesires.Add(PossPromiseType.Gold); }
                                //Lordship -> Not if a member of Royal house
                                if (actor.HouseID != royalHouse.HouseID)
                                {
                                    int treachery = actor.GetSkill(SkillType.Treachery);
                                    switch (treachery)
                                    {
                                        case 4:
                                            listOfPossibleDesires.Add(PossPromiseType.Lordship);
                                            listOfPossibleDesires.Add(PossPromiseType.Lordship);
                                            break;
                                        case 5:
                                            listOfPossibleDesires.Add(PossPromiseType.Lordship);
                                            listOfPossibleDesires.Add(PossPromiseType.Lordship);
                                            listOfPossibleDesires.Add(PossPromiseType.Lordship);
                                            break;
                                    }
                                }
                                else { Game.logStart?.Write($"[Alert -> Royal] Bannerlord House \"{tempHouse.Name}\" is a member of the Royal Household -> Lordship desire not valid"); }
                            }
                            else { Game.SetError(new Error(234, "Invalid tempHouse (null) for BannerLord")); }
                            //Item
                            if (itemProceed == true)
                            { listOfPossibleDesires.Add(PossPromiseType.Item); }
                            //None -> possible for Bannerlords but not Lords (they all want something)
                            listOfPossibleDesires.Add(PossPromiseType.None);
                            break;
                        case ActorType.Lady:
                            Noble lady = actor as Noble;
                            //Family => cares only for son or daughter, there is no 'None' option
                            SortedDictionary<int, ActorRelation> dictFamilyWife = lady.GetFamily();
                            foreach (var familyMember in dictFamilyWife)
                            {
                                Passive relative = GetPassiveActor(familyMember.Key);
                                if (relative != null)
                                {
                                    if (relative.Status != ActorStatus.Gone)
                                    {
                                        //Court Position for a brother or son, or Marriage for a daughter
                                        if ((relative.Age + Game.gameExile) >= 15)
                                        {
                                            switch (familyMember.Value)
                                            {
                                                case ActorRelation.Son:
                                                    //store Sons as a positive (normal) ActID (two entries for each son)
                                                    listOfSonsAndBrothers.Add(familyMember.Key);
                                                    //Game.logStart?.Write($"  Desire -> Court, Son {relative.Name} ActID {relative.ActID}");
                                                    listOfPossibleDesires.Add(PossPromiseType.Court);
                                                    listOfPossibleDesires.Add(PossPromiseType.Court);
                                                    break;
                                                case ActorRelation.Daughter:
                                                    Noble daughter = relative as Noble;
                                                    //check that she is available
                                                    if (daughter.Married == 0)
                                                    {
                                                        //store Daughter's ActID (two entries for each daughter)
                                                        listOfDaughters.Add(familyMember.Key);
                                                        listOfPossibleDesires.Add(PossPromiseType.Marriage);
                                                        listOfPossibleDesires.Add(PossPromiseType.Marriage);
                                                    }
                                                    else { Game.logStart?.Write($"[Alert -> Daughter] {daughter.Title} {daughter.Name}, ActID {daughter.ActID} already Married in {daughter.Married}"); }
                                                    break;
                                            }
                                        }
                                    }
                                }
                                else { Game.SetError(new Error(234, $"Invalid Passive relative (null) {familyMember.Value}, ActID {familyMember.Key} -> Family member not checked")); }
                            }
                            break;
                        case ActorType.Knight:
                            //Title or gold, if treacherous
                            switch (actor.GetSkill(SkillType.Treachery))
                            {
                                case 4:
                                    listOfPossibleDesires.Add(PossPromiseType.Title);
                                    listOfPossibleDesires.Add(PossPromiseType.Title);
                                    listOfPossibleDesires.Add(PossPromiseType.Gold);
                                    break;
                                case 5:
                                    listOfPossibleDesires.Add(PossPromiseType.Title);
                                    listOfPossibleDesires.Add(PossPromiseType.Title);
                                    listOfPossibleDesires.Add(PossPromiseType.Title);
                                    listOfPossibleDesires.Add(PossPromiseType.Gold);
                                    break;
                            }
                            break;
                        case ActorType.Advisor:
                            //all advisors, Royal and Noble -> Desire gold if high treachery, there is no 'None' option
                            int advisorTreachery = actor.GetSkill(SkillType.Treachery);
                            switch (advisorTreachery)
                            {
                                case 4:
                                    listOfPossibleDesires.Add(PossPromiseType.Gold);
                                    break;
                                case 5:
                                    listOfPossibleDesires.Add(PossPromiseType.Gold);
                                    listOfPossibleDesires.Add(PossPromiseType.Gold);
                                    break;
                            }
                            break;
                    }

                    //actor has desires?
                    if (listOfPossibleDesires.Count > 0)
                    {
                        //randomly choose a Desire
                        PossPromiseType desire = listOfPossibleDesires[rnd.Next(listOfPossibleDesires.Count)];
                        //assign to actor
                        actor.Desire = desire;
                        actor.SetDesireKnown(false);
                        int data;
                        //choose specific option for the desire
                        switch (desire)
                        {
                            case PossPromiseType.Land:
                                actor.DesireData = listOfMinorHouses[rnd.Next(listOfMinorHouses.Count)];
                                House tempHouse = GetHouse(actor.DesireData);
                                Actor tempLord = GetAnyActor(tempHouse.LordID);
                                Location loc = Game.network.GetLocation(tempHouse.LocID);
                                actor.DesireText = $"to have {tempLord.Title} {tempLord.Name} of House {tempHouse.Name} at {tempHouse.LocName} (Loc {loc.GetPosX()}:{loc.GetPosY()}) swear allegiance";
                                break;
                            case PossPromiseType.Court:
                                data = listOfSonsAndBrothers[rnd.Next(listOfSonsAndBrothers.Count)];
                                actor.DesireData = Math.Abs(data);
                                Passive brother = GetPassiveActor(actor.DesireData);
                                actor.DesireText = string.Format("a court position for their {0} {1} \"{2}\" ActID {3}", data > 0 ? "son" : "brother", brother.Name, brother.Handle, brother.ActID);
                                break;
                            case PossPromiseType.Gold:
                                actor.DesireText = "more Gold";
                                actor.DesireData = actor.ActID;
                                break;
                            case PossPromiseType.Marriage:
                                actor.DesireData = listOfDaughters[rnd.Next(listOfDaughters.Count)];
                                Passive daughter = GetPassiveActor(actor.DesireData);
                                actor.DesireText = $"the marriage of their daughter, {daughter.Name} \"{daughter.Handle}\" ActID {daughter.ActID}, to the one true King";
                                break;
                            case PossPromiseType.Item:
                                actor.DesireData = possID;
                                reason = itemReasons[rnd.Next(itemReasons.Length)];
                                actor.DesireText = $"the {item.Description} because it {reason}";
                                break;
                            case PossPromiseType.Title:
                                actor.DesireText = "wants to become a BannerLord with their own castle";
                                actor.DesireData = actor.ActID;
                                break;
                            case PossPromiseType.Lordship:
                                actor.DesireData = actor.HouseID;
                                actor.DesireText = $"the Lordship of House {GetMajorHouseName(actor.HouseID)}";
                                break;
                            case PossPromiseType.None:
                                actor.DesireText = "nothing";
                                actor.DesireData = actor.ActID;
                                break;
                            default:
                                Game.SetError(new Error(234, $"Invalid PossPromiseType for desire \"{desire}\" -> {actor.Title} {actor.Name}, ActID {actor.ActID} desire revoked"));
                                actor.Desire = PossPromiseType.None;
                                break;
                        }
                        Game.logStart?.Write($"{actor.Title} {actor.Name} ActID {actor.ActID} wants {actor.DesireText} -> Desire: {actor.Desire}, DesireData: {actor.DesireData}");
                    }
                }
            }
        }



        /// <summary>
        /// populates Possession dictionary with Secrets
        /// </summary>
        private void InitialiseSecrets()
        {
            List<Secret> tempList = Game.history.GetSecrets();
            if (tempList != null)
            {
                foreach (Secret secret in tempList)
                {
                    try
                    { dictPossessions.Add(secret.PossID, secret); }
                    catch (ArgumentNullException)
                    { Game.SetError(new Error(198, "Invalid Secret (null) -> Not added to Dictionary")); }
                    catch (ArgumentException)
                    { Game.SetError(new Error(198, string.Format("Invalid secret.PossID \"{0}\" (duplicate) -> Not added to Dictionary", secret.PossID))); }
                }
            }
            else { Game.SetError(new Error(198, "Invalid dictionary input -> history.GetSecrets (null)")); }
        }

        /// <summary>
        /// populates Possession dictionary with Items
        /// </summary>
        private void InitialiseItems()
        {
            Game.logStart?.Write("--- InitialiseItems (World.cs)");
            List<Item> tempList = Game.file.GetItems("Items.txt");
            if (tempList != null)
            {
                foreach (Item item in tempList)
                {
                    try
                    { dictPossessions.Add(item.PossID, item); }
                    catch (ArgumentNullException)
                    { Game.SetError(new Error(199, "Invalid Item (null) -> Not added to Dictionary")); }
                    catch (ArgumentException)
                    { Game.SetError(new Error(199, string.Format("Invalid item.PossID \"{0}\" (duplicate) -> Not added to Dictionary", item.PossID))); }
                }
            }
            else { Game.SetError(new Error(199, "Invalid dictionary input -> history.GetSecrets (null)")); }
        }


      

        /// <summary>
        /// Quickly access a house name using houseID
        /// </summary>
        /// <param name="houseID"></param>
        /// <returns></returns>
        public string GetMajorHouseName(int houseID)
        {
            string houseName = "";
            MajorHouse house = new MajorHouse();
            if (dictMajorHouses.TryGetValue(houseID, out house))
            { houseName = house.Name; }
            return houseName;
        }

        /// <summary>
        /// Returns name of house (major, minor or Inn) using Ref ID. 
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        public string GetHouseName(int refID)
        {
            string houseName = "";
            House house = new House();
            if (dictAllHouses.TryGetValue(refID, out house))
            { houseName = house.Name; }
            else if (refID == 9999) { houseName = "KingsKeep"; }
            return houseName;
        }

        internal Dictionary<int, MajorHouse> GetAllMajorHouses()
        { return dictMajorHouses; }

        internal Dictionary<int, House> GetAllHouses()
        { return dictAllHouses; }

        internal Dictionary<int, Passive> GetRoyalCourt()
        { return dictRoyalCourt; }

        /// <summary>
        /// Returns Great house if found, otherwise null, keyed of
        /// </summary>
        /// <param name="houseID"></param>
        /// <returns></returns>
        internal MajorHouse GetMajorHouse(int houseID)
        {
            MajorHouse house = new MajorHouse();
            if (dictMajorHouses.TryGetValue(houseID, out house))
            { return house; }
            return null;
        }

        /// <summary>
        /// returns dictMajorHouses (key is houseID)
        /// </summary>
        /// <returns></returns>
        internal Dictionary<int, MajorHouse> GetMajorHouses()
        { return dictMajorHouses; }

        /// <summary>
        /// Returns house (any type) if found, otherwise null, keyed off refID). Note: Capital returns null
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal House GetHouse(int refID)
        {
            House house = new House();
            if (dictAllHouses.TryGetValue(refID, out house))
            { return house; }
            return null;
        }

        /// <summary>
        /// Return capital, null if not found
        /// </summary>
        /// <returns></returns>
        internal CapitalHouse GetCapital()
        {
            House house = new House();
            if (dictAllHouses.TryGetValue(9999, out house))
            {
                CapitalHouse capital = house as CapitalHouse;
                return capital;
            }
            return null;
        }

        /// <summary>
        /// Query to return list of strings containing selected actor's personal history (includes those of Player)
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal List<string> GetActorHistoricalRecords(int actorID)
        {
            List<string> actorRecords = new List<string>();
            if (actorID > 0)
            {
                //query
                IEnumerable<string> actorHistory =
                    from actor in dictHistoricalRecords
                    from actID in actor.Value.listOfActors
                    where actID == actorID
                    orderby actor.Value.Year
                    select Convert.ToString(actor.Value.Year + " " + actor.Value.Text);
                //place filtered data into list
                actorRecords = actorHistory.ToList();
            }
            else { Game.SetError(new Error(144, "Invalid actorID (0 or less)")); }
            return actorRecords;
        }

        /// <summary>
        /// Query to return list of strings containing selected actor's current game-start onwards records (excludes those of Player)
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal List<string> GetActorCurrentRecords(int actorID)
        {
            List<string> actorRecords = new List<string>();
            if (actorID > 1)
            {
                //query
                IEnumerable<string> actorCurrent =
                    from actor in dictCurrentRecords
                    from actID in actor.Value.listOfActors
                    where actID == actorID
                    orderby actor.Value.Year
                    select Convert.ToString("Day " + actor.Value.Day + ", " + actor.Value.Year + " " + actor.Value.Text);
                //place filtered data into list
                actorRecords = actorCurrent.ToList();
            }
            else { Game.SetError(new Error(142, "Invalid actorID (1 or less)")); }
            return actorRecords;
        }

        /// <summary>
        /// Query to return list of strings containing Player's current game-start onwards records
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal List<string> GetPlayerCurrentRecords(int actorID)
        {
            List<string> actorRecords = new List<string>();
            if (actorID == 1)
            {
                //query
                IEnumerable<string> actorPlayer =
                    from actor in dictPlayerRecords
                    from actID in actor.Value.listOfActors
                    where actID == actorID
                    orderby actor.Value.Year
                    select Convert.ToString("Day " + actor.Value.Day + ", " + actor.Value.Year + " " + actor.Value.Text);
                //place filtered data into list
                actorRecords = actorPlayer.ToList();
            }
            else { Game.SetError(new Error(142, "Invalid actorID (Not that of the Players)")); }
            return actorRecords;
        }

        /// <summary>
        /// Query to return list of strings containing selected house's history
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        private List<string> GetHistoricalHouseRecords(int refID)
        {
            List<string> houseRecords = new List<string>();
            //query
            IEnumerable<string> houseHistory =
                from house in dictHistoricalRecords
                from _refID in house.Value.listOfHouses
                where _refID == refID
                orderby house.Value.Year
                select Convert.ToString(house.Value.Year + " " + house.Value.Text);
            //place filtered data into list
            houseRecords = houseHistory.ToList();
            return houseRecords;
        }

        /// <summary>
        /// returns RefID, '0' if not found
        /// </summary>
        /// <param name="houseID"></param>
        /// <returns></returns>
        public int GetGreatHouseRefID(int houseID)
        {
            MajorHouse house = new MajorHouse();
            if (dictMajorHouses.TryGetValue(houseID, out house))
            { return house.RefID; }
            else { Game.SetError(new Error(264, $"Invalid houseID \"{houseID}\" -> Not found in dictionary")); }
            return 0;
        }


        /// <summary>
        /// returns geoCluster, null if not found
        /// </summary>
        /// <param name="geoID"></param>
        /// <returns></returns>
        internal GeoCluster GetGeoCluster(int geoID)
        {
            GeoCluster cluster = new GeoCluster();
            if (dictGeoClusters.TryGetValue(geoID, out cluster))
            { return cluster; }
            else { Game.SetError(new Error(263, $"Invalid geoID \"{geoID}\" -> Not found in dictionary")); }
            return null;
        }

        /// <summary>
        /// return Skill, returns null if not found
        /// </summary>
        /// <param name="skillID"></param>
        /// <returns></returns>
        internal Skill GetSkill(int skillID)
        {
            Skill trait = new Skill();
            if (dictTraits.TryGetValue(skillID, out trait))
            { return trait; }
            else { Game.SetError(new Error(262, $"Invalid traitID \"{skillID}\" -> Not found in dictionary")); }
            return null;
        }

        /// <summary>
        /// get Possession, returns null if not found
        /// </summary>
        /// <param name="possID"></param>
        /// <returns></returns>
        internal Possession GetPossession(int possID)
        {
            if (possID > 0)
            {
                Possession possession = new Possession();
                if (dictPossessions.TryGetValue(possID, out possession))
                { return possession; }
            }
            else { Game.SetError(new Error(205, "Invalid PossID (zero, or less)")); }
            return null;
        }

        /// <summary>
        /// get Rumour, returns null if not found
        /// </summary>
        /// <param name="rumourID"></param>
        /// <returns></returns>
        internal Rumour GetRumour(int rumourID)
        {
            if (rumourID > 0)
            {
                Rumour rumour = new Rumour();
                //try Timed Rumour dict first (it's the smallest)
                if (dictRumoursTimed.TryGetValue(rumourID, out rumour))
                { return rumour; }
                if (dictRumoursNormal.TryGetValue(rumourID, out rumour))
                { return rumour; }
            }
            else { Game.SetError(new Error(265, $"Invalid rumourID \"{rumourID}\" -> Not found in dictRumours Normal or Timed")); }
            return null;
        }

        /// <summary>
        /// get a Known Rumour, returns null if not found
        /// </summary>
        /// <param name="rumourID"></param>
        /// <returns></returns>
        internal Rumour GetRumourKnown(int rumourID)
        {
            if (rumourID > 0)
            {
                Rumour rumour = new Rumour();
                if (dictRumoursKnown.TryGetValue(rumourID, out rumour))
                { return rumour; }
            }
            else { Game.SetError(new Error(274, $"Invalid rumourID \"{rumourID}\" -> Not found in dictRumoursKnown")); }
            return null;
        }

        /// <summary>
        /// returns True if rumour present in dict of Known Rumours
        /// </summary>
        /// <param name="rumourID"></param>
        /// <returns></returns>
        internal bool CheckRumourKnown(int rumourID)
        { return dictRumoursKnown.ContainsKey(rumourID);  }


        /// <summary>
        /// returns an Item from the Possessions Dict, null if not found
        /// </summary>
        /// <param name="possID"></param>
        /// <returns></returns>
        internal Item GetItem(int possID)
        {
            if (possID > 0)
            {
                Possession possession = new Possession();
                if (dictPossessions.TryGetValue(possID, out possession))
                {
                    if (possession is Item)
                    {
                        Item item = possession as Item;
                        return item;
                    }
                    else { Game.SetError(new Error(204, string.Format("Invalid possession -> should be an Item but isn't (possID {0})", possID))); }
                }
            }
            else { Game.SetError(new Error(204, "Invalid PossID (zero, or less)")); }
            return null;
        }

        /// <summary>
        /// Pre-Game start records for everybody including Player
        /// </summary>
        /// <param name="record"></param>
        internal void SetHistoricalRecord(Record record)
        {
            try
            { dictHistoricalRecords.Add(record.TrackerID, record); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(139, "Invalid record (null)")); }
            catch (ArgumentException)
            { Game.SetError(new Error(139, string.Format("Invalid Record TrackerID \"{0}\" (duplicate)", record.TrackerID))); }
        }

        /// <summary>
        /// Game start onwards records for everybody except the Player
        /// </summary>
        /// <param name="record"></param>
        internal void SetCurrentRecord(Record record)
        {
            try
            { dictCurrentRecords.Add(record.TrackerID, record); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(140, "Invalid record (null)")); }
            catch (ArgumentException)
            { Game.SetError(new Error(140, string.Format("Invalid Record TrackerID \"{0}\" (duplicate)", record.TrackerID))); }
        }

        /// <summary>
        /// Game start onwards records for the Player
        /// </summary>
        /// <param name="record"></param>
        internal void SetPlayerRecord(Record record)
        {
            try
            { dictPlayerRecords.Add(record.TrackerID, record); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(141, "Invalid record (null)")); }
            catch (ArgumentException)
            { Game.SetError(new Error(141, string.Format("Invalid Record TrackerID \"{0}\" (duplicate)", record.TrackerID))); }
        }

        /// <summary>
        /// handle a new message appropriately
        /// </summary>
        /// <param name="message"></param>
        internal void SetMessage(Message message)
        {
            if (message != null)
            {
                RLColor color = RLColor.White;
                //certain message types are color coded
                switch (message.Type)
                {
                    case MessageType.Activation:
                        color = Color._active;
                        break;
                    case MessageType.Error:
                        color = RLColor.LightRed;
                        break;
                    case MessageType.God:
                        color = Color._godMode;
                        break;
                }
                //queue for the most recent messages to display at bottom right console window
                Snippet snippet = new Snippet(string.Format("Day {0}, {1}, {2}", message.Day, message.Year, message.Text), color, RLColor.Black);
                messageQueue.Enqueue(snippet);
                //max 8 entries in queue at any one time
                if (messageQueue.Count > 8)
                { messageQueue.Dequeue(); }
                //add to dictionary
                dictMessages.Add(message.TrackerID, message);
                //debug -> doesn't work 'cause called by both logStart and logTurn
                //Game.logTurn.Write(string.Format("Message -> [{0}] Day {1}, {2}, {3}", message.Type, message.Day, message.Year, message.Text));
            }
        }


        /// <summary>
        /// Store a new actor (child,regent brother, etc.) in relevant dictionaries
        /// </summary>
        /// <param name="actor"></param>
        internal void SetPassiveActor(Passive actor)
        {
            try
            {
                dictPassiveActors.Add(actor.ActID, actor);
                dictAllActors.Add(actor.ActID, actor);
            }
            catch (ArgumentNullException)
            { Game.SetError(new Error(211, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(211, "Invalid actor.ActID (duplicate key exists) -> Record not saved")); }
        }

        /// <summary>
        /// store a new actor (player and follower)
        /// </summary>
        /// <param name="actor"></param>
        internal void SetActiveActor(Active actor)
        {
            try
            {
                dictActiveActors.Add(actor.ActID, actor);
                dictAllActors.Add(actor.ActID, actor);
            }
            catch (ArgumentNullException)
            { Game.SetError(new Error(150, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(150, "Invalid actor.ActID (duplicate key exists) -> Record not saved")); }
        }

        /// <summary>
        /// returns number of followers 
        /// </summary>
        /// <returns></returns>
        internal int GetNumFollowers()
        {
            int numFollowers = 0;
            foreach (var actor in dictActiveActors)
            {
                if (actor.Value is Follower && actor.Value.Status != ActorStatus.Gone)
                { numFollowers++; }
            }
            return numFollowers;
        }

        /// <summary>
        /// store a new special (NPC) actor
        /// </summary>
        /// <param name="actor"></param>
        internal void SetSpecialActor(Special actor)
        {
            try
            {
                dictPassiveActors.Add(actor.ActID, actor);
                dictAllActors.Add(actor.ActID, actor);
                dictSpecialActors.Add(actor.SpecialID, actor);
            }
            catch (ArgumentNullException)
            { Game.SetError(new Error(150, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(150, "Invalid ActID or SpecialID (duplicate key exists) -> Record not saved")); }
        }


        /// <summary>
        /// store a Royal court member in relevant dict
        /// </summary>
        /// <param name="actor"></param>
        internal void SetRoyalCourt(Passive actor)
        {
            try
            { dictRoyalCourt.Add(actor.ActID, actor); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(212, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(212, "Invalid actor.ActID (duplicate key exists) -> Record not saved")); }
        }

        /// <summary>
        /// Returns a filtered set of Historical Records
        /// </summary>
        /// <param name="keyPress"></param>
        /// <returns></returns>
        internal List<Snippet> GetHistoricalRecordSet(RLKeyPress keyPress)
        {
            List<string> tempList = new List<string>();
            List<Snippet> snippetList = new List<Snippet>();
            IEnumerable<string> recordList;
            switch (keyPress.Key)
            {
                case RLKey.A:
                    //All records
                    recordList =
                        from record in dictHistoricalRecords
                        orderby record.Value.Year, record.Value.TrackerID
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.C:
                    //CUSTOM (debugging purposes)
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfHistoricalActorIncidents
                        where eventType == HistActorEvent.Lordship
                        //where record.Value.Actual == false
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.D:
                    //deaths
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfHistoricalActorIncidents
                        where eventType == HistActorEvent.Died
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.G:
                    //Marriages
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfHistoricalActorIncidents
                        where eventType == HistActorEvent.Married
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.K:
                    //Kingdom events
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfKingdomIncidents
                        where eventType == HistKingdomEvent.Battle || eventType == HistKingdomEvent.Siege
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
            }
            foreach (string text in tempList)
            { snippetList.Add(new Snippet(text)); }
            return snippetList;
        }

        /// <summary>
        /// Returns a filtered set of Lore records
        /// </summary>
        /// <param name="keyPress"></param>
        /// <returns></returns>
        internal List<Snippet> GetLoreSet(RLKeyPress keyPress)
        {
            List<string> tempList = new List<string>();
            List<Snippet> snippetList = new List<Snippet>();
            switch (keyPress.Key)
            {
                case RLKey.U:
                    tempList.AddRange(Game.lore.GetUprising());
                    break;
                case RLKey.F:
                    tempList.AddRange(Game.lore.GetRoyalFamilyFate());
                    break;
            }
            foreach (string text in tempList)
            { snippetList.Add(new Snippet(text)); }
            return snippetList;
        }

        /*
        /// <summary>
        /// Generate a list of All Secrets
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowSecretsRL()
        {
            List <string> tempList = GetPossessionsSummary(PossessionType.Secret);
            //snippet list
            List<Snippet> listData = new List<Snippet>();
            foreach(string data in tempList)
            { listData.Add(new Snippet(data)); }
            return listData;
        }*/

        /// <summary>
        /// Generate a list of a subtype of Possessions for display
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowPossessionsRL(PossessionType type)
        {
            //snippet list
            List<Snippet> listData = new List<Snippet>();
            List<string> tempList = GetPossessionsSummary(type);
            if (tempList.Count > 0)
            {
                foreach (string data in tempList)
                { listData.Add(new Snippet(data)); }
            }
            return listData;
        }


        /// <summary>
        /// Generate a list of all Bloodhound Actor info grouped by turns
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowSpyAllRL(bool showActive, bool showEnemy)
        {
            int turn;
            string description;
            List<Snippet> listData = new List<Snippet>();
            if (showActive == true)
            {
                if (showEnemy == true)
                { listData.Add(new Snippet("--- Spy ALL", RLColor.Yellow, RLColor.Black)); }
                else { listData.Add(new Snippet("--- Spy ACTIVE Actors", RLColor.Yellow, RLColor.Black)); }
            }
            else { listData.Add(new Snippet("--- Spy ENEMY Actors", RLColor.Yellow, RLColor.Black)); }
            List<ActorSpy> listTempActive = new List<ActorSpy>();
            List<ActorSpy> listTempEnemy = new List<ActorSpy>();
            foreach (var bloodhound in dictBloodHound)
            {
                turn = bloodhound.Key;
                //clear lists
                listTempActive.Clear();
                listTempEnemy.Clear();
                //get a new turn's worth of data
                listTempActive.AddRange(bloodhound.Value.GetActiveActors());
                listTempEnemy.AddRange(bloodhound.Value.GetEnemyActors());
                //snippets -> active actors
                listData.Add(new Snippet(string.Format("Day {0}", turn), RLColor.LightRed, RLColor.Black));
                if (showActive == true)
                {
                    foreach (ActorSpy spy in listTempActive)
                    {
                        description = string.Format("ID {0,-5} {1,-26} Pos {2,2}:{3,-5} Status -> {4,-12} Known -> {5,-8} Goal -> {6, -8} Mode -> {7}", spy.ActID, GetActorDetails(spy.ActID),
                            spy.Pos.PosX, spy.Pos.PosY, spy.Status, spy.Known, "n.a", "n.a");
                        listData.Add(new Snippet(description));
                    }
                }
                //snippets -> enemy actors
                if (showEnemy == true)
                {
                    foreach (ActorSpy spy in listTempEnemy)
                    {
                        description = string.Format("ID {0,-5} {1,-26} Pos {2,2}:{3,-5} Status -> {4,-12} Known -> {5,-8} Goal -> {6, -8} Mode -> {7}", spy.ActID, GetActorDetails(spy.ActID), spy.Pos.PosX,
                            spy.Pos.PosY, spy.Status, spy.Known, spy.Goal, spy.HuntMode == true ? "Hunt" : "normal");
                        listData.Add(new Snippet(description));
                    }
                }
            }
            return listData;
        }

        /// <summary>
        /// Show bloodhound data, turn by turn, for a specific active, or enemy, actor (input ActID)
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowSpyRL(int actID)
        {
            string description;
            List<Snippet> listData = new List<Snippet>();
            List<ActorSpy> tempList = new List<ActorSpy>();
            if (actID > 0)
            {
                if (actID < 10)
                {
                    //Active
                    IEnumerable<ActorSpy> actorData =
                        from bloodhound in dictBloodHound
                        from spy in bloodhound.Value.GetActiveActors()
                        where spy.ActID == actID
                        select spy;
                    tempList = actorData.ToList();
                }
                else
                {
                    //Enemy
                    IEnumerable<ActorSpy> actorData =
                        from bloodhound in dictBloodHound
                        from spy in bloodhound.Value.GetEnemyActors()
                        where spy.ActID == actID
                        select spy;
                    tempList = actorData.ToList();
                }
                //any records found?
                if (tempList.Count > 0)
                {
                    RLColor foreColor;
                    listData.Add(new Snippet(string.Format("--- Spy ACTOR ID {0}", actID), RLColor.Yellow, RLColor.Black));
                    //set up formatted Snippet list
                    foreach (ActorSpy spy in tempList)
                    {
                        if (spy.Known == true) { foreColor = Color._badTrait; }
                        else { foreColor = RLColor.White; }
                        description = string.Format("Day {0,-5} {1,-26} Pos {2,2}:{3,-5} Status -> {4,-12} Known -> {5,-8} Goal -> {6, -8} Mode -> {7}", spy.Turn, GetActorDetails(spy.ActID),
                            spy.Pos.PosX, spy.Pos.PosY, spy.Status, spy.Known, spy.Goal, spy.HuntMode == true ? "Hunt" : "normal");
                        listData.Add(new Snippet(description, foreColor, RLColor.Black));
                    }
                }
                else
                { listData.Add(new Snippet(string.Format("No records found for ActID {0}", actID))); }
            }
            else { listData.Add(new Snippet("Warning! Invalid ActorID Input", RLColor.LightRed, RLColor.Black)); }
            return listData;
        }

        /// <summary>
        /// Generate a list of All Messages
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowMessagesRL()
        {
            List<Snippet> tempList = new List<Snippet>();
            RLColor color = RLColor.White;
            foreach (var message in dictMessages)
            {
                if (message.Value.Type == MessageType.Activation) { color = Color._active; }
                else { color = RLColor.White; }
                tempList.Add(new Snippet(string.Format("Day {0}, {1}, {2}", message.Value.Day, message.Value.Year, message.Value.Text), color, RLColor.Black));
            }
            return tempList;
        }

        /// <summary>
        /// return 8 most recent messages to display at bottom right console window
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowRecentMessagesRL()
        {
            List<Snippet> tempList = new List<Snippet>();
            tempList.Add(new Snippet("--- Message Log Recent", RLColor.Yellow, RLColor.Black));
            tempList.AddRange(messageQueue.ToList());
            return tempList;
        }


        public List<Snippet> ShowFoodRL(FoodInfo mode)
        {
            List<Snippet> tempList = new List<Snippet>();
            if (mode != FoodInfo.None)
            {
                List<String> listOfFoodInfo = GetFoodInfo(mode);
                tempList.Add(new Snippet($"--- {mode} Food Info", RLColor.Yellow, RLColor.Black));
                if (listOfFoodInfo.Count > 0)
                {
                    foreach (var text in listOfFoodInfo)
                    { tempList.Add(new Snippet(text)); }
                }
                else { tempList.Add(new Snippet($"No records have been returned for FoodInfo mode \"{mode}\"", RLColor.LightRed, RLColor.Black)); }
            }
            else { tempList.Add(new Snippet("ERROR -> Invalid FoodInfo mode provided", RLColor.LightRed, RLColor.Black)); }
            return tempList;
        }

        /// <summary>
        /// gets the correct advisor type and returns as a string for display purposes
        /// </summary>
        /// <param name="advisor"></param>
        /// <returns></returns>
        internal string GetAdvisorType(Advisor advisor)
        {
            string type = "unknown";
            if (advisor.advisorRoyal > 0)
            { type = Convert.ToString(advisor.advisorRoyal); }
            else if (advisor.advisorNoble > 0)
            { type = Convert.ToString(advisor.advisorNoble); }
            return type;
        }


        /// <summary>
        /// debug: highlights duplicate names in imported files
        /// </summary>
        /// <returns></returns>
        internal List<Snippet> ShowDuplicatesRL()
        {
            //get duplicates
            List<string> listOfStrings = new List<string>(Game.history.GetDuplicatesNames());
            List<Snippet> listOfDuplicates = new List<Snippet>();
            //convert to snippets
            foreach (string name in listOfStrings)
            { listOfDuplicates.Add(new Snippet(name)); }
            return listOfDuplicates;
        }

        /// <summary>
        /// if specified actor present at location then True
        /// </summary>
        /// <param name="actorID"></param>
        /// <param name="locID"></param>
        /// <returns></returns>
        public bool CheckActorPresent(int actorID, int locID)
        {
            Location loc = Game.network.GetLocation(locID);
            if (loc != null) { return loc.CheckActorStatus(actorID); }
            else { Game.SetError(new Error(189, "Invalid Loc (null)")); }
            return false;
        }

        /// <summary>
        /// permanently remove an actor from relevant dictionaries
        /// </summary>
        /// <param name="actorID"></param>
        public void RemovePassiveActor(int actorID)
        {
            if (!dictAllActors.Remove(actorID))
            { Game.SetError(new Error(37, "ActorID not found")); }
            if (!dictPassiveActors.Remove(actorID))
            { Game.SetError(new Error(37, "ActorID not found")); }
        }

        /// <summary>
        /// add a new actor to relevant dictionaries
        /// </summary>
        /// <param name="actor"></param>
        public void AddPassiveActor(Passive actor)
        {
            if (actor != null)
            {
                try
                {
                    dictAllActors.Add(actor.ActID, actor);
                    dictPassiveActors.Add(actor.ActID, actor);
                }
                catch (ArgumentException)
                { Game.SetError(new Error(60, string.Format("Invalid Passive ActorID (duplicate ID) for \"{0}\"", actor.Name))); }
            }
            else { Game.SetError(new Error(38, "null Actor input")); }
        }


        public void AddEnemyActor(Enemy actor)
        {
            if (actor != null)
            {
                try
                {
                    dictAllActors.Add(actor.ActID, actor);
                    dictEnemyActors.Add(actor.ActID, actor);
                }
                catch (ArgumentException)
                { Game.SetError(new Error(151, string.Format("Invalid Enemy ActorID (duplicate ID) for \"{0}\"", actor.Name))); }
            }
            else { Game.SetError(new Error(151, "Invalid Enemy Actor input (null)")); }
        }

        /// <summary>
        /// returns all availabe living Knights
        /// </summary>
        /// <returns></returns>
        public List<int> GetKnights()
        {
            List<int> listOfKnights = new List<int>();
            IEnumerable<int> knights =
                from person in dictPassiveActors
                where person.Value.Type == ActorType.Knight && person.Value.Status != ActorStatus.Gone
                orderby person.Value.ActID
                select person.Value.ActID;
            listOfKnights = knights.ToList();
            return listOfKnights;
        }

        /// <summary>
        /// handles all start (day 0) Game stuff -> NOTE: logTurn
        /// </summary>
        public void ProcessStartGame()
        {
            Game.logTurn?.Write("--- ProcessStartGame (World.cs)");
            Message message = new Message($"Game world created with seed {seed}", MessageType.System);
            SetMessage(message);
            Game.history.AgePassiveCharacters(dictPassiveActors);
            InitialiseGameVars();
            InitialiseRoyalAccounts();
            Game.director.InitialiseStartRumours(); //AFTER initialiseRoyalAccount and just about everything else
            CalculateCrows();
            //DEBUG -> populate dictionary with sample data
            for (int i = 3; i > 0; i--)
            { Game.director.AddVisitedLoc(Game.network.GetRandomLocation(), i * -1); }

            InitialiseFinalPlayer();
            Game.display.ShowGeneratorStatsRL();
        }

        /// <summary>
        /// handles all pre-turn stuff, part 1 (Notification messages)
        /// </summary>
        public bool ProcessStartTurnEarly()
        {
            bool notificationStatus = false; //is a notification msg needed?
            Game.infoChannel.ClearConsole(ConsoleDisplay.Event);
            Game.logTurn?.Write("--- ProcessStartTurn (World.cs)");
            Game.logTurn?.Write($"Day {Game.gameTurn}, Turn {Game.gameTurn}, Harvest in {Game.HarvestTimer} days, Winter in {Game.WinterTimer} days, SeasonTimer {Game.SeasonTimer}");
            Game.logTurn?.Write($"{GetPlayerStatusReport()}");
            UpdateRumours();
            UpdateActorMoveStatus(MoveActors());
            if (UpdatePlayerStatus() == true) { notificationStatus = true; }
            CalculateCrows();
            if (UpdateWorldStatus() == true) { notificationStatus = true; }
            CheckStationaryActiveActors();
            
            //Enemies
            UpdateAIController();
            SetEnemyActivity();

            //Finances
            CheckRoyalAccounts();
            
            return notificationStatus;
        }

        /// <summary>
        /// handles pre-turn stuff, part 2 (events)
        /// </summary>
        public void ProcessStartTurnLate()
        {
            //Game.infoChannel.ClearConsole(ConsoleDisplay.Event);
            //Create events
            Game.director.CheckPlayerEvents();
            Game.director.CheckFollowerEvents(dictActiveActors);
            //Player events first
            if (Game.director.ResolvePlayerEvents())
            { Game._specialMode = SpecialMode.PlayerEvent; }
            else
            {
                //Follwer events last
                if (Game.director.ResolveFollowerEvents())
                { Game._specialMode = SpecialMode.FollowerEvent; }
            }
            //update position of all key characters on map layers
            UpdateFollowerPositions();
            UpdateEnemiesPositions();
            UpdateActiveActors();
            UpdateBloodHound(); //needs to be right at the end of ProcessStartTurn
        }

        /// <summary>
        /// handles all end of turn stuff
        /// </summary>
        public void ProcessEndTurn()
        {
            Game.logTurn?.Write("--- ProcessEndTurn (World.cs)");
            Game.logTurn?.Write($"Day {Game.gameTurn + 1}, Turn {Game.gameTurn}");
            Game.map.UpdateMap();
            Game.director.HousekeepEvents();
            Game.director.CheckEventTimers();
            Game.director.InitialiseDynamicRumours();
            HousekeepActors();
            HousekeepHouses();
            HousekeepRumours();
            HousekeepGame();
            
        }

        /// <summary>
        /// handles all relevant status changes for the Player
        /// </summary>
        private bool UpdatePlayerStatus()
        {
            bool updateStatus = false; //does a message need to be shown?
            string description;
            Game.logTurn?.Write("--- UpdatePlayerStatus (World.cs)");
            Player player = GetPlayer();
            if (player != null)
            {
                //Sea Voyage Status
                if (player.Status == ActorStatus.AtSea)
                {
                    player.VoyageTimer--;
                    if (player.VoyageTimer == 0)
                    {
                        //arrived at Location
                        string locName = GetLocationName(player.LocID);
                        description = string.Format("{0} {1} has arrived at {2} onboard the S.S \"{3}\"", player.Title, player.Name, locName, player.ShipName);
                        SetPlayerRecord(new Record(description, 1, player.LocID, CurrentActorEvent.Travel));
                        SetMessage(new Message(description, MessageType.Move));
                        //notification message
                        List<Snippet> msgList = new List<Snippet>();
                        msgList.Add(new Snippet($"The S.S \"{player.ShipName}\" has docked today with {player.Title} {player.Name} onboard", RLColor.Red, Color._background1));
                        msgList.Add(new Snippet(""));
                        msgList.Add(new Snippet("- o -", RLColor.Gray, Color._background1));
                        msgList.Add(new Snippet(""));
                        SetNotification(msgList);
                        updateStatus = true;
                        //reset actor instances
                        player.Status = ActorStatus.AtLocation;
                        player.ShipName = "Unknown";
                        player.SeaName = "Unknown";
                        player.VoyageSafe = true;
                    }
                    else
                    {
                        description = string.Format("{0} {1} is at Sea onboard the S.S \"{2}\", bound for {3}, arriving in {4} days", player.Title, player.Name, player.ShipName,
                            GetLocationName(player.LocID), player.VoyageTimer);
                        SetMessage(new Message(description, MessageType.Move));
                    }
                    Game.logTurn?.Write(description);
                }
                //In a safe House
                if ( player.Conceal == ActorConceal.SafeHouse &&player.Status == ActorStatus.AtLocation )
                {
                    House house = GetHouse(ConvertLocToRef(player.LocID));
                    if (house != null)
                    {
                        description = string.Format("{0} {1} is laying low at a safe house at {2} ({3} stars)", player.Title, player.Name, house.LocName, house.SafeHouse);
                        SetMessage(new Message(description, MessageType.Move));
                        Game.logTurn?.Write(description);
                    }
                    else { Game.SetError(new Error(219, "Invalid house (null) -> SafeHouse message not created")); }
                }
                //Death Timer active
                if (player.DeathTimer < 999)
                {
                    player.DeathTimer--;
                    Game.logTurn?.Write($"{player.Title} {player.Name} Death Timer reduced by 1 to {player.DeathTimer}");
                    if (player.DeathTimer <= 0)
                    {
                        //end of game
                        Game.SetEndGame("Death Timer expired");
                    }
                }
            }
            else { Game.SetError(new Error(219, "Invalid Player (null)")); }
            return updateStatus;
        }

        /// <summary>
        /// checks rumours in dict Timed & Inactive, updates timers and moves & deletes rumours where appropriate
        /// </summary>
        private void UpdateRumours()
        {
            Game.logTurn?.Write("--- UpdateRumours (World.cs)");
            Game.logTurn?.Write($"dictRumoursTimed (Start) -> {dictRumoursTimed.Count} records");
            bool rumourRemoved = false;
            int numRecordsRemoved = 0;
            //Timed Rumours
            if (dictRumoursTimed.Count > 0)
            {
                int counter = 0;
                foreach (var rumour in dictRumoursTimed)
                {
                    //countdown expire timers
                    rumour.Value.TimerExpire--;
                    if (rumour.Value.TimerExpire <= 0)
                    {
                        //Rumour Expired -> remove from list
                        if (Game.director.RemoveRumourFromList(rumour.Value) == true)
                        { rumourRemoved = true; }
                    }
                    else { counter++; }
                }
                if (dictRumoursTimed.Count > 0) { Game.logTurn?.Write($"{counter} rumours -> TimerExpire decremented"); }
                if (rumourRemoved == true)
                {
                    //loop dict backwards and remove any rumours with TimerExpire <= 0
                    for (int i = dictRumoursTimed.Count - 1 ; i >= 0; i--)
                    {
                        Rumour rumour = dictRumoursTimed.ElementAt(i).Value;
                        if (rumour.TimerExpire <= 0)
                        {
                            if (dictRumoursTimed.Remove(rumour.RumourID) == true)
                            { numRecordsRemoved++; }
                            else { Game.SetError(new Error(280, $"RID {rumour.RumourID}, \"{rumour.Text}\" -> FAILED removal from dict")); }
                        }
                    }
                    Game.logTurn?.Write($"{numRecordsRemoved} records have expired and been removed");
                    Game.logTurn?.Write($"dictRumoursTimed (End) -> {dictRumoursTimed.Count} records");
                }
            }
            else { Game.logTurn?.Write("[Notification] No Timed rumours present -> dictRumoursTimed is MT"); }
        }

        /// <summary>
        /// Deletes old timed rumours from dictRumoursKnown
        /// </summary>
        private void HousekeepRumours()
        {
            Game.logTurn?.Write("--- HousekeepRumours (World.cs)");
            int timeLimit = Game.constant.GetValue(Global.ENEMY_RUMOUR_TIME) * 2;
            List<int> listOfKeysToDelete = new List<int>();
            int numRecords = dictRumoursKnown.Count;
            if (numRecords> 0)
            {
                Game.logTurn?.Write($"dictRumoursKnown has {numRecords} records");
                //find any old enemy records that need deleting
                foreach (var rumour in dictRumoursKnown)
                {
                    if (rumour.Value.Status == RumourStatus.Timed && rumour.Value.TimerExpire <= 0)
                    { listOfKeysToDelete.Add(rumour.Key); }
                }
                //delete the records from the dict
                for(int i = 0; i < listOfKeysToDelete.Count; i++)
                {
                    if (dictRumoursKnown.Remove(listOfKeysToDelete[i]) == true)
                    { Game.logTurn?.Write($"[Rumour -> Deleted] RumourID {listOfKeysToDelete[i]}");}
                    else { Game.SetError(new Error(281, $"Failed to delete RumourID {listOfKeysToDelete[i]} from dictRumoursKnown")); }
                }
            }
            else { Game.logTurn?.Write("[Notification] There are no rumours in dictRumoursKnown"); }
        }

        /// <summary>
        /// updates Movement map layer for the different actors (key is mapMarker which is also the ActID of the character moving) Enemies are only shown if known.
        /// </summary>
        private void UpdateActorMoveStatus(Dictionary<int, Position> dictMoveActors)
        {
            int marker;
            //clear out the Movement layer of the grid first
            Game.map.ClearMapLayer(MapLayer.Movement);
            //loop dictionary of move actors
            foreach (var pos in dictMoveActors)
            {
                marker = -1;
                //get actor
                Actor person = GetAnyActor(pos.Key);
                if (person != null)
                {
                    marker = pos.Key;
                    if (person is Enemy)
                    {
                        //enemies are shown as '999' indicating Known status (converted to '0' by map.DrawMapRL)
                        Enemy enemy = person as Enemy;
                        if (enemy.Known == true)
                        { marker = 999; }
                        else { marker = -1; }
                    }
                    //show on map only if known
                    if (marker > 0)
                    { Game.map.SetMapInfo(MapLayer.Movement, pos.Value.PosX, pos.Value.PosY, marker); }
                }
                else { Game.SetError(new Error(157, "Invalid key (ActID) in dictMoveActors (not found in dict)")); }
            }
        }

        /// <summary>
        /// Calculates crow %'s at start of trun
        /// </summary>
        private void CalculateCrows()
        {
            int distance, chance;
            //Player is assumed to be the first record in dictActiveActors
            Player player = GetPlayer();
            Position posPlayer = player.GetActorPosition();
            //Top up Player Crows to the maximum allowed
            player.CrowsNumber = Game.constant.GetValue(Global.CROW_NUMBER);
            //loop through active players
            foreach (var actor in dictActiveActors)
            {
                if (actor.Value is Follower)
                {
                    actor.Value.ClearCrowTooltips();
                    actor.Value.Activated = false;
                    Position pos = actor.Value.GetActorPosition();
                    distance = Game.utility.GetDistance(posPlayer.PosX, posPlayer.PosY, pos.PosX, pos.PosY);
                    chance = 100 - (distance * 2) + actor.Value.CrowBonus;
                    chance = Math.Min(100, chance);

                    if (player.Status != ActorStatus.AtLocation || player.Conceal == ActorConceal.SafeHouse)
                    {
                        //no crows can be sent if Player isn't at a Location, or is in a SafeHouse
                        actor.Value.CrowChance = 0;
                        actor.Value.CrowBonus = 0;
                        actor.Value.CrowDistance = distance;
                        //actor.Value.CrowBonus = 0;
                        actor.Value.AddCrowTooltip("No crows can be sent, or received, if the Player is travelling, or is being held");
                    }
                    else
                    {
                        if (actor.Value.Status == ActorStatus.AtLocation)
                        {
                            if (actor.Value.LocID != player.LocID)
                            {
                                //Normal operations -> Player and Follower both at a Location
                                actor.Value.CrowChance = chance;
                                actor.Value.CrowDistance = distance;
                                //actor.Value.CrowBonus = 0;
                                actor.Value.AddCrowTooltip(string.Format("Chance is {0}%  (One hundred less distance doubled plus any bonus)", chance));
                                if (actor.Value.CrowBonus > 0)
                                {
                                    actor.Value.AddCrowTooltip(string.Format("Includes a cumulative bonus of +{0}% from previous failed crows that might be delayed",
                                      Game.constant.GetValue(Global.CROW_BONUS)));
                                }
                            }
                            else
                            {
                                //both at the same location -> no crow required and automatic activation
                                actor.Value.Activated = true;
                                actor.Value.CrowChance = 100;
                                actor.Value.AddCrowTooltip("Automatic activation as at the same location as the Player");
                            }
                        }
                        else
                        {
                            //no crows can be sent if Follower isn't at a Location
                            actor.Value.CrowChance = 0;
                            actor.Value.CrowDistance = distance;
                            actor.Value.CrowBonus = 0;
                            actor.Value.AddCrowTooltip("No crows can be sent to the Follower if they are travelling");
                        }
                    }
                    if (distance > 0)
                    { actor.Value.AddCrowTooltip(string.Format("Distance from Player is {0} leagues, as the crow flies", distance)); }
                }
            }
        }

        /// <summary>
        /// Send a crow to a loyal follower
        /// </summary>
        public List<Snippet> SendCrow(int actorID)
        {
            List<Snippet> listSnippet = new List<Snippet>();
            string description, messageText, locName;
            int chance, num;
            Active actor = GetActiveActor(actorID);
            Player player = GetPlayer();
            int bonus = Game.constant.GetValue(Global.CROW_BONUS);
            if (player.Status == ActorStatus.AtLocation)
            {
                if (player.Conceal != ActorConceal.SafeHouse)
                { 
                    if (player.CrowsNumber > 0)
                    {
                        if (actor != null)
                        {
                            if (actorID != 1)
                            {
                                if (actor.Status == ActorStatus.AtLocation)
                                {
                                    if (actor.LocID != player.LocID)
                                    {
                                        if (actor.Delay == 0)
                                        {
                                            if (actor.Activated == false)
                                            {
                                                locName = GetLocationName(actor.LocID);
                                                num = rnd.Next(100);
                                                chance = actor.CrowChance + actor.CrowBonus;
                                                description = string.Format("chance of Crow arriving {0}%, or less. Roll {1}", chance, num);
                                                listSnippet.Add(new Snippet(string.Format("Crow dispatched to {0}, Aid {1}, at {2} (distance {3} leagues)", actor.Name, actor.ActID, locName, actor.CrowDistance)));
                                                player.CrowsNumber--;
                                                messageText = string.Format("Crow sent to {0}, Aid {1}, at {2} ({3}% chance of arriving, roll {4}, {5})", actor.Name, actor.ActID, locName, chance,
                                                    num, num < chance ? "Arrived" : "Failed");
                                                Message message = new Message(messageText, actor.ActID, actor.LocID, MessageType.Crow);
                                                SetMessage(message);
                                                if (num < chance)
                                                {
                                                    //success!
                                                    actor.Activated = true;
                                                    actor.CrowBonus = 0;
                                                    listSnippet.Add(new Snippet(string.Format("Crow success! {0} activated ({1})", actor.Name, description), RLColor.Yellow, RLColor.Black));
                                                    //Game.messageLog.Add(new Snippet(string.Format("Crow arrived, {0} activated", actor.Name)));
                                                    Message message_1 = new Message(string.Format("{0}, Aid {1}, has been Activated", actor.Name, actor.ActID), MessageType.Activation);
                                                    SetMessage(message_1);
                                                }
                                                else
                                                //failed the roll, apply bonus
                                                {
                                                    actor.Activated = false;
                                                    listSnippet.Add(new Snippet(string.Format("The Crow failed to arrive ({0})", description)));
                                                    actor.CrowBonus += bonus;
                                                    actor.AddCrowTooltip(string.Format("An additional bonus of +{0}% applies from a previous failed crow that might have been delayed", bonus));
                                                }
                                                listSnippet.Add(new Snippet(string.Format("You have {0} {1} remaining", player.CrowsNumber, player.CrowsNumber == 1 ? "Crow" : "Crows")));
                                            }
                                            else
                                            //already activated
                                            { listSnippet.Add(new Snippet(string.Format("{0} is already activated and awaiting your orders!", actor.Name))); }
                                        }
                                        else
                                        {
                                            //actor delayed
                                            { listSnippet.Add(new Snippet(string.Format("Crow can NOT be dispatched to {0} as they are delayed (\"{1}\"", actor.Name, actor.DelayReason))); }
                                        }
                                    }
                                    else
                                    {
                                        //at same location as player
                                        listSnippet.Add(new Snippet(string.Format("No crow required as {0} is present at the same location as yourself", actor.Name)));
                                        actor.Activated = true;
                                    }
                                }
                                else
                                //actor not at a location
                                { listSnippet.Add(new Snippet(string.Format("Crow can NOT be dispatched to {0} as they aren't at a location", actor.Name))); }
                            }
                            else
                            //sending a crow to yourself
                            { listSnippet.Add(new Snippet("There is no need to send a crow to yourself!")); }
                        }
                        else
                        //invalid actor
                        { listSnippet.Add(new Snippet("Unknown Actor. No crow sent.")); }
                    }
                    else
                    //run out of crows
                    { listSnippet.Add(new Snippet("You have run out of crows. More will be available next turn")); }
                }
                else
                //Player at safe house
                { listSnippet.Add(new Snippet("You are unable to dispatch crows while in a Safe House", RLColor.LightRed, RLColor.Black)); }
            }
            else
            {
                //Main error states
                if (player.Status == ActorStatus.Travelling) { listSnippet.Add(new Snippet("You are unable to dispatch crows while you are Travelling", RLColor.LightRed, RLColor.Black)); }
                else if (player.Status == ActorStatus.AtSea) { listSnippet.Add(new Snippet("You are unable to dispatch crows while at Sea", RLColor.LightRed, RLColor.Black)); }
                else if (player.Status == ActorStatus.Captured) { listSnippet.Add(new Snippet("You are unable to dispatch crows while you are Incarcerated", RLColor.LightRed, RLColor.Black)); }
                else if (player.Status == ActorStatus.Gone) { listSnippet.Add(new Snippet("You are unable to dispatch crows from the AfterLife", RLColor.LightRed, RLColor.Black)); }
                else { listSnippet.Add(new Snippet(string.Format("Your Status isn't recognised (\"{0}\") and crows are consequently unavailable", player.Status), RLColor.LightRed, RLColor.Black)); }
            }
            return listSnippet;
        }

        /// <summary>
        /// provides # of crows remaining
        /// </summary>
        /// <returns></returns>
        public int GetCrowsAvailable()
        {
            Player player = GetPlayer();
            //snippet = new Snippet(string.Format("You have {0} {1} remaining", numCrows, numCrows == 1 ? "Crow" : "Crows"));
            return player.CrowsNumber;
        }

        /// <summary>
        /// handles end of turn housekeeping for all actor types
        /// </summary>
        private void HousekeepActors()
        {
            Game.logTurn?.Write("--- HouseKeepActors (World.cs)");
            //All actors -> decrement any Condition timers
            foreach (var actor in dictAllActors)
            {
                if (actor.Value.CheckConditions() == true)
                { actor.Value.UpdateConditionTimers(); }
            }
            //Active actors -> decrement any delays
            foreach (var actor in dictActiveActors)
            {
                if (actor.Value.Delay > 0)
                {
                    actor.Value.Delay--;
                    if (actor.Value.Delay == 0)
                    { actor.Value.DelayReason = null; }
                }
                //reset Found and listOfEnemies (search routines)
                actor.Value.Found = false;
                actor.Value.Capture = false;
                actor.Value.ResetEnemies();
                actor.Value.ResetSearched();
                //Player
                if (actor.Value.ActID == 1)
                {
                    Player player = actor.Value as Player;
                    //incarcerated?
                    switch (player.Status)
                    {
                        case ActorStatus.Captured:
                            //stats
                            Game.statistic.AddStat(GameStatistic.Dungeon_Days);
                            actor.Value.Known = true; actor.Value.Revert = 2;
                            //raise Legend_King each turn player is held in dungeon
                            int legendLoss = Game.constant.GetValue(Global.LOSS_OF_LEGEND);
                            int currentValue = Game.director.GetGameState(GameState.Legend_King, DataState.Good);
                            int newValue = Math.Abs(Game.director.ChangeData(currentValue, legendLoss, Event_System.EventCalc.Add));
                            Game.director.SetGameState(GameState.Legend_King, DataState.Good, newValue, true);
                            //message
                            string description = string.Format("The Legend of {0} {1} grows (+{2}) while the Usurper is incarcerated", Game.lore.NewKing.Title, Game.lore.NewKing.Name, legendLoss);
                            SetMessage(new Message(description, MessageType.Incarceration));
                            break;
                        case ActorStatus.AtLocation:
                            //stats
                            Game.statistic.AddStat(GameStatistic.Location_Days);
                            //horse matters
                            switch (player.horseStatus)
                            {
                                case HorseStatus.Normal:
                                    //handles God mode moving from one to another
                                    player.horseStatus = HorseStatus.Stabled;
                                    break;
                                case HorseStatus.Lame:
                                case HorseStatus.Exhausted:
                                case HorseStatus.Gone:
                                    Game.SetError(new Error(298, $"A Horse can't be \"{player.horseStatus}\" Status while at a Location"));
                                    break;
                                case HorseStatus.Stabled:
                                    player.HorseDays++;
                                    if (player.HorseHealth < player.HorseMaxHealth)
                                    { player.HorseHealth++; SetMessage(new Message($"\"{player.HorseName}\" is recovering while stabled", 1, player.LocID, MessageType.Horse)); }
                                    break;
                            }
                            break;
                        case ActorStatus.Travelling:
                            //stats
                            Game.statistic.AddStat(GameStatistic.Travelling_Days);
                            //horse matters
                            if (player.horseStatus != HorseStatus.Gone) { player.HorseDays++; }
                            break;
                        case ActorStatus.AtSea:
                            //stats
                            Game.statistic.AddStat(GameStatistic.AtSea_Days);
                            break;
                        case ActorStatus.Adrift:
                            //stats
                            Game.statistic.AddStat(GameStatistic.Adrift_Days);
                            break;
                    }

                    //stats
                    if (player.Known == true) { Game.statistic.AddStat(GameStatistic.Known_Days); }
                    if (player.Conceal == ActorConceal.Disguise) { Game.statistic.AddStat(GameStatistic.Disguise_Days); }
                    if (player.Conceal == ActorConceal.SafeHouse) { Game.statistic.AddStat(GameStatistic.SafeHouse_Days); }
                }
            }
        }

        /// <summary>
        /// returns number of object types in dictionary
        /// </summary>
        /// <param name="possType"></param>
        /// <returns></returns>
        internal int GetPossessionsCount(PossessionType possType)
        {
            int num = 0;
            switch (possType)
            {
                case PossessionType.Item:
                    var itemResult = from possObject in dictPossessions
                                     where possObject.Value is Item
                                     select possObject;
                    num = itemResult.Count();
                    break;
                case PossessionType.Secret:
                    var secretResult = from possObject in dictPossessions
                                       where possObject.Value is Secret
                                       select possObject;
                    num = secretResult.Count();
                    break;
                case PossessionType.None:
                    Game.SetError(new Error(120, "Invalid possType Input (None)"));
                    break;
                default:
                    Game.SetError(new Error(120, string.Format("Invalid possType Input (\"{0}\")", possType)));
                    break;
            }
            return num;
        }

        internal int GetRumoursNormalCount()
        { return dictRumoursNormal.Count; }

        internal int GetRumoursTimedCount()
        { return dictRumoursTimed.Count; }

        /// <summary>
        /// returns a list of year + description of the specific object type in dictionary
        /// </summary>
        /// <param name="possType"></param>
        /// <returns></returns>
        internal List<string> GetPossessionsSummary(PossessionType possType)
        {
            List<string> tempList = new List<string>();
            switch (possType)
            {
                case PossessionType.Secret:
                    IEnumerable<string> secretList =
                    from secret in dictPossessions
                    where secret.Value is Secret
                    orderby secret.Value.Year
                    select Convert.ToString(secret.Value.Year + " " + secret.Value.Description);
                    tempList = secretList.ToList();
                    break;
                case PossessionType.Item:
                    IEnumerable<string> itemListActive =
                        from items in dictPossessions.Values.OfType<Item>()
                        where items.ItemType == PossItemType.Active && items.WhoHas > 0
                        select Convert.ToString("ItemID " + items.ItemID + ", \"" + items.Description + "\", Type: " + items.ItemType + ", " + GetActorDetails(items.WhoHas, false));
                    tempList = itemListActive.ToList();
                    IEnumerable<string> itemListPassive =
                        from items in dictPossessions.Values.OfType<Item>()
                        where items.ItemType == PossItemType.Passive && items.WhoHas > 0
                        select Convert.ToString("ItemID " + items.ItemID + ", \"" + items.Description + "\", Type: " + items.ItemType + ", " + GetActorDetails(items.WhoHas, false));
                    tempList.AddRange(itemListPassive.ToList());
                    break;
                case PossessionType.None:
                    Game.SetError(new Error(121, "Invalid possType Input (None)"));
                    break;
                default:
                    Game.SetError(new Error(121, string.Format("Invalid possType Input (\"{0}\")", possType)));
                    break;
            }

            return tempList;
        }

        /// <summary>
        /// checks all active followers and updates their position on the map 'Information' layer (used to show characters if the Information toggle is pressed ("I")
        /// </summary>
        private void UpdateFollowerPositions()
        {
            Game.map.ClearMapLayer(MapLayer.Followers);
            foreach (var follower in dictActiveActors)
            {
                if (follower.Key > 0 && follower.Value.Status != ActorStatus.Gone)
                {
                    Position pos = follower.Value.GetActorPosition();
                    if (pos != null)
                    { Game.map.SetMapInfo(MapLayer.Followers, pos.PosX, pos.PosY, follower.Key); }
                }
            }
        }

        /// <summary>
        /// shows all known enemies
        /// </summary>
        private void UpdateEnemiesPositions()
        {
            Game.map.ClearMapLayer(MapLayer.Enemies);
            Game.map.ClearMapLayer(MapLayer.EnemiesDebug);
            int expire = Game.constant.GetValue(Global.KNOWN_REVERT);
            //loop dictionary -> only place on map layer if known
            foreach (var enemy in dictEnemyActors)
            {
                if (enemy.Value.Status != ActorStatus.Gone)
                {
                    Position pos = enemy.Value.GetActorPosition();
                    //add to enemiesDebug layer regardless (shows all enemies at current positions)
                    Game.map.SetMapInfo(MapLayer.EnemiesDebug, pos.PosX, pos.PosY, 1);
                    //normal enemies Layer (only what is known by the player)
                    if (enemy.Value.Known == true)
                    {
                        //show enemy with a map marker indicating how many days old the information is -> 1 day old as Known
                        if (pos != null)
                        { Game.map.SetMapInfo(MapLayer.Enemies, pos.PosX, pos.PosY, 1); }
                    }
                    else if (enemy.Value.TurnsUnknown <= expire)
                    {
                        //show enemy with a map marker indicating how many days old the information is (show last known position, not current one).
                        Position pos_1 = enemy.Value.LastKnownPos;
                        if (pos_1 != null)
                        { Game.map.SetMapInfo(MapLayer.Enemies, pos_1.PosX, pos_1.PosY, enemy.Value.TurnsUnknown); }
                    }
                }
            }
        }

        /// <summary>
        /// start of turn Housekeeping for Active Actors
        /// </summary>
        private void UpdateActiveActors()
        {
            Game.logTurn?.Write("--- UpdateActiveActors (World.cs)");
            foreach (var actor in dictActiveActors)
            {
                //if Known, decrement their revert status
                if (actor.Value.Known == true)
                {
                    actor.Value.LastKnownLocID = actor.Value.LocID;
                    actor.Value.TurnsUnknown = 0;
                    actor.Value.Revert--;
                    Game.logTurn?.Write(string.Format(" {0} {1} has had their Revert Timer reduced from {2} to {3}", actor.Value.Title, actor.Value.Name, actor.Value.Revert + 1, actor.Value.Revert));
                    if (actor.Value.Revert <= 0)
                    {
                        //Reverts from Known to Unknown state
                        actor.Value.Known = false;
                        string eventText = string.Format("{0} {1} is no longer \"Known\" as sufficient time has passed", actor.Value.Title, actor.Value.Name);
                        Message message = new Message(eventText, MessageType.Known);
                        SetMessage(message);
                        int refID = ConvertLocToRef(actor.Value.LocID);
                        if (actor.Value.ActID == 1)
                        { SetPlayerRecord(new Record(eventText, actor.Value.ActID, actor.Value.LocID, CurrentActorEvent.Known)); }
                        else if (actor.Value.ActID > 1)
                        { SetCurrentRecord(new Record(eventText, actor.Value.ActID, actor.Value.LocID, CurrentActorEvent.Known)); }
                        Game.logTurn?.Write(eventText);
                    }
                }
                else if (actor.Value.Known == false)
                {
                    actor.Value.TurnsUnknown++;
                    Game.logTurn?.Write(string.Format(" {0} {1} has had their TurnsUnknown Timer increased from {2} to {3}",
                        actor.Value.Title, actor.Value.Name, actor.Value.TurnsUnknown - 1, actor.Value.TurnsUnknown));
                }
            }
        }

        /// <summary>
        /// set up the two refID -> LocID (& vice versa) dictionaries at start of game
        /// </summary>
        private void InitialiseConversionDicts()
        {
            List<Location> listOfLocations = Game.map.GetLocations();
            if (listOfLocations != null)
            {
                int refID, locID, houseID;
                //get all other Loc & Ref data directly from map
                foreach (Location loc in listOfLocations)
                {
                    locID = loc.LocationID;
                    //set up conversion dictionaries
                    refID = Game.map.GetMapInfo(MapLayer.RefID, loc.GetPosX(), loc.GetPosY());
                    houseID = Game.map.GetMapInfo(MapLayer.HouseID, loc.GetPosX(), loc.GetPosY());
                    if (refID > 0)
                    {
                        try
                        { dictConvertLocToRef.Add(locID, refID); }
                        catch (ArgumentException)
                        { Game.SetError(new Error(145, "Invalid LocID, Record already exists (LocID -> RefID)")); }
                        try
                        { dictConvertRefToLoc.Add(refID, locID); }
                        catch (ArgumentException)
                        { Game.SetError(new Error(145, "Invalid RefID, Record already exists (RefID -> LocID)")); }
                        if (houseID > 0)
                        {
                            try
                            { dictConvertRefToHouse.Add(refID, houseID); }
                            catch (ArgumentException)
                            { Game.SetError(new Error(145, "Invalid refID, Record already exists (RefID -> HouseID)")); }
                        }
                    }
                }
            }
            else { Game.SetError(new Error(145, "Invalid listOfLocations (null)")); }
        }

        /// <summary>
        /// get corresponding RefID from LocID. Returns 0 if not found.
        /// </summary>
        /// <param name="locID"></param>
        /// <returns></returns>
        internal int ConvertLocToRef(int locID)
        {
            if (locID > 0)
            {
                if (dictConvertLocToRef.ContainsKey(locID) == true)
                { return dictConvertLocToRef[locID]; }
                else { Game.SetError(new Error(146, "Invalid LocID (record not found")); }
            }
            return 0;
        }

        /// <summary>
        /// get corresponding LocID from RefID. Returns 0 if not found.
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal int ConvertRefToLoc(int refID)
        {
            if (refID > 0)
            {
                if (dictConvertRefToLoc.ContainsKey(refID) == true)
                { return dictConvertRefToLoc[refID]; }
                else { Game.SetError(new Error(147, "Invalid refID (record not found")); }
            }
            return 0;
        }

        /// <summary>
        /// get corresponding HouseID from RefID. Returns 0 if not found.
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal int ConvertRefToHouse(int refID)
        {
            if (refID > 0)
            {
                if (dictConvertRefToHouse.ContainsKey(refID) == true)
                { return dictConvertRefToHouse[refID]; }
                else { Game.SetError(new Error(236, "Invalid refID (record not found")); }
            }
            return 0;
        }



        /// <summary>
        /// Master AI controller, checked each turn, determines HuntMode for each enemy based on big picture analysis
        /// </summary>
        private void UpdateAIController()
        {
            int threshold = Game.constant.GetValue(Global.AI_HUNT_THRESHOLD); //max # turns since Player last known that AI will continue to hunt
            int knownStatus = GetActiveActorTrackingStatus(1); //if '0' then Known, if > 0 then # of days since last known
            int playerLocID, distance, enemyDM;
            int turnsToDestination = 0; //# of turns for Player to reach their destination if travelling (used to adjust threshold)
            Game.logTurn?.Write("--- UpdateAIController (World.cs)");
            //get player
            Player player = GetPlayer();
            if (player != null)
            {
                //Travelling? Allow for time taken to reach destination
                if (player.Status == ActorStatus.Travelling)
                {
                    //loop List of Move objects looking for Player's party
                    for (int i = 0; i < listMoveObjects.Count; i++)
                    {
                        Move moveObject = listMoveObjects[i];
                        if (moveObject.PlayerInParty == true)
                        {
                            //player found, determine how many route segments left
                            turnsToDestination = moveObject.CheckTurnsToDestination();
                            Game.logTurn?.Write(string.Format(" [AI -> Notification] Player is Travelling -> {0} turns from their destination", turnsToDestination));
                            break;
                        }
                    }
                }
                //ignore all this if player Incarcerated in a dungeon?
                if (player.Status == ActorStatus.AtLocation || player.Status == ActorStatus.Travelling)
                {
                    //threshold is adjusted upwards if Player enroute to a destination
                    threshold += turnsToDestination;
                    //Player location is current, if known, or last known if not. Will be destination if travelling.
                    if (knownStatus == 0) { playerLocID = GetActiveActorLocByID(1); }
                    else { playerLocID = GetActiveActorLastKnownLoc(1); }
                    if (playerLocID > 0)
                    {
                        //can only hunt a recently known player for so long before reverting back to normal behaviour (there is a time taken test below which tests threshold on a tighter basis)
                        if (knownStatus <= threshold)
                        {
                            //Known
                            Location loc = Game.network.GetLocation(playerLocID);
                            if (loc != null)
                            {
                                Position playerPos = loc.GetPosition();
                                //dictionary to handle sorted distance data
                                Dictionary<int, int> tempDict = new Dictionary<int, int>();
                                foreach (var enemy in dictEnemyActors)
                                {
                                    //store enemies in tempDict by dist to player (key is ActID, value distance)
                                    Position enemyPos = enemy.Value.GetActorPosition();
                                    if (playerPos != null && enemyPos != null)
                                    {
                                        //only check enemies at a location (those who are travelling will have to wait)
                                        if (enemy.Value.Status == ActorStatus.AtLocation)
                                        {
                                            List<Route> route = Game.network.GetRouteAnywhere(enemyPos, playerPos);
                                            distance = Game.network.GetDistance(route);
                                            try
                                            { tempDict.Add(enemy.Value.ActID, distance); }
                                            catch (ArgumentException)
                                            { Game.SetError(new Error(167, string.Format("Invalid enemy ID {0} (duplicate)", enemy.Value.ActID))); }
                                        }
                                        else {
                                            Game.logTurn?.Write(string.Format(" [AI -> Notification] {0} {1}, ActID {2} is Travelling to {3}", enemy.Value.Title, enemy.Value.Name,
                                            enemy.Value.ActID, GetLocationName(enemy.Value.LocID))); }
                                    }
                                    else
                                    {
                                        Game.SetError(new Error(167, string.Format("Invalid Player ({0}:{1}) or Enemy Position ({2}:{3})", playerPos.PosX, playerPos.PosY,
                                     enemyPos.PosX, enemyPos.PosY)));
                                    }
                                }
                                //sort dictionary by distance
                                if (tempDict.Count > 0)
                                {
                                    var sorted = from pair in tempDict orderby pair.Value ascending select pair;
                                    foreach (var pair in sorted)
                                    {
                                        Enemy enemy = (Enemy)GetAnyActor(pair.Key);
                                        if (enemy != null)
                                        {
                                            //set nemesis to have double the normal threshold (will hunt at twice the distance from the player than an inquisitor)
                                            enemyDM = 1;
                                            if (enemy is Nemesis) { enemyDM = 2; }
                                            //can enemy reach player loc within threshold time? (distance / speed = # of turns <= threshold # of turns allowed
                                            if ((pair.Value / enemy.Speed) <= (threshold * enemyDM))
                                            { enemy.HuntMode = true; }
                                            else { enemy.HuntMode = false; }
                                            Game.logTurn?.Write(string.Format(" [AI -> Mode] enemyID {0},  distance -> {1}  Threshold (turns) -> {2}  Mode -> {3}", pair.Key, pair.Value,
                                                threshold * enemyDM, enemy.HuntMode == true ? "Hunt" : "Normal"));
                                        }
                                        else { Game.SetError(new Error(167, string.Format("Invalid enemy, ID {0} (null)", pair.Key))); }
                                    }
                                }
                                else { Game.logTurn?.Write(" [AI -> Notification] tempDictionary has too few records to sort (zero)"); }
                            }
                            else { Game.SetError(new Error(167, "Invalid Loc (null) Dictionary not updated")); }
                        }
                        else
                        {
                            //Unknown -> all enemies at a location are set to normal mode (huntmode 'false')
                            foreach (var enemy in dictEnemyActors)
                            {
                                if (enemy.Value.Status == ActorStatus.AtLocation)
                                {
                                    enemy.Value.HuntMode = false;
                                    Game.logTurn?.Write(string.Format(" [AI -> Player Unknown] {0} {1}, Act ID {2} Mode -> Normal", enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID));
                                }
                            }
                        }
                    }
                    else { Game.SetError(new Error(167, "Warning -> LocID of Player has returned Zero")); }
                }
                else if (player.Status == ActorStatus.Captured)
                {
                    //Incarcerated in a dungeon -> all enemies at a location are set to normal mode (huntmode 'false')
                    foreach (var enemy in dictEnemyActors)
                    {
                        if (enemy.Value.Status == ActorStatus.AtLocation)
                        {
                            enemy.Value.HuntMode = false;
                            Game.logTurn?.Write(string.Format(" [AI -> Player Captured] {0} {1}, Act ID {2} Mode -> Normal", enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID));
                        }
                    }
                }
            }
            else { Game.SetError(new Error(167, "Invalid player (Null), set Enemy AI bypassed")); }
        }

        /// <summary>
        /// handles AI for all enemies, also updates status (known, etc.)
        /// </summary>
        private void SetEnemyActivity()
        {
            Player player = GetPlayer();
            if (player != null)
            {
                int turnsDM; //DM for the # of turns spent on the same goal (prevents enemy being locked into a set goal due to bad rolls)
                int playerLocID = player.LocID;
                int turnsUnknown = player.TurnsUnknown;
                bool huntStatus;
                int ai_search = Game.constant.GetValue(Global.AI_CONTINUE_SEARCH);
                int ai_hide = Game.constant.GetValue(Global.AI_CONTINUE_HIDE);
                int ai_wait = Game.constant.GetValue(Global.AI_CONTINUE_WAIT);
                int revert = Game.constant.GetValue(Global.KNOWN_REVERT);
                Game.logTurn?.Write("--- SetEnemyActivity (World.cs)");
                //loop enemy dictionary
                foreach (var enemy in dictEnemyActors)
                {
                    //debug -> random chance of enemy being known
                    if (enemy.Value.Known == false && rnd.Next(100) < 20)
                    {
                        enemy.Value.Known = true; enemy.Value.Revert = revert;
                        Game.logTurn?.Write(string.Format(" [Enemy -> Known] {0} ActID {1} has become KNOWN", enemy.Value.Name, enemy.Value.ActID));
                    }

                    //update status -> unknown
                    if (enemy.Value.Known == false) { enemy.Value.TurnsUnknown++; enemy.Value.Revert = 0; }
                    else
                    {
                        //known
                        enemy.Value.TurnsUnknown = 0;
                        enemy.Value.LastKnownLocID = enemy.Value.LocID;
                        enemy.Value.LastKnownPos = enemy.Value.GetActorPosition();
                        enemy.Value.LastKnownGoal = enemy.Value.Goal;
                        enemy.Value.Revert--;
                        if (enemy.Value.Revert <= 0)
                        {
                            enemy.Value.Revert = 0; enemy.Value.Known = false; enemy.Value.TurnsUnknown++;
                            Game.logTurn?.Write(string.Format(" [Enemy -> Unknown] {0} ActID {1} has reverted to Unknown status (timer elapsed)", enemy.Value.Name, enemy.Value.ActID));
                        }
                    }
                    //continue on with existing goal or get a new one?
                    if (enemy.Value is Inquisitor || enemy.Value is Nemesis)
                    {
                        //inquisitors -> if Move then automatic (continues on with Move)
                        if (enemy.Value.Goal != ActorAIGoal.Move)
                        {
                            huntStatus = enemy.Value.HuntMode;
                            turnsDM = enemy.Value.GoalTurns; //+1 % chance of changing goal per turn spent on existing goal
                            enemy.Value.GoalTurns++;
                            switch (enemy.Value.Goal)
                            {
                                case ActorAIGoal.None:
                                    //auto assign new goal
                                    SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown);
                                    break;
                                case ActorAIGoal.Wait:
                                    if (huntStatus == true)
                                    {
                                        //Player Known -> Will Search if same Loc
                                        SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown);
                                    }
                                    else
                                    {
                                        //Player Unknown
                                        if (rnd.Next(100) > (ai_wait + turnsDM))
                                        { SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown); }
                                        else { Game.logTurn?.Write(string.Format(" [Enemy -> Goal] {0}, ActID {1} retains Goal -> {2}", enemy.Value.Name, enemy.Value.ActID, enemy.Value.Goal)); }
                                    }
                                    break;
                                case ActorAIGoal.Search:
                                    if (huntStatus == true)
                                    {
                                        //Player Known -> if actor at different location then new goal
                                        if (enemy.Value.LocID != playerLocID)
                                        { SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown); }
                                    }
                                    else
                                    {
                                        //Player Unknown
                                        if (rnd.Next(100) > (ai_search + turnsDM))
                                        { SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown); }
                                        else { Game.logTurn?.Write(string.Format(" [Enemy -> Goal] {0}, ActID {1} retains Goal -> {2}", enemy.Value.Name, enemy.Value.ActID, enemy.Value.Goal)); }
                                    }
                                    break;
                                case ActorAIGoal.Hide:
                                    if (huntStatus == true)
                                    {
                                        //Player Known -> if actor at different location then new goal
                                        if (enemy.Value.LocID != playerLocID)
                                        { SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown); }
                                    }
                                    else
                                    {
                                        //Player Unknown
                                        if (rnd.Next(100) > (ai_hide + turnsDM))
                                        { SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown); }
                                        else { Game.logTurn?.Write(string.Format(" [Enemy -> Goal] {0}, ActID {1} retains Goal -> {2}", enemy.Value.Name, enemy.Value.ActID, enemy.Value.Goal)); }
                                    }
                                    break;
                                default:
                                    Game.SetError(new Error(155, string.Format("Invalid Enemy Goal (\"{0}\")", enemy.Value.Goal)));
                                    break;
                            }
                        }
                    }
                    else
                    {
                        //all other enemies
                    }
                }
            }
            else { Game.SetError(new Error(155, "Invalid Player (null)")); }
        }

        /// <summary>
        /// sub method to provide a new goal when required -> Incorporates all necessary AI logic
        /// <param name="knowStatus">if '0' then player status is Unknown</param>
        /// <param name="playerLocID">current locID or Player's destination locId if travelling</param>
        /// <param name="turnsUnknown">Number of Turns player has been unknown for ('0' -> known)</param>
        /// </summary>
        /// <param name="enemy"></param>
        private void SetEnemyGoal(Enemy enemy, bool huntStatus, int playerLocID, int turnsUnknown)
        {
            Game.logTurn?.Write("--- SetEnemyGoal (World.cs)");
            bool huntMoveFlag = false;
            int rndNum, refID, tempDistance, enemyDistance, tempLocID;
            int currentBranch = -1;
            ActorAIGoal newGoal = ActorAIGoal.None;
            if (enemy != null)
            {
                if (playerLocID > 0)
                {
                    //get location of enemy
                    Location loc = Game.network.GetLocation(enemy.LocID);
                    if (loc != null)
                    {
                        //get branch info
                        refID = ConvertLocToRef(enemy.LocID);
                        if (refID > 0)
                        {
                            House house = null;
                            if (refID == 9999) //capital
                            { currentBranch = 0; }
                            else
                            {
                                house = GetHouse(refID);
                                currentBranch = house.Branch;
                            }
                            //debug
                            Game.logTurn?.Write(string.Format(" [Goal -> Branch] {0}, ActID {1} Assigned Branch -> {2} Current Branch -> {3}", enemy.Name, enemy.ActID, enemy.AssignedBranch, currentBranch));
                            //Mode -> Hunt or Normal (set by UpdateAIController)
                            if (huntStatus == true)
                            {
                                //Player Known, Hunt Mode -> not at same location
                                if (enemy.LocID != playerLocID)
                                {
                                    newGoal = ActorAIGoal.Move;
                                    huntMoveFlag = true;
                                }
                                //Player Known, Hunt Mode -> Same location -> Search
                                else { newGoal = ActorAIGoal.Search; }
                            }
                            else
                            {
                                //Normal Mode -> Player Unknown
                                rndNum = rnd.Next(100);
                                //Possible goals depend on location type
                                if (house != null)
                                {
                                    if (house is MajorHouse)
                                    {
                                        //Major House -> Wait 30, Hide 20, Move 50
                                        if (rndNum <= 30) { newGoal = ActorAIGoal.Wait; }
                                        else if (rndNum >= 50) { newGoal = ActorAIGoal.Move; }
                                        else { newGoal = ActorAIGoal.Hide; }
                                    }
                                    else if (house is MinorHouse)
                                    {
                                        //Minor House -> Wait 30, Move 70
                                        if (rndNum <= 30) { newGoal = ActorAIGoal.Wait; }
                                        else { newGoal = ActorAIGoal.Move; }
                                    }
                                    else if (house is InnHouse)
                                    {
                                        //Inn -> Wait 20, Hide 30, Move 50
                                        if (rndNum <= 20) { newGoal = ActorAIGoal.Wait; }
                                        else if (rndNum >= 50) { newGoal = ActorAIGoal.Move; }
                                        else { newGoal = ActorAIGoal.Hide; }
                                    }
                                    else { Game.SetError(new Error(156, "Invalid House type (not in list)")); }
                                }
                                else if (refID == 9999)
                                {
                                    //Capital
                                    if (enemy.AssignedBranch == 0)
                                    {
                                        //Capital (where enemy should be) -> Wait 70, Hide 30
                                        if (rndNum <= 70) { newGoal = ActorAIGoal.Wait; }
                                        else { newGoal = ActorAIGoal.Hide; }
                                    }
                                    else
                                    {
                                        //Capital -> Wait 30, Hide 20, Move 50
                                        if (rndNum <= 30) { newGoal = ActorAIGoal.Wait; }
                                        else if (rndNum >= 50) { newGoal = ActorAIGoal.Move; }
                                        else { newGoal = ActorAIGoal.Hide; }
                                    }
                                }
                            }
                        }
                        else
                        {
                            Game.SetError(new Error(156, string.Format("Enemy {0}, ID {1}, LocID {2} has an Invalid RefID (zero or less)", enemy.Name, enemy.ActID, enemy.LocID)));
                            //give default goal of Move
                            newGoal = ActorAIGoal.Move;
                        }

                        //reset Goal turns if new goal different to old goal
                        if (newGoal != enemy.Goal)
                        {
                            enemy.GoalTurns = 0;
                            //assign new goal
                            enemy.Goal = newGoal;
                            Game.logTurn?.Write(string.Format(" [Goal -> New] {0}, ActID {1}, {2}, assigned new Goal -> {3}", enemy.Name, enemy.ActID, GetLocationCoords(enemy.LocID),
                                enemy.Goal));
                        }
                        //
                        // --- Handle all Move logic here
                        //
                        if (newGoal == ActorAIGoal.Move)
                        {
                            Position posOrigin = enemy.GetActorPosition();
                            List<int> listNeighbours = loc.GetNeighboursLocID();
                            int destinationLocID = 0;
                            //
                            //-- HUNT mode
                            //
                            if (huntMoveFlag == true)
                            {
                                // - Move One Node closer to Player's last known location
                                if (turnsUnknown > 3 && rnd.Next(100) < 50)
                                {
                                    Location locTarget = Game.network.GetLocation(playerLocID);
                                    if (locTarget != null)
                                    {
                                        Position posTarget = locTarget.GetPosition();
                                        List<Position> pathTemp = Game.network.GetPathAnywhere(posOrigin, posTarget);
                                        //loop path looking for the first viable location along path
                                        for (int i = 0; i < pathTemp.Count; i++)
                                        {
                                            Position posTemp = pathTemp[i];
                                            if (posTemp != null)
                                            {
                                                tempLocID = Game.map.GetMapInfo(MapLayer.LocID, posTemp.PosX, posTemp.PosY);
                                                if (tempLocID > 0)
                                                {
                                                    Game.logTurn?.Write(string.Format(" [Goal -> Move] {0}, ActID {1} -> One Node closer to Player -> {2}, LocID {3}", enemy.Name, enemy.ActID,
                                                    GetLocationName(tempLocID), tempLocID));
                                                    destinationLocID = tempLocID; break;
                                                }
                                            }
                                            else { Game.SetError(new Error(156, "Invalid Position (null) in pathTemp")); }
                                        }
                                        //error check
                                        if (destinationLocID == 0)
                                        {
                                            destinationLocID = playerLocID;
                                            Game.logTurn?.Write(string.Format(" [Goal -> Alert] {0}, ActID [1} has been assigned a default PlayerLocID [move One Node closer] as no viable node was found",
                                                enemy.Name, enemy.ActID));
                                        }
                                    }
                                    else { Game.SetError(new Error(156, "Invalid locTarget (null) Viable Node not searched for")); }
                                }
                                // - Move Directly to Player's last known location
                                else
                                {
                                    Game.logTurn?.Write(string.Format(" [Goal -> Move] {0}, ActID {1} -> Player's last known location -> {2}, LocID {3}", enemy.Name, enemy.ActID,
                                                   GetLocationName(playerLocID), playerLocID));
                                    destinationLocID = playerLocID;
                                }
                            }
                            //
                            // -- NORMAL Mode
                            //
                            else
                            {
                                // - Correct Branch
                                if (enemy.AssignedBranch == currentBranch)
                                {
                                    //Not at Capital
                                    if (enemy.LocID > 1)
                                    {
                                        List<int> tempLocList = new List<int>();
                                        //change direction of travel?
                                        bool reverseStatus = false;
                                        switch (enemy.MoveOut)
                                        {
                                            case true:
                                                //slightly higher chance of reversing outward movement in order to keep inquisitors closer to the capital
                                                if (rnd.Next(100) < 15)
                                                { reverseStatus = true; }
                                                break;
                                            case false:
                                                if (rnd.Next(100) < 10)
                                                { reverseStatus = true; }
                                                break;
                                        }
                                        if (reverseStatus == true)
                                        {
                                            Game.logTurn?.Write(string.Format(" [Goal -> Alert] {0}, ActID {1} has reversed their MoveOut status from {2} to {3}", enemy.Name, enemy.ActID, enemy.MoveOut,
                                                enemy.MoveOut == true ? "False" : "True"));
                                            if (enemy.MoveOut == true) { enemy.MoveOut = false; }
                                            else { enemy.MoveOut = true; }
                                        }
                                        enemyDistance = loc.DistanceToCapital;
                                        for (int i = 0; i < listNeighbours.Count; i++)
                                        {
                                            Location locTemp = Game.network.GetLocation(listNeighbours[i]);
                                            if (locTemp != null)
                                            {
                                                tempDistance = locTemp.DistanceToCapital;

                                                if (enemy.MoveOut == true)
                                                {
                                                    //move outwards towards capital -> select any that are further out (also check not going across a connector)
                                                    if (tempDistance > enemyDistance && locTemp.GetBranch() == enemy.AssignedBranch)
                                                    { tempLocList.Add(listNeighbours[i]); }
                                                }
                                                else
                                                {
                                                    //move inwards towards capital -> select any that are further in
                                                    if (tempDistance < enemyDistance)
                                                    { tempLocList.Add(listNeighbours[i]); }
                                                }
                                            }
                                            else
                                            { Game.SetError(new Error(156, "Invalid LocID (zero or less) [Not at Capital] in ListOfNeighbours")); }
                                        }
                                        //any viable selections?
                                        if (tempLocList.Count > 0)
                                        {
                                            //randomly select a destination
                                            destinationLocID = tempLocList[rnd.Next(0, tempLocList.Count)];
                                            Game.logTurn?.Write(string.Format(" [Goal -> Move] {0}, ActID {1} -> Move {2} -> {3}, LocID {4}", enemy.Name, enemy.ActID, enemy.MoveOut == true ? "Outwards" : "Inwards",
                                                   GetLocationName(destinationLocID), destinationLocID));
                                        }
                                        else
                                        {
                                            //else must have reached the end of a branch -> reverse move direction to prevent an endless loop
                                            Game.logTurn?.Write(string.Format(" [Goal -> Alert] {0}, ActID {1} has reversed their MoveOut status [end of the Road] from {2} to {3}", enemy.Name, enemy.ActID,
                                                enemy.MoveOut, enemy.MoveOut == true ? "False" : "True"));
                                            if (enemy.MoveOut == true) { enemy.MoveOut = false; }
                                            else { enemy.MoveOut = true; }
                                            //NOTE: destinationLocID left unassigned (default '0') so that a random selection will be made at the end.
                                        }
                                    }
                                    //At Capital
                                    else if (enemy.LocID == 1)
                                    {
                                        //Currently at the Capital -> Shouldn't get to this situation (see above)
                                        Game.logTurn?.Write(string.Format(" [Goal -> Alert] Normal Mode, {0}, ActID {1} At Capital with correct branch -> Unassigned", enemy.Name, enemy.ActID));
                                    }
                                }
                                // - Incorrect Branch
                                else if (enemy.AssignedBranch != currentBranch && currentBranch > -1)
                                {
                                    //Not at Capital
                                    if (enemy.LocID > 1)
                                    {
                                        //return to Capital
                                        destinationLocID = 1;
                                        Game.logTurn?.Write(string.Format(" [Goal -> Move] {0}, ActID {1} -> Return to Capital -> {2}, LocID {3}", enemy.Name, enemy.ActID,
                                                   GetLocationName(destinationLocID), destinationLocID));
                                    }
                                    //At Capital
                                    else if (enemy.LocID == 1)
                                    {
                                        for (int i = 0; i < listNeighbours.Count; i++)
                                        {
                                            if (listNeighbours[i] > 0)
                                            {
                                                Location locTemp = Game.network.GetLocation(listNeighbours[i]);
                                                if (locTemp != null)
                                                {
                                                    if (locTemp.GetBranch() == enemy.AssignedBranch)
                                                    {
                                                        destinationLocID = listNeighbours[i];
                                                        Game.logTurn?.Write(string.Format(" [Goal -> Move] {0}, ActID {1} -> Capital to Correct Branch -> {2}, LocID {3}", enemy.Name, enemy.ActID,
                                                        GetLocationName(destinationLocID), destinationLocID));
                                                        break;
                                                    }
                                                }
                                                else { Game.SetError(new Error(156, "Invalid Loc (null) Enemy Goal not set")); }
                                            }
                                            else
                                            { Game.SetError(new Error(156, "Invalid LocID (zero or less) [at Capital] in ListOfNeighbours")); }
                                        }
                                    }
                                }
                                else
                                { Game.SetError(new Error(156, "Invalid branch value (default of -1)")); }
                            }
                            //valid destination found ? -> otherwise assign random neighbour
                            if (destinationLocID == 0)
                            {
                                destinationLocID = listNeighbours[rnd.Next(0, listNeighbours.Count)];
                                Game.logTurn?.Write(string.Format(" [Goal -> Alert] No valid destination found for {0}, ActID {1}. Assigned Random neighbour, {2}, LocID {3}", enemy.Name, enemy.ActID,
                                    GetLocationName(destinationLocID), destinationLocID));
                            }
                            //Move enemy
                            Location locMove = Game.network.GetLocation(destinationLocID);
                            if (locMove != null)
                            {
                                Position posDestination = locMove.GetPosition();
                                //List<Position> pathToTravel = Game.network.GetPathAnywhere(posOrigin, posDestination);
                                InitialiseMoveActor(enemy.ActID, posOrigin, posDestination);
                            }
                            else { Game.SetError(new Error(156, "Invalid locMove (null) Enemy isn't Moved")); }
                        }
                    }
                    else { Game.SetError(new Error(156, string.Format("Invalid playerLocID (zero or less), existing goal retained for actID {0}", enemy.ActID))); }
                }
                else { Game.SetError(new Error(156, string.Format("Invalid Enemy Location (null), for LocID {0}, Enemy ID {1}", enemy.LocID, enemy.ActID))); }
            }
            else { Game.SetError(new Error(156, "Invalid enemy input (null), existing goal retained")); }
        }


        /// <summary>
        /// checks Active Character when moving for presence of Enemy in same place
        /// <param name="charID">ActID of active character</param>
        /// <param name="pos">Current Position of active character</param>
        /// </summary>
        internal bool CheckIfFoundActive(Position pos, int charID)
        {
            int rndNum, threshold;
            bool found = false;
            int knownDM = 0; //modifier for search if active character known
            int onFootDM = 0; //modifier for search if player is travelling and on foot
            int known_revert = Game.constant.GetValue(Global.KNOWN_REVERT);
            int ai_known = Game.constant.GetValue(Global.AI_SEARCH_KNOWN);
            int ai_foot = Game.constant.GetValue(Global.AI_SEARCH_FOOT);
            int ai_hide = Game.constant.GetValue(Global.AI_SEARCH_HIDE);
            int ai_move = Game.constant.GetValue(Global.AI_SEARCH_MOVE);
            int ai_search = Game.constant.GetValue(Global.AI_SEARCH_SEARCH);
            int ai_wait = Game.constant.GetValue(Global.AI_SEARCH_WAIT);
            //active characters only
            Actor actor = GetAnyActor(charID);
            if (actor != null && actor.Status != ActorStatus.Gone && actor.Status != ActorStatus.Captured)
            {
                if (actor is Active)
                {
                    Active active = actor as Active;
                    //find player in any situation, find follower only if Known
                    if (active is Player || (active is Follower && active.Known == true))
                    {
                        Game.logTurn?.Write("--- CheckIfFoundActive (World.cs)");
                        foreach (var enemy in dictEnemyActors)
                        {
                            found = false;
                            Position posEnemy = enemy.Value.GetActorPosition();
                            if (posEnemy != null && pos != null)
                            {
                                //debug
                                Game.logTurn?.Write(string.Format(" [Search -> Debug] Enemy, {0}, ID {1} at {2}:{3}, Active {4}, ID {5}, at {6}:{7}", enemy.Value.Name, enemy.Value.ActID, posEnemy.PosX, posEnemy.PosY,
                                    active.Name, active.ActID, pos.PosX, pos.PosY));
                                if (posEnemy.PosX == pos.PosX && posEnemy.PosY == pos.PosY)
                                {
                                    //in same spot
                                    Game.logTurn?.Write(string.Format(" [Search -> Alert] {0} {1}, ActID {2}, is in the same place as Active {3}, ID {4}, (loc {5}:{6})", enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID,
                                        active.Name, active.ActID, pos.PosX, pos.PosY));
                                    //only search if enemy hasn't already searched for this actor this turn
                                    if (active.CheckSearchedOnList(enemy.Value.ActID) == false)
                                    {
                                        //add DM if actor Known
                                        if (active.Known == true) { knownDM = ai_known; }
                                        //add DM if Player and on foot (travelling)
                                        if (active is Player && active.Travel == TravelMode.Foot) { onFootDM = ai_foot; }
                                        rndNum = rnd.Next(100);
                                        threshold = 0;
                                        //chance varies depending on current enemy activity
                                        switch (enemy.Value.Goal)
                                        {
                                            case ActorAIGoal.Hide:
                                                threshold = ai_hide + knownDM;
                                                break;
                                            case ActorAIGoal.Move:
                                                threshold = ai_move + knownDM + onFootDM;
                                                break;
                                            case ActorAIGoal.Search:
                                                threshold = ai_search + knownDM ;
                                                break;
                                            case ActorAIGoal.Wait:
                                                threshold = ai_wait + knownDM;
                                                break;
                                        }
                                        if (rndNum < threshold) { found = true; }
                                        Game.logTurn?.Write(string.Format(" [SEARCH -> Active] Random {0} < {1} (ai {2} + known {3} + foot {4}) -> {5} ", rndNum, threshold, threshold - knownDM, knownDM,
                                            onFootDM, rndNum < threshold ? "Success" : "Fail"));
                                        //add to list of searched to prevent same enemy making multiple searches per turn
                                        if (active.AddSearched(enemy.Value.ActID) == true)
                                        { Game.logTurn?.Write(string.Format(" [Search -> ListSearched] {0} {1}, ActID {2} Searched -> Enemy ActID {3} added", active.Title, active.Name, active.ActID, enemy.Value.ActID)); }

                                        if (found == true)
                                        {
                                            string locName = GetLocationName(pos);
                                            if (String.IsNullOrEmpty(locName) == true) { locName = string.Format("Loc {0}:{1}", pos.PosX, pos.PosY); }
                                            Game.logTurn?.Write(string.Format(" [SEARCH -> Active] {0} {1} has been Spotted by {2}, ActID {3} at loc {4}:{5} -> Activated {6}", active.Title, active.Name, enemy.Value.Name,
                                                enemy.Value.ActID, pos.PosX, pos.PosY, enemy.Value.Activated));
                                            active.Found = true;
                                            Game.logTurn?.Write(string.Format(" [Search -> ListEnemy] {0} {1}, ActID {2} as Spotted -> True and Enemy ActID {3} added", active.Title, active.Name, active.ActID, enemy.Value.ActID));
                                            //Stuff that happens when found
                                            string description = "Unknown";
                                            int locID = Game.map.GetMapInfo(MapLayer.LocID, pos.PosX, pos.PosY);
                                            int refID = Game.map.GetMapInfo(MapLayer.RefID, pos.PosX, pos.PosY);
                                            //different outcomes for Player and Followers
                                            if (active is Player)
                                            {
                                                Player player = active as Player;
                                                //player has concealment
                                                if (player.Conceal > ActorConceal.None && enemy.Value.Activated == true)
                                                { CheckConcealment(); }
                                                //no concealment -> normal
                                                else
                                                {
                                                    //if unknown then becomes known
                                                    if (active.Known == false)
                                                    {
                                                        if (active.AddEnemy(enemy.Value.ActID, enemy.Value.Activated) == true)
                                                        {
                                                            active.Known = true; active.Revert = known_revert;
                                                            description = string.Format("{0} {1}, ActID {2}, has been Spotted by {3} {4}, ActID {5} at {6}", active.Title, active.Name, active.ActID,
                                                                enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID, locName);
                                                            Record record = new Record(description, active.ActID, locID, CurrentActorEvent.Known);
                                                            SetPlayerRecord(record);
                                                            SetMessage(new Message(description, MessageType.Search));
                                                        }
                                                    }
                                                    else if (active.Known == true)
                                                    {
                                                        if (active.CheckEnemyOnList(enemy.Value.ActID) == false)
                                                        {
                                                            //if already known then challenge/capture (But only if character hasn't already found player in the same turn -> must be another character)
                                                            if (active.AddEnemy(enemy.Value.ActID, enemy.Value.Activated) == true)
                                                            {
                                                                active.Revert = known_revert;
                                                                description = string.Format("{0} {1}, ActID {2}, has been Found by {3} {4}, ActID {5} at {6}", active.Title, active.Name, active.ActID,
                                                                        enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID, locName);
                                                                if (enemy.Value.Activated == true)
                                                                {
                                                                    //only activated enemies can capture (Inquisitors ae always activated, Nemesis only if the gods are angry)
                                                                    active.Capture = true;
                                                                }
                                                                Record record = new Record(description, active.ActID, locID, CurrentActorEvent.Search);
                                                                SetPlayerRecord(record);
                                                                SetMessage(new Message(description, MessageType.Search));
                                                            }
                                                            else
                                                            {
                                                                //enemy has already found Player this turn
                                                                Game.logTurn?.Write(string.Format(" [Search -> Previous] {0} {1}, ActID {2} has already Found Player this turn -> Result Cancelled", enemy.Value.Title,
                                                                    enemy.Value.Name, enemy.Value.ActID));
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (active is Follower)
                                            {
                                                //can only be captured (assumed to be Known)
                                                if (active.AddEnemy(enemy.Value.ActID, enemy.Value.Activated) == true)
                                                {

                                                    if (enemy.Value is Inquisitor)
                                                    {
                                                        active.Known = true; active.Revert = known_revert;
                                                        description = string.Format("{0} {1}, ActID {2}, has been Spotted by {3} {4}, ActID {5} at {6}", active.Title, active.Name, active.ActID,
                                                            enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID, locName);
                                                        Record record = new Record(description, active.ActID, locID, CurrentActorEvent.Search);
                                                        SetCurrentRecord(record);
                                                        SetMessage(new Message(description, MessageType.Search));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else { Game.logTurn?.Write(string.Format(" [Search -> Notification] {0} {1}, ActID {2} Already on List, no Search -> Enemy ActID {3}", active.Title, active.Name, active.ActID, enemy.Value.ActID)); }
                                }
                            }
                            else { Game.SetError(new Error(161, string.Format("Invalid Enemy (actID {0}) Pos (null) or Active (actID {1}) Pos (null)", enemy.Value.ActID, active.ActID))); }
                        }
                    }
                    else { Game.logTurn?.Write(string.Format(" [Search -> Notification] Invalid actor (NOT Player || NOT Follower && Known) {0}, ActID {1}", active.Name, active.ActID)); }
                }
            }
            else { Game.SetError(new Error(161, string.Format("Invalid actor (null or ActorStatus.Gone) charID \"{0}\", Status {1}", charID, actor.Status))); }
            return found;
        }

        /// <summary>
        /// checks Enemy Character when moving for presence of Active character in same place
        /// <param name="charID">ActID of Enemy character</param>
        /// <param name="pos">Current Position of Enemy character</param>
        /// </summary>
        internal bool CheckIfFoundEnemy(Position pos, int charID)
        {
            int rndNum, threshold;
            bool found = false;
            int known_revert = Game.constant.GetValue(Global.KNOWN_REVERT);
            int ai_known = Game.constant.GetValue(Global.AI_SEARCH_KNOWN);
            int ai_foot = Game.constant.GetValue(Global.AI_SEARCH_FOOT);
            int ai_hide = Game.constant.GetValue(Global.AI_SEARCH_HIDE);
            int ai_move = Game.constant.GetValue(Global.AI_SEARCH_MOVE);
            int ai_search = Game.constant.GetValue(Global.AI_SEARCH_SEARCH);
            int ai_wait = Game.constant.GetValue(Global.AI_SEARCH_WAIT);
            int knownDM = 0; //modifier for search if player known
            int onFootDM = 20; //modifier for search if player is travelling and on foot
            //get enemy
            Actor actor = GetAnyActor(charID);
            if (actor != null && actor.Status != ActorStatus.Gone)
            {
                if (actor is Enemy)
                {
                    Enemy enemy = actor as Enemy;
                    Game.logTurn?.Write("--- CheckIfFoundEnemy (World.cs)");
                    //loop Active Actors and check if in same position as enemy
                    foreach (var active in dictActiveActors)
                    {
                        found = false;
                        Position posActive = active.Value.GetActorPosition();
                        if (posActive != null && pos != null)
                        {
                            //find player in any situation, find follower only if Known
                            if (active.Value is Player && active.Value.Status != ActorStatus.Captured || (active.Value is Follower && active.Value.Known == true))
                            {
                                //debug
                                Game.logTurn?.Write(string.Format(" [Search -> Debug] Active {0}, ID {1} at {2}:{3}, Enemy at {4}:{5} ({6}, ID {7}", active.Value.Name, active.Value.ActID,
                                    posActive.PosX, posActive.PosY, pos.PosX, pos.PosY, enemy.Name, enemy.ActID));
                                if (posActive.PosX == pos.PosX && posActive.PosY == pos.PosY)
                                {
                                    //in same spot
                                    Game.logTurn?.Write(string.Format(" [Search -> Alert] {0} {1}, ActID {2}, is in the same place as the Enemy, loc {3}:{4} ({5}, ID {6})", active.Value.Title, active.Value.Name,
                                        active.Value.ActID, pos.PosX, pos.PosY, enemy.Name, enemy.ActID));
                                    //only search if enemy hasn't already searched for this actor this turn
                                    if (active.Value.CheckSearchedOnList(enemy.ActID) == false)
                                    {
                                        //figure out if spotted and handle disguise and safe house star reduction
                                        if (active.Value.Known == true) { knownDM = ai_known; }
                                        //add DM if Player and on foot (travelling)
                                        if (actor is Player && actor.Travel == TravelMode.Foot) { onFootDM = ai_foot; }
                                        rndNum = rnd.Next(100);
                                        threshold = 0;
                                        //chance depends on enemies current activity
                                        switch (enemy.Goal)
                                        {
                                            case ActorAIGoal.Hide:
                                                threshold = ai_hide + knownDM;
                                                break;
                                            case ActorAIGoal.Move:
                                                threshold = ai_move + knownDM + onFootDM;
                                                break;
                                            case ActorAIGoal.Search:
                                                threshold = ai_search + knownDM;
                                                break;
                                            case ActorAIGoal.Wait:
                                                threshold = ai_wait + knownDM;
                                                break;
                                        }
                                        if (rndNum < threshold)
                                        { found = true; }
                                        Game.logTurn?.Write(string.Format(" [SEARCH -> Active] Random {0} < {1} (ai {2} + known {3} + foot {4}) -> {5} ", rndNum, threshold, threshold - knownDM, knownDM,
                                            onFootDM, rndNum < threshold ? "Success" : "Fail"));
                                        //add to list of Searched to prevent same enemy making multiple search attempts on this actor per turn
                                        if (active.Value.AddSearched(enemy.ActID) == true)
                                        { Game.logTurn?.Write(string.Format(" [Search -> ListSearched] {0} {1}, ActID {2} Searched -> Enemy ActID {3} added", active.Value.Title, active.Value.Name, active.Value.ActID, enemy.ActID)); }

                                        if (found == true)
                                        {
                                            string locName = GetLocationName(pos);
                                            if (locName.Equals("Unknown") == true) { locName = string.Format("Loc {0}:{1}", pos.PosX, pos.PosY); } //travelling
                                            if (String.IsNullOrEmpty(locName) == true) { locName = string.Format("Loc {0}:{1}", pos.PosX, pos.PosY); }
                                            Game.logTurn?.Write(string.Format(" [SEARCH -> Enemy] {0} {1} has been Spotted by {2}, ActID {3} at {4} -> Activated {5}", active.Value.Title, active.Value.Name,
                                                enemy.Name, enemy.ActID, locName, enemy.Activated));
                                            active.Value.Found = true;
                                            Game.logTurn?.Write(string.Format(" [Search -> ListEnemies] {0} {1}, ActID {2} is Found -> True and Enemy ActID {3} added", active.Value.Title, active.Value.Name, active.Value.ActID, enemy.ActID));
                                            //Stuff that happens when found
                                            string description = "Unknown";
                                            int locID = Game.map.GetMapInfo(MapLayer.LocID, pos.PosX, pos.PosY);
                                            int refID = Game.map.GetMapInfo(MapLayer.RefID, pos.PosX, pos.PosY);
                                            if (active.Value is Player)
                                            {
                                                Player player = active.Value as Player;
                                                //player has concealment
                                                if (player.Conceal > ActorConceal.None && enemy.Activated == true)
                                                { CheckConcealment(); }
                                                //no concealment -> normal
                                                else
                                                {
                                                    //if unknown then becomes known
                                                    if (active.Value.Known == false)
                                                    {
                                                        if (active.Value.AddEnemy(enemy.ActID, enemy.Activated) == true)
                                                        {
                                                            active.Value.Known = true; active.Value.Revert = known_revert;
                                                            description = string.Format("{0} {1}, ActID {2}, has been Spotted by {3} {4}, ActID {5} at {6}", active.Value.Title, active.Value.Name,
                                                                active.Value.ActID, enemy.Title, enemy.Name, enemy.ActID, locName);
                                                            Record record = new Record(description, active.Value.ActID, locID, CurrentActorEvent.Known);
                                                            SetPlayerRecord(record);
                                                            SetMessage(new Message(description, MessageType.Search));
                                                        }
                                                    }
                                                    else if (active.Value.Known == true)
                                                    {
                                                        if (active.Value.CheckEnemyOnList(enemy.ActID) == false)
                                                        {
                                                            //if already known then challenge/capture (But only if character hasn't already found player in the same turn -> must be another character)
                                                            if (active.Value.AddEnemy(enemy.ActID, enemy.Activated) == true)
                                                            {
                                                                active.Value.Revert = known_revert;
                                                                description = string.Format("{0} {1}, ActID {2}, has been Found by {3} {4}, ActID {5} at {6}", active.Value.Title, active.Value.Name,
                                                                    active.Value.ActID, enemy.Title, enemy.Name, enemy.ActID, locName);
                                                                if (enemy.Activated == true)
                                                                {
                                                                    //only activated enemies can capture (Inquisitors are always activated, Nemesis only when gods are angry)
                                                                    active.Value.Capture = true;
                                                                }
                                                                Record record = new Record(description, active.Value.ActID, locID, CurrentActorEvent.Search);
                                                                SetPlayerRecord(record);
                                                                SetMessage(new Message(description, MessageType.Search));
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //enemy has already found player this turn
                                                            Game.logTurn?.Write(string.Format(" [Search -> Previous] {0} {1}, ActID {2} has previously Found the Player -> Result Cancelled", enemy.Title, enemy.Name,
                                                                enemy.ActID));
                                                        }
                                                    }
                                                }
                                            }
                                            else if (active.Value is Follower)
                                            {
                                                //can only be captured (assumed to be Known)
                                                if (active.Value.AddEnemy(enemy.ActID, enemy.Activated) == true)
                                                {
                                                    if (enemy is Inquisitor)
                                                    {
                                                        active.Value.Known = true; active.Value.Revert = known_revert; active.Value.Capture = true;
                                                        description = string.Format("{0} {1}, ActID {2}, has been Spotted by {3} {4}, ActID {5} at {6}", active.Value.Title, active.Value.Name, active.Value.ActID,
                                                            enemy.Title, enemy.Name, enemy.ActID, locName);
                                                        Record record = new Record(description, active.Value.ActID, locID, CurrentActorEvent.Search);
                                                        SetCurrentRecord(record);
                                                        SetMessage(new Message(description, MessageType.Search));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else { Game.logTurn?.Write(string.Format(" [Search -> Notification] {0} {1}, ActID {2} already on List, not Searched -> Enemy ActID {3}", active.Value.Title, active.Value.Name, active.Value.ActID, enemy.ActID)); }
                                }
                            }
                        }
                        else { Game.SetError(new Error(161, string.Format("Invalid Enemy (actID {0}) Pos (null) or Active (actID {1}) Pos (null)", enemy.ActID, active.Value.ActID))); }
                    }
                }
                else { Game.SetError(new Error(161, string.Format("Invalid actor (NOT Enemy) charID \"{0}\"", charID))); }
            }
            else { Game.SetError(new Error(161, string.Format("Invalid Enemy actor (null or ActorStatus.Gone) charID \"{0}\", Status {1}", charID, actor.Status))); }
            return found;
        }

        /// <summary>
        /// Checks Active actors who haven't moved to see if they have been found
        /// </summary>
        private void CheckStationaryActiveActors()
        {
            Game.logTurn?.Write("--- CheckStationaryActiveActors (World.cs)");
            //loop active actors 
            foreach (var actor in dictActiveActors)
            {
                if (actor.Value.Status == ActorStatus.AtLocation)
                {
                    Game.logTurn?.Write(string.Format(" [Search -> Stationary] {0} {1}, ActID {2} is AtLocation", actor.Value.Title, actor.Value.Name, actor.Value.ActID));
                    Position pos = actor.Value.GetActorPosition();
                    if (pos != null)
                    {
                        if (actor.Value is Player)
                        { CheckIfFoundActive(pos, actor.Value.ActID); }
                        else if (actor.Value is Follower)
                        {
                            //must be a Follower
                            if (actor.Value.Known == true)
                            { CheckIfFoundActive(pos, actor.Value.ActID); }
                        }
                        else { Game.SetError(new Error(162, string.Format("Unknown Actor type for \"{0} {1}\" ID {2}", actor.Value.Title, actor.Value.Name, actor.Value.ActID))); }
                    }
                }
                else { Game.logTurn?.Write(string.Format(" [Search -> Stationary] {0} {1}, ActID {2} is {3}", actor.Value.Title, actor.Value.Name, actor.Value.ActID, actor.Value.Status)); }
            }
        }

        /// <summary>
        /// handles all specific follower actions, returns a list of Snippets to World.UpdateWorldActivity (combined to generate notification message). Returns rumours only if Player at location.
        /// </summary>
        private List<Snippet> CheckFollowerActivity()
        {
            Game.logTurn?.Write("--- CheckFollowerActivity (World.cs)");
            int rumourID, refID;
            int numRumours = 0;
            RLColor backColor = Color._background4;
            List<Snippet> listData = new List<Snippet>();
            List<Snippet> listRumours = new List<Snippet>();
            //loop all active actors looking for followers
            foreach(var actor in dictActiveActors)
            {
                if (actor.Value is Follower)
                {
                    switch (actor.Value.Status)
                    {
                        case ActorStatus.AtLocation:
                            //get a rumour if in crow contact with player (any crow % > 0)
                            if (actor.Value.CrowChance > 0)
                            {
                                refID = ConvertLocToRef(actor.Value.LocID);
                                rumourID = Game.director.GetRumourUnknown(refID, actor.Value.ActID);
                                if (rumourID > 0)
                                {
                                    Rumour rumour = GetRumour(rumourID);
                                    if (rumour != null)
                                    {
                                        listRumours.Add(new Snippet(rumour.Text, RLColor.Black, backColor));
                                        listRumours.Add(new Snippet(""));
                                        AddRumourKnown(rumour.RumourID, rumour);
                                        numRumours++;
                                        Game.logTurn?.Write($"{actor.Value.Title} {actor.Value.Name}, ActID {actor.Value.ActID}, added RumourID {rumour.RumourID}");
                                        //handle special cases -> assumes that rumours are now known to the Player ('cause the Follower has auto sent a crow)
                                        Game.director.ResolveRumours(rumour);
                                        //if a timed rumour it'll need to be deleted from the dictionary
                                        if (rumour.Status == RumourStatus.Timed)
                                        { RemoveRumourTimed(rumourID); }
                                    }
                                    else { Game.SetError(new Error(276, $"Invalid rumour from RumourID {rumourID}")); }
                                }
                                else { Game.logTurn?.Write($"[Notification] No rumour returned for {actor.Value.Name} at {GetLocationName(actor.Value.LocID)}"); }
                            }
                            else { Game.logTurn?.Write($"{actor.Value.Title} {actor.Value.Name}, ActID {actor.Value.ActID}, has no contact with the Player -> No rumours"); }
                            break;
                    }
                }
            }
            //if rumours present add to master list
            if (numRumours > 0)
            {
                listData.Add(new Snippet(string.Format("Your Followers have overheard {0} rumour{1}", numRumours, numRumours != 1 ? "s" : ""), RLColor.Red, backColor));
                listData.Add(new Snippet(""));
                listData.AddRange(listRumours);
                listData.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                listData.Add(new Snippet(""));
            }
            return listData;
        }

        /// <summary>
        /// sub method to check a Player's concealment when spotted. Handles all details of Concealment changes.
        /// </summary>
        private void CheckConcealment()
        {
            Player player = GetPlayer();
            int refID = ConvertLocToRef(player.LocID);
            string lostText = "";
            //player not found but concealment level takes a hit
            player.ConcealLevel--;
            Game.logTurn?.Write($" [Search -> Concealment] Player has been spotted by an Enemy but their concealment keeps their presence hidden");
            //update concealment method
            switch (player.Conceal)
            {
                case ActorConceal.Disguise:
                    if (player.ConcealDisguise > 0)
                    {
                        Possession possession = GetPossession(player.ConcealDisguise);
                        if (possession != null)
                        {
                            if (possession is Disguise)
                            {
                                Disguise disguise = possession as Disguise;
                                disguise.Strength--;
                                //only show msg if remaining concealment otherwise just doubling up on msg's
                                if (disguise.Strength > 0)
                                {
                                    lostText = $"The disguise, {player.ConcealText}, has lost a level of concealment (now {disguise.Strength} stars)";
                                    Game.logTurn?.Write(lostText);
                                    SetMessage(new Message(lostText, MessageType.Search));
                                }
                                else
                                {
                                    //disguise revealed, no longer of any use
                                    player.ConcealDisguise = 0;
                                }
                            }
                            else { Game.SetError(new Error(251, $"Invalid possession type (not a disguise) for PossID {possession.PossID}")); }
                        }
                        else { Game.SetError(new Error(251, "Invalid Possession (null)")); }
                    }
                    else { Game.SetError(new Error(251, "Invalid player.ConcealDisguise (zero or less)")); }
                    break;
                case ActorConceal.SafeHouse:
                    House house = GetHouse(refID);
                    if (house != null)
                    {
                        house.SafeHouse--;
                        //only show msg if remaining concealment otherwise just doubling up on msg's
                        if (house.SafeHouse > 0)
                        {
                            lostText = $"{player.ConcealText} Safe House at {house.LocName} has lost a level of concealment (now {house.SafeHouse} stars)";
                            Game.logTurn?.Write(lostText);
                            SetMessage(new Message(lostText, MessageType.Search));
                        }
                    }
                    else { Game.SetError(new Error(251, "Invalid house (null)")); }
                    break;
                default:
                    Game.SetError(new Error(251, $"Unknown player.Conceal method \"{player.Conceal}\""));
                    break;
            }
            if (player.ConcealLevel <= 0)
            {
                //concealment has expired
                string expireText = $"The {player.Conceal} \"{player.ConcealText}\" has become known to the Enemy and no longer provides any benefit";
                Game.logTurn?.Write($" [Search -> Conceal] {expireText}");
                SetMessage(new Message(expireText, MessageType.Search));
                player.Conceal = ActorConceal.None;
                player.ConcealText = "None";
            }
        }

        /// <summary>
        /// Analyses map and sets up the desired part of the AI array (# enemies at capital and # enemies to allocate to each branch)
        /// </summary>
        private void InitialiseAI()
        {
            Game.logStart?.Write("--- InitialiseAI (World.cs)");
            int connectorBonus = Game.constant.GetValue(Global.AI_CONNECTOR);
            //work out branch priorities
            int numBranches = Game.network.GetNumBranches();
            int numLocs = Game.network.GetNumLocations() - 1; //ignore capital
            int[] arrayTemp = new int[5]; // (1 to 4 branches with 0 being Capital)
            //allocate # loc's to each branch
            int tempNumLocs = 0;
            for (int i = 1; i < arrayTemp.Length; i++)
            { arrayTemp[i] = Game.network.GetNumLocsByBranch(i); tempNumLocs += arrayTemp[i]; }
            //tallies match?
            if (tempNumLocs != numLocs)
            { Game.SetError(new Error(165, string.Format("Loc's don't tally (tempNumLocs (GetNumLocsByBranch) {0} numLocs (GetNumLocations) {1})", tempNumLocs, numLocs))); }
            //allow for connectors (provide more flexibility and make a branch more valuable to the enemy if present)
            int adjustedNumLocs = 0;
            for (int i = 1; i < arrayTemp.Length; i++)
            {
                if (Game.network.GetBranchConnectorStatus(i) == true)
                { arrayTemp[i] += connectorBonus; }
                adjustedNumLocs += arrayTemp[i];
            }
            //work out how many enemies should stay in the captial (normal operations)
            int totalEnemies = Game.constant.GetValue(Global.INQUISITORS);
            int enemiesInCapital = (int)Math.Round((double)(totalEnemies * Game.constant.GetValue(Global.AI_CAPITAL)) / 100);
            int remainingEnemies = totalEnemies - enemiesInCapital;
            //boundary check
            if (remainingEnemies == 0)
            {
                Game.SetError(new Error(165, "Invalid Remaining Enemies (Zero)"));
                remainingEnemies = 1; enemiesInCapital -= 1; enemiesInCapital = Math.Max(enemiesInCapital, 1);
            }
            arrayAI[1, 0] = enemiesInCapital;
            //assign the desired number of enemies to each relevant branch
            int percent, branchEnemies;
            int poolOfEnemies = remainingEnemies;
            for (int i = 1; i < arrayTemp.Length; i++)
            {
                percent = (int)Math.Round((double)(arrayTemp[i] * 100) / adjustedNumLocs);
                branchEnemies = (int)Math.Round((double)(remainingEnemies * percent) / 100);
                //check we aren't over allocating
                if (branchEnemies > poolOfEnemies)
                {
                    if (poolOfEnemies == 0)
                    {
                        if (enemiesInCapital > 0)
                        {
                            //move an enemy from Capital duty to branch duty
                            arrayAI[1, 0]--;
                        }
                        else { branchEnemies = 0; }
                    }
                    else { branchEnemies = poolOfEnemies; }
                }
                arrayAI[1, i] = branchEnemies;
                //track total number of allocated enemies
                poolOfEnemies -= branchEnemies;
            }
            //any unallocated actors get placed in the capital
            if (poolOfEnemies > 0)
            { arrayAI[1, 0] += poolOfEnemies; }
            //copy finalised data from range 1 to range 2 (temp data used for assigning enemies in InitialiseEnemyActors)
            for (int i = 0; i <= arrayAI.GetUpperBound(1); i++)
            { arrayAI[2, i] = arrayAI[1, i]; }
            //display arrayAI

            for (int i = 0; i <= arrayAI.GetUpperBound(1); i++)
            { Game.logStart?.Write(string.Format(" {0} {1} -> Current {2} -> Desired {3} -> adjusted Loc's {4}", i > 0 ? "Branch " : "Capital", i, arrayAI[0, i], arrayAI[1, i],
                arrayTemp[i])); }
        }

        /// <summary>
        /// tracks active and enemy actors at the start of each turn
        /// </summary>
        private void UpdateBloodHound()
        {
            BloodHound bloodhound = new BloodHound();
            //clear out temp lists
            listTempActiveActors.Clear();
            listTempEnemyActors.Clear();
            //active actors
            foreach (var active in dictActiveActors)
            {
                ActorSpy activeSpy = new ActorSpy(active.Value.ActID, active.Value.GetActorPosition(), active.Value.Status, active.Value.Known);
                listTempActiveActors.Add(activeSpy);
            }
            bloodhound.SetActiveActors(listTempActiveActors);
            //enemy actors
            foreach (var enemy in dictEnemyActors)
            {
                ActorSpy enemySpy = new ActorSpy(enemy.Value.ActID, enemy.Value.GetActorPosition(), enemy.Value.Status, enemy.Value.Known, enemy.Value.Goal, enemy.Value.HuntMode);
                listTempEnemyActors.Add(enemySpy);
            }
            bloodhound.SetEnemyActors(listTempEnemyActors);
            //add to dictionary
            try
            { dictBloodHound.Add(Game.gameTurn, bloodhound); }
            catch (ArgumentException)
            { Game.SetError(new Error(171, string.Format("Invalid gameTurn \"{0}\", (duplicate Entry) -> Bloodhound entry Not added", Game.gameTurn))); }
        }

        /// <summary>
        /// handles logistics when Player is captured
        /// </summary>
        /// <param name="actID"></param>
        /// <param name="enemyID">actID of enemy who captured the player</param>
        public void SetPlayerCaptured(int enemyID)
        {
            Game.logTurn?.Write("--- SetPlayerCaptured (World.cs)");
            string description, dungeonLoc;
            Player player = GetPlayer();
            if (player != null)
            {
                //player travelling when captured?
                if (player.Status == ActorStatus.Travelling)
                {
                    //loop list Move Objects and delete the Players
                    for (int i = 0; i < listMoveObjects.Count; i++)
                    {
                        Move moveObject = listMoveObjects[i];
                        if (moveObject.PlayerInParty == true)
                        {
                            Game.logTurn?.Write(string.Format(" [Capture -> Move Object] {0} {1}'s journey to {2} has been deleted", player.Title, player.Name, moveObject.GetDestination()));
                            listMoveObjects.RemoveAt(i);
                            break;
                        }
                    }
                }
                //change status
                player.Status = ActorStatus.Captured;
                player.DeathTimer = 20;
                Enemy enemy = GetEnemyActor(enemyID);
                if (enemy != null)
                {
                    if (enemy is Inquisitor)
                    {
                        //assign nearest major House / capital locID as the place where the player is held
                        int heldLocID = 0;
                        int tempRefID = 0;
                        int refID = 0;
                        if (player.LocID == 1) { tempRefID = 9999; Game.logTurn?.Write(" [Captured] dungeon -> Capital"); }
                        else
                        {
                            Location loc = Game.network.GetLocation(player.LocID);
                            if (loc != null)
                            {
                                //not at Capital -> At Major House?
                                House house = GetHouse(loc.RefID);
                                if (house != null)
                                {
                                    if ((house is MajorHouse) == false)
                                    {
                                        //find nearest Major house/Capital moving Inwards
                                        List<Route> routeToCapital = loc.GetRouteToCapital();
                                        List<Position> pathToCapital = routeToCapital[0].GetPath();
                                        int distIn = 0; int refIn = 0;
                                        for (int i = 0; i < pathToCapital.Count; i++)
                                        {
                                            Position pos = pathToCapital[i];
                                            if (pos != null)
                                            {
                                                refID = Game.map.GetMapInfo(MapLayer.RefID, pos.PosX, pos.PosY);
                                                if (refID > 0)
                                                {
                                                    if (refID == 9999 || refID < 100)
                                                    { refIn = refID; distIn = i; break; }
                                                }
                                            }
                                        }
                                        //find nearest Major house moving Outwards
                                        int branch = loc.GetBranch();
                                        List<Location> listBranchLocs = Game.network.GetBranchLocs(branch);
                                        int distOut = 0; int refOut = 0;
                                        int playerLocIndex = -1;
                                        if (listBranchLocs != null && listBranchLocs.Count > 0)
                                        {
                                            //loop through list and find player's current location
                                            for (int i = 0; i < listBranchLocs.Count; i++)
                                            {
                                                if (listBranchLocs[i].LocationID == player.LocID)
                                                { playerLocIndex = i; break; }
                                            }
                                            //found Player's loc in the list?
                                            if (playerLocIndex > -1)
                                            {
                                                //loop through branch list starting from player's current loc, moving outwards (redundantly start at player's current loc to avoid possible index overshoot)
                                                for (int i = playerLocIndex; i < listBranchLocs.Count; i++)
                                                {
                                                    House tempHouse = GetHouse(listBranchLocs[i].RefID);
                                                    if (tempHouse is MajorHouse)
                                                    {
                                                        //found the first Major House along
                                                        distOut = listBranchLocs[i].DistanceToCapital - loc.DistanceToCapital;
                                                        refOut = listBranchLocs[i].RefID;
                                                        //need to check the actual distance as it could be on a seperate branch and be much further than initially assumed
                                                        List<Route> route = Game.network.GetRouteAnywhere(loc.GetPosition(), listBranchLocs[i].GetPosition());
                                                        int checkDistance = Game.network.GetDistance(route);
                                                        if (checkDistance > distOut)
                                                        {
                                                            Game.logTurn?.Write(string.Format(" [Captured -> CheckDistance] distOut increased from {0} to {1}", distOut, checkDistance));
                                                            distOut = checkDistance;
                                                        }
                                                        break;
                                                    }
                                                }
                                            }
                                            else { Game.SetError(new Error(174, "Player's Loc not found in search through listBranchLocs.Search outwards Cancelled")); }
                                        }
                                        else { Game.SetError(new Error(174, "Invalid listBranchLocs (Null or Zero Count) Search outwards cancelled")); }
                                        //Compare in and out and find closest, favouring inwards (if equal distance)
                                        if (refIn > 0 && refOut == 0) { tempRefID = refIn; Game.logTurn?.Write(" [Captured] dungeon -> In (no out)"); }
                                        else if (refOut > 0 && refIn == 0) { tempRefID = refOut; Game.logTurn?.Write(" [Captured] dungeon -> Out (no in)"); }
                                        else if (distIn <= distOut) { tempRefID = refIn; Game.logTurn?.Write(" [Captured] dungeon -> In (distance <= out)"); }
                                        else if (distIn > distOut) { tempRefID = refOut; Game.logTurn?.Write(" [Captured] dungeon -> Out (distance < in)"); }
                                        else
                                        {
                                            Game.SetError(new Error(174, string.Format("Unable to get a valid dungeon loc, refIn -> {0} distIn -> {1} refOut -> {2} distOut -> {3}, default to Capital",
                                            refIn, distIn, refOut, distOut)));
                                        }
                                        Game.logTurn?.Write(string.Format(" [Captured -> Debug] refIn -> {0} distIn -> {1} refOut -> {2} distOut -> {3} tempRefID -> {4}",
                                            refIn, distIn, refOut, distOut, tempRefID));
                                    }
                                    else { Game.logTurn?.Write(" [Captured] Major House dungeon"); }
                                }
                                else { Game.SetError(new Error(174, string.Format("Invalid House returned (null) from player.LocID \"{0}\"", player.LocID))); }
                            }
                            else { Game.SetError(new Error(174, string.Format("Invalid Location returned (null) from player.LocID \"{0}\"", player.LocID))); }
                        }
                        //found a dungeon?
                        if (tempRefID > 0)
                        { heldLocID = ConvertRefToLoc(tempRefID); }
                        else { Game.logTurn?.Write("Unable to find a suitable location for Incarceration -> Default to KingsKeep"); heldLocID = 1; }
                        //update Player LocID (dungeon), set Known to true (should be already)
                        player.LocID = heldLocID;
                        player.Known = true;
                        dungeonLoc = GetLocationName(heldLocID);
                        //Player loses any items they possess (needs to be a reverse loop as you're deleting as you go
                        if (player.CheckItems() == true)
                        {
                            int possID;
                            List<int> tempItems = player.GetItems();
                            for (int k = tempItems.Count - 1; k >= 0; k--)
                            {
                                possID = tempItems[k];
                                if (player.RemoveItem(possID) == true)
                                {
                                    Item item = GetItem(possID);
                                    //admin
                                    description = string.Format("ItemID {0}, {1}, has been confiscated by the {2} Dungeon Master", item.ItemID, item.Description, dungeonLoc);
                                    SetMessage(new Message(description, MessageType.Incarceration));
                                    SetPlayerRecord(new Record(description, player.ActID, player.LocID, CurrentActorEvent.Challenge));
                                }
                            }
                        }
                        //Player loses a disguise if they have one
                        if (player.ConcealDisguise > 0)
                        {
                            description = $"The disguise, {player.ConcealText}, has been confiscated by the {dungeonLoc} Dungeon Master";
                            SetMessage(new Message(description, MessageType.Incarceration));
                            SetPlayerRecord(new Record(description, player.ActID, player.LocID, CurrentActorEvent.Challenge));
                            player.ConcealDisguise = 0;
                            player.Conceal = ActorConceal.None;
                            player.ConcealLevel = 0;
                            player.ConcealText = "";
                        }
                        //Player any most Resources they have
                        if (player.Resources > 1)
                        {
                            player.Resources = 1;
                            description = $"{player.Name} \"{player.Handle}\", has had most of their gold confiscated by the {dungeonLoc} Dungeon Master";
                            SetMessage(new Message(description, MessageType.Incarceration));
                            SetPlayerRecord(new Record(description, player.ActID, player.LocID, CurrentActorEvent.Challenge));
                        }
                        //administration
                        description = string.Format("{0} has been Captured by {1} {2}, ActID {3} and is to be held at {4}", player.Name, enemy.Title, enemy.Name, enemy.ActID, dungeonLoc);
                        SetMessage(new Message(description, MessageType.Search));
                        SetPlayerRecord(new Record(description, player.ActID, player.LocID, CurrentActorEvent.Search));
                        SetCurrentRecord(new Record(description, enemy.ActID, player.LocID, CurrentActorEvent.Search));
                    }
                    else if (enemy is Nemesis)
                    {
                        //Nemsis capturing Player logic goes here -> TODO
                    }
                }
                else { Game.SetError(new Error(174, "Invalid Enemy (null)")); }
            }
            else { Game.SetError(new Error(174, "Invalid Player (null)")); }
        }

        /// <summary>
        /// Places items within world
        /// </summary>
        private void InitialiseItemPlacement()
        {
            Game.logStart?.Write("--- InitialiseItemPlacement (World.cs)");
            //List of all Passive Items
            IEnumerable<Item> listItems =
                from items in dictPossessions.Values.OfType<Item>()
                where items.ItemType == PossItemType.Passive
                select items;
            List<Item> listPassiveItems = listItems.ToList();
            //get list of live Passive actors
            IEnumerable<Passive> listActors =
                from actors in dictPassiveActors
                where actors.Value.Status == ActorStatus.AtLocation && !(actors.Value is Special)
                select actors.Value;
            List<Passive> listPassiveActors = listActors.ToList();

            int rndIndex;
            int itemIndex;
            string startText;
            string endText;
            bool proceedFlag = true;
            //descriptive texts
            string[] arrayOfStartTexts = new string[] { "has been entrusted with keeping the", "has come into possession of the", "has stolen the", "is hording the" };
            string[] arrayOfEndTexts = new string[] { "safe from harm", "in mysterious circumstances", "and is desperate to keep it quiet", "safe from pyring eyes"  };
            //note that both Text arrays need to be identical lengths
            if (arrayOfStartTexts.Length != arrayOfEndTexts.Length)
            {
                proceedFlag = false;
                Game.SetError(new Error(235, "Text arrays have different lengths -> No secrets assigned"));
            }
            //assign all passive items to random actors
            for (int i = 0; i < listPassiveItems.Count; i++)
            {
                Item item = listPassiveItems[i];
                rndIndex = rnd.Next(listPassiveActors.Count);
                Passive passive = listPassiveActors[rndIndex];
                passive.AddItem(item.PossID);
                Game.logStart?.Write(string.Format("ItemID {0}, \"{1}\", given to {2} {3}, ActID {4}, at {5} {6}", item.ItemID, item.Description, passive.Title, passive.Name, passive.ActID,
                    GetLocationName(passive.LocID), GetLocationCoords(passive.LocID)));
                //item possession a secret? Not for a Lord (known)
                if (proceedFlag == true)
                {
                    if (passive.Type != ActorType.Lord)
                    {
                        itemIndex = rnd.Next(arrayOfStartTexts.Length);
                        startText = arrayOfStartTexts[itemIndex];
                        endText = arrayOfEndTexts[itemIndex];
                        string description = $"{passive.Name}, ActID {passive.ActID}, {startText} {item.Description}, ItemID {item.ItemID}, {endText}";
                        SecretActor secret = new SecretActor(PossSecretType.Item, Game.gameYear, description, 4, passive.ActID);
                        passive.AddSecret(secret.PossID);
                        AddPossession(secret.PossID, secret);
                        item.Active = false;
                        Game.logStart?.Write($"[Secret -> Item] {description}");
                    }
                    else { item.Active = true; }
                }
                listPassiveActors.RemoveAt(rndIndex);
            }

        }

        /// <summary>
        /// Set up a notification message (straight message, no user input). Will automatically add or append where necessary. Snippets should be pre-formatted
        /// </summary>
        /// <param name="notificationList"></param>
        public void SetNotification(List<Snippet> notificationList)
        {
            if (notificationList != null)
            {
                //take a list of snippets and set up ready to go. Might need to switch to special mode.
                if (notificationList.Count > 0)
                {
                    List<Snippet> eventList = new List<Snippet>();
                    RLColor backColor = Color._background1;
                    if (Game.infoChannel.GetListCount(ConsoleDisplay.Event) == 0)
                    {
                        //no existing records, create header
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("Hear Yea, Hear Yea, Hear Yea!", RLColor.Blue, backColor));
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                        eventList.Add(new Snippet(""));
                        eventList.AddRange(notificationList);
                        Game.infoChannel.SetInfoList(eventList, ConsoleDisplay.Event);
                    }
                    else
                    {
                        //existing records, append
                        foreach(Snippet snippet in notificationList)
                        { Game.infoChannel.AppendInfoList(snippet, ConsoleDisplay.Event);}
                    }
                    Game._specialMode = SpecialMode.Notification;
                }
                else { Game.SetError(new Error(223, "Invalid notificationList input (no records)")); }
            }
            else { Game.SetError(new Error(223, "Invalid notificationList input (null)")); }
        }

        /// <summary>
        /// Set up a confirmation message (message with Yes or No user input). Snippets should be pre-formatted. No appending takes place, one-shot only
        /// </summary>
        /// <param name="confirmationList"></param>
        public void SetConfirmation(List<Snippet> confirmationList)
        {
            if (confirmationList != null)
            {
                //take a list of snippets and set up ready to go. Might need to switch to special mode.
                if (confirmationList.Count > 0)
                {
                    List<Snippet> eventList = new List<Snippet>();
                    RLColor backColor = Color._background1;
                    //add new records
                    eventList.AddRange(confirmationList);
                    Game.infoChannel.ClearConsole(ConsoleDisplay.Event);
                    Game.infoChannel.SetInfoList(eventList, ConsoleDisplay.Event);
                    Game._specialMode = SpecialMode.Confirm;
                }
                else { Game.SetError(new Error(225, "Invalid confirmationList input (no records)")); }
            }
            else { Game.SetError(new Error(225, "Invalid confirmationList input (null)")); }
        }

        /// <summary>
        /// Updates world events and triggers a Notification message
        /// </summary>
        /// <returns></returns>
        private bool UpdateWorldStatus()
        {
            Game.logTurn?.Write("--- UpdateWorldStatus (World.cs)");
            bool notificationStatus = false;
            List<Snippet> eventList = new List<Snippet>();
            RLColor foreColor = RLColor.Black;
            RLColor backColor = Color._background1;
            //Follower Rumours
            eventList.AddRange(CheckFollowerActivity());
            //Player Rumours
            Player player = GetPlayer();
            if (player != null)
            {
                if (player.Conceal != ActorConceal.SafeHouse)
                {
                    switch (player.Status)
                    {
                        case ActorStatus.AtLocation:
                            //Market View
                            eventList.Add(new Snippet("The View from the Market", RLColor.Red, backColor));
                            eventList.Add(new Snippet(""));
                            eventList.AddRange(Game.director.GetMarketView());
                            eventList.Add(new Snippet(""));
                            break;
                        case ActorStatus.Travelling:
                            /*if (rnd.Next(100) < 20)
                            {
                                eventList.Add(new Snippet("The Word on the Road", RLColor.Red, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("A passing Merchant tells of trouble in the Court of Casterly Rock", foreColor, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                                eventList.Add(new Snippet(""));
                            }
                            break;*/
                        case ActorStatus.AtSea:
                            /*if (rnd.Next(100) < 20)
                            {
                                eventList.Add(new Snippet("The Word at Sea", RLColor.Red, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("The Captain tells tales of war in the far-off-lands", foreColor, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                                eventList.Add(new Snippet(""));
                            }
                            break;*/
                        case ActorStatus.Captured:
                            /*if (rnd.Next(100) < 20)
                            {
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("The Word in the Dungeon", RLColor.Red, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("You overhear a guard arguing with another prison about food shortages in the Castle", foreColor, backColor));
                                eventList.Add(new Snippet(""));
                                eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                                eventList.Add(new Snippet(""));
                            }*/
                            break;
                    }
                    //any world message to display?
                    if (eventList.Count > 0)
                    {
                        notificationStatus = true;
                        SetNotification(eventList);
                    }
                }
                else { Game.logTurn?.Write("[Notification] Player in SafeHouse -> World events cancelled"); }
            }
            else { Game.SetError(new Error(224, "Invalid player (null)")); }
            return notificationStatus;
        }


        /// <summary>
        /// Given an NPC's house, it works out another refID where the introduction can be used. 
        /// Randomly chooses from any other house where it has +rel's (first), if not then from houses with neutral relationships (zero)
        /// </summary>
        /// <param name="origRefID">RefID of house of NPC (assumed to be Major)</param>
        /// <returns></returns>
        public int GetIntroductionHouse(int origRefID)
        {
            int introRefID = 0; //introduction house (output)
            int refID = 0; //temp var
            int currentRel = 0;
            int searchRefID = origRefID; //searchRefID used for search
            //Bannerlord?
            if (origRefID > 100 && origRefID < 1000)
            { searchRefID = Game.world.GetLiegeLord(origRefID); }

            House npcHouse = GetHouse(searchRefID);
            List<int> listTempRefIDPositive = new List<int>(); //holds all Major houses where origHouse has +ve rel's (first choice for an introduction)
            List<int> listTempRefIDNeutral = new List<int>(); //holds all Major houses where origHouse has a neutral rel (second choice)
            Game.logTurn?.Write("--- GetIntroductionHouse (World.cs)");
            Player player = GetPlayer();
            if (player != null)
            {
                if (npcHouse != null)
                {
                    Game.logTurn?.Write($"Check Relations for House \"{npcHouse.Name}\" at {npcHouse.LocName}, RefID {searchRefID}");
                    //loop great Houses and get current relations
                    foreach (var house in dictMajorHouses)
                    {
                        refID = house.Value.RefID;
                        if (refID != searchRefID)
                        {
                            currentRel = npcHouse.GetCurrentRelationship(refID);
                            if (currentRel > 0)
                            {
                                listTempRefIDPositive.Add(refID);
                                Game.logTurn?.Write($"House \"{house.Value.Name}\" at {house.Value.LocName}, RefID {house.Value.RefID}, has a Rel level of +{currentRel} -> Added to List +ve's");
                            }
                            else if (currentRel == 0)
                            {
                                listTempRefIDNeutral.Add(refID);
                                Game.logTurn?.Write($"House \"{house.Value.Name}\" at {house.Value.LocName}, RefID {house.Value.RefID}, has a Rel level of {currentRel} -> Added to List Neutrals");
                            }
                            else { Game.logTurn?.Write($"House \"{house.Value.Name}\" at {house.Value.LocName}, RefID {house.Value.RefID}, has a Rel level of {currentRel} -> Ignored"); }
                        }
                    }
                    //Randomly choose one RefID from list of positive relations (first choice)
                    if (listTempRefIDPositive.Count > 0)
                    {
                        introRefID = listTempRefIDPositive[rnd.Next(listTempRefIDPositive.Count)];
                        player.AddIntroduction(introRefID);
                        Game.logTurn?.Write($"There are {listTempRefIDPositive.Count} records in listPositive to select from");
                        Game.logTurn?.Write($"House {GetHouseName(searchRefID)} has a Positive Relationship lvl with House \"{GetHouseName(introRefID)} -> Introduction Created");
                    }
                    //Look to list of houses with a neutral relationship as a second choice, if none with +ve rel's
                    else if (listTempRefIDNeutral.Count > 0)
                    {
                        introRefID = listTempRefIDNeutral[rnd.Next(listTempRefIDNeutral.Count)];
                        player.AddIntroduction(introRefID);
                        Game.logTurn?.Write($"There are {listTempRefIDNeutral.Count} records in listNeutral to select from");
                        Game.logTurn?.Write($"House {GetHouseName(searchRefID)} has a Neutral Relationship lvl with House \"{GetHouseName(introRefID)} -> Introduction Created");
                    }
                    else { Game.logTurn?.Write("[Alert] There are no Positive, or Neutral interHouse Relationships -> Introduction cancelled"); }
                }
                else { Game.SetError(new Error(240, $"Invalid npcHouse (null) for refID {searchRefID}")); }
            }
            else { Game.SetError(new Error(240, "Invalid player (null)")); }
            return introRefID;
        }

        /// <summary>
        /// Takes a BannerLord's RefID and returns the RefID of their Liege Lord. Returns '0' for an invalid conversion.
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        public int GetLiegeLord(int refID)
        {
            int liegeRefID = refID; //newRefID used for search
            //Bannerlord?
            if (refID > 100 && refID < 1000)
            {
                int houseID = ConvertRefToHouse(refID);
                if (houseID > 0)
                {
                    MajorHouse majorHouse = GetMajorHouse(houseID);
                    if (majorHouse != null)
                    {
                        //search on RefID of Bannerlord's liege Lord (introductions for a house are valid for Major and Minor houses)
                        liegeRefID = majorHouse.RefID;
                    }
                    else { Game.SetError(new Error(246, "Invalid MajorHouse (null) -> No conversion")); liegeRefID = 0; }
                }
                else { Game.SetError(new Error(246, "Invalid HouseID (zero, or less) -> No conversion")); liegeRefID = 0; }
            }
            else if (refID >= 1000)
            { Game.SetError(new Error(246, $"Invalid refID \"{refID}\" (too high) -> No conversion")); liegeRefID = 0; }
            return liegeRefID;
        }

        /// <summary>
        /// God Mode -> Change Player's known status to the opposite of whatever it is
        /// </summary>
        public List<Snippet> GodChangeKnownStatus()
        {
            Player player = GetPlayer();
            string text = "";
            List<Snippet> listText = new List<Snippet>();
            listText.Add(new Snippet("God Mode -> Change Player's Known Status", Color._godMode, RLColor.Black));
            if (player != null)
            {
                if (player.Known == true)
                {
                    //player becomes UNKNOWN
                    player.Known = false;
                    player.Revert = 0;
                    text = $"[God Mode] {player.Title} {player.Name} \"{player.Handle}\" Known Status changed to Unknown";
                    Game.world.SetMessage(new Message(text, MessageType.God));
                }
                else
                {
                    //player becomes KNOWN
                    player.Known = true;
                    player.Revert = Game.constant.GetValue(Global.KNOWN_REVERT);
                    player.TurnsUnknown = 0;
                    player.LastKnownLocID = player.LocID;
                    text = $"[God Mode] {player.Title} {player.Name} \"{player.Handle}\" Known Status changed to Known (reverts in {player.Revert} days)";
                    Game.world.SetMessage(new Message(text, MessageType.God));
                }
            }
            else { Game.SetError(new Error(248, "Invalid Player (null)"));}
            listText.Add(new Snippet(text));
            return listText;
        }


        /// <summary>
        /// Sets up Safe Houses at Game Start
        /// </summary>
        internal void InitialiseSafeHouses()
        {
            Game.logStart?.Write("--- InitialiseSafeHouse (World.cs)");
            int oldKingRefID = Game.lore.RoyalRefIDOld;
            int chanceSafeHouse = Game.constant.GetValue(Global.SAFE_HOUSE);
            //Major Houses
            for (int i = 0; i < dictAllHouses.Count; i++)
            {
                House house = dictAllHouses.ElementAt(i).Value;
                if (house != null)
                {
                    //supports old King -> automatically have a safe house and auto known
                    if (house.Loyalty_Current == KingLoyalty.Old_King && house.RefID != oldKingRefID )
                    {
                        if (house is MajorHouse)
                        {
                            //randomly allocate a safe house rating of between 3 and 5
                            house.SafeHouse = rnd.Next(3, 6);
                            Game.logStart?.Write($"House {house.Name} at \"{house.LocName}\" has a SafeHouse rating of {house.SafeHouse} stars");
                            house.SetInfoStatus(HouseInfo.SafeHouse);
                        }
                        else if (house is MinorHouse)
                        {
                            //randomly allocate a safe house rating of between 1 and 2
                            house.SafeHouse = rnd.Next(1, 3);
                            Game.logStart?.Write($"BannerLord House {house.Name} at \"{house.LocName}\" has a SafeHouse rating of {house.SafeHouse} stars");
                            house.SetInfoStatus(HouseInfo.SafeHouse);
                        }
                    }
                    //random chance of a safe house elsewhere (supporters of New King) -> Safe Houses not known about at game start (rumours)
                    else if (rnd.Next(100) <= chanceSafeHouse)
                    {
                        if (house is MajorHouse)
                        {
                            //randomly allocate a safe house rating of between 3 and 5
                            house.SafeHouse = rnd.Next(3, 6);
                            Game.logStart?.Write($"[Supports New King] House {house.Name} at \"{house.LocName}\" has a SafeHouse rating of {house.SafeHouse} stars -> Rumour created");
                        }
                        else if (house is MinorHouse)
                        {
                            //randomly allocate a safe house rating of between 1 and 2
                            house.SafeHouse = rnd.Next(1, 3);
                            Game.logStart?.Write($"[Supports New King] BannerLord House {house.Name} at \"{house.LocName}\" has a SafeHouse rating of {house.SafeHouse} stars -> Rumour created");
                        }
                    }
                }
                else { Game.SetError(new Error(249, "Invalid house (null)")); }
            }
        }


        /// <summary>
        /// Imports Disguises and seeds them with friendly advisors in the world
        /// </summary>
        internal void InitialiseDisguises()
        {
            Game.logStart?.Write("--- InitialiseDisguises (World.cs)");
            List<DisguiseStruct> listOfDisguises = Game.file.GetDisguises("Disguises.txt");
            int relThreshold = Game.constant.GetValue(Global.TALK_THRESHOLD);
            List<Advisor> listOfMaesters = new List<Advisor>();
            List<Advisor> listOfCastellans = new List<Advisor>();
            List<Advisor> listOfSeptons = new List<Advisor>();
            //Obtain a list of Friendly Noble Advisors
            IEnumerable<Advisor> advisorActors =
                from actors in dictPassiveActors.Values.OfType<Advisor>()
                where actors.advisorNoble > AdvisorNoble.None && actors.Status == ActorStatus.AtLocation && actors.Loyalty_Current == KingLoyalty.Old_King
                select actors;
            List<Advisor> listLoyalAdvisors = advisorActors.ToList();
            int numAdvisors = listLoyalAdvisors.Count();
            if (numAdvisors <= 0) { Game.SetError(new Error(259, "Invalid numAdvisors (zero) -> No disguises allocated within world")); }
            else { Game.logStart?.Write($"listLoyalAdvisors -> {numAdvisors} records"); }
            //loop advisors and assign to correct list
            foreach(var advisor in listLoyalAdvisors)
            {
                switch(advisor.advisorNoble)
                {
                    case AdvisorNoble.Maester:
                        listOfMaesters.Add(advisor);
                        break;
                    case AdvisorNoble.Castellan:
                        listOfCastellans.Add(advisor);
                        break;
                    case AdvisorNoble.Septon:
                        listOfSeptons.Add(advisor);
                        break;
                    default:
                        Game.SetError(new Error(259, $"Invalid advisorNoble type \"{advisor.advisorNoble}\" -> Advisor not placed in specailised list"));
                        break;
                }
            }
            //how many in each
            int countMaesters = listOfMaesters.Count; Game.logStart?.Write($"listOfMaesters -> {countMaesters} records");
            int countCastellans = listOfCastellans.Count; Game.logStart?.Write($"listOfCastellans -> {countCastellans} records");
            int countSeptons = listOfSeptons.Count; Game.logStart?.Write($"listOfSeptons -> {countSeptons} records");
            //loop through disguises
            foreach (var structDisguise in listOfDisguises)
            {
                //create instance of object
                Disguise disguise = new Disguise(structDisguise.Name, structDisguise.Strength);
                if (disguise != null)
                {
                    //add to Possessions dict
                    if (AddPossession(disguise.PossID, disguise) == true)
                    {
                        //assign to a random Advisor
                        if (numAdvisors > 0)
                        {
                            Advisor advisor = null;
                            switch (structDisguise.Type)
                            {
                                case AdvisorNoble.Maester:
                                    //prioritise giving disguise to a Maester
                                    if (countMaesters > 0)
                                    { advisor = listOfMaesters[rnd.Next(countMaesters)];  }
                                    break;
                                case AdvisorNoble.Castellan:
                                    //prioritise giving disguise to a Castellan
                                    if ( countCastellans > 0)
                                    { advisor = listOfCastellans[rnd.Next(countCastellans)]; }
                                    break;
                                case AdvisorNoble.Septon:
                                    //prioritise giving disguise to a Septon
                                    if (countSeptons > 0)
                                    { advisor = listOfSeptons[rnd.Next(countSeptons)]; }
                                    break;
                                default:
                                    Game.SetError(new Error(259, $"Invalid advisorNoble type \"{advisor.advisorNoble}\" -> Disguise not assigned to an Advisor"));
                                    break;
                            }
                            //found an advisor of the correct type?
                            if (advisor != null)
                            { advisor.AddDisguise(disguise.PossID); }
                            else
                            {
                                //if not then use another advisor from master list
                                advisor = listLoyalAdvisors[rnd.Next(numAdvisors)];
                                if (advisor != null)
                                { advisor.AddDisguise(disguise.PossID); }
                                else { Game.SetError(new Error(259, "Invalid advisor (null)")); }
                            }
                            //admin
                            if (advisor != null)
                            { Game.logStart?.Write($"{advisor.Title} {advisor.Name}, ActID {advisor.ActID} assigned Disguise \"{disguise.Description}\", PossID {disguise.PossID}"); }
                            else
                            { Game.logStart?.Write($"[Alert] Invalid advisor (null), Disguise \"{disguise.Description}\", PossID {disguise.PossID} Not placed in the world)"); }
                        }
                    }
                }
                else { Game.SetError(new Error(259, "Invalid disguise (null) -> not added to Dictionary")); }
            }
        }


        /// <summary>
        /// Toggles disguise on/off
        /// </summary>
        internal List<Snippet> ChangeDisguise()
        {
            Game.logTurn?.Write("--- ChangeDisguise (World.cs)");
            Player player = GetPlayer();
            List<Snippet> listToDisplay = new List<Snippet>();
            RLColor concealColor = RLColor.Yellow;
            string description = "";
            if (player != null)
            {
                if (player.ConcealDisguise > 0)
                {
                    Possession possession = GetPossession(player.ConcealDisguise);
                    if (possession is Disguise)
                    {
                        Disguise disguise = possession as Disguise;
                        switch (player.Conceal)
                        {
                            case ActorConceal.Disguise:
                                //remove disguise
                                description = $"{player.Name} \"{player.Handle}\" has removed their disguise of {disguise.Description}";
                                SetMessage(new Message(description, MessageType.Search));
                                SetPlayerRecord(new Record(description, 1, player.LocID, CurrentActorEvent.Search));
                                Game.logTurn?.Write(description);
                                player.Conceal = ActorConceal.None;
                                player.ConcealLevel = 0;
                                player.ConcealText = "None";
                                break;
                            case ActorConceal.SafeHouse:
                                //can't use disguises within a safe house
                                description = $"{player.Name} is currently at {player.ConcealText} SafeHouse and is unable to don a disguise";
                                concealColor = RLColor.LightRed;
                                break;
                            case ActorConceal.None:
                                //puts the disguise on
                                player.Conceal = ActorConceal.Disguise;
                                player.ConcealLevel = disguise.Strength;
                                player.ConcealText = disguise.Description;
                                description = $"{player.Name} \"{player.Handle}\" has assumed the disguise of {disguise.Description}";
                                SetMessage(new Message(description, MessageType.Search));
                                SetPlayerRecord(new Record(description, 1, player.LocID, CurrentActorEvent.Search));
                                //player becomes UNKNOWN, if already Known
                                if (player.Known == true)
                                {
                                    string knownText = $"{player.Name} \"{player.Handle}\" Known Status changed to Unknown as a result of assuming their Disguise";
                                    Game.world.SetMessage(new Message(knownText, MessageType.Search));
                                    player.Known = false;
                                    player.Revert = 0;
                                }
                                break;
                            default:
                                Game.SetError(new Error(253, $"Invalid player.Conceal type \"{player.Conceal}\""));
                                break;
                        }
                    }
                    else { Game.SetError(new Error(253, $"Invalid possession type (Not disguise) for player.ConcealDisguise PossID {player.ConcealDisguise}")); }
                }
                else
                {
                    description = "The Player doesn't have a disguise";
                    concealColor = RLColor.LightRed;
                    Game.logTurn?.Write($"[Alert] {description} (Player attempted to don a disguise");
                }
            }
            else { Game.SetError(new Error(253, "Invalid Player (null)")); }
            //set up snippet list
            if (description.Length > 0)
            { listToDisplay.Add(new Snippet(description, concealColor, RLColor.Black)); }
            else { listToDisplay.Add(new Snippet("Error in ChangeDisguise", RLColor.LightRed, RLColor.Black)); }
            return listToDisplay;
        }

        /// <summary>
        /// Sets the values of any GameVars at game start
        /// </summary>
        private void InitialiseGameVars()
        {
            Game.logTurn?.Write("--- InitialiseGameVars (World.cs)");
            int numOfMarketViews = 7;
            Game.variable.SetValue(GameVar.View_Index, rnd.Next(1, numOfMarketViews));
            Game.variable.SetValue(GameVar.View_Rollover, numOfMarketViews);
            Game.variable.SetValue(GameVar.Account_Timer, Game.constant.GetValue(Global.ACCOUNT_INTERVAL));
        }

        /// <summary>
        /// returns short string of Player's status and whereabouts
        /// </summary>
        /// <returns></returns>
        private string GetPlayerStatusReport()
        {
            Player player = GetPlayer();
            return $"{player.Title} {player.Name}, \"{player.Handle}\", {player.Status}, {GetLocationName(player.LocID)}";
        }

        /// <summary>
        /// returns a random Major house name
        /// </summary>
        /// <returns></returns>
        internal string GetRandomMajorHouseName()
        {
            int count = dictMajorHouses.Count;
            return dictMajorHouses.ElementAt(rnd.Next(count)).Value.Name;
        }

        /// <summary>
        /// assigns LocTypes to all Houses and Loc's
        /// </summary>
        private void InitialiseLocTypes()
        {
            int locID;
            foreach(var house in dictAllHouses)
            {
                locID = house.Value.LocID;
                Location loc = Game.network.GetLocation(locID);
                if (loc != null)
                {
                    if (house.Value is MajorHouse) { loc.Type = LocType.MajorHouse; house.Value.Type = LocType.MajorHouse; }
                    else if (house.Value is MinorHouse) { loc.Type = LocType.MinorHouse; house.Value.Type = LocType.MinorHouse; }
                    else if (house.Value is InnHouse) { loc.Type = LocType.Inn; house.Value.Type = LocType.Inn; }
                }
                else { Game.SetError(new Error(294, $"Invalid Loc (null), LocID \"{locID}\" -> LocType not assigned to house or Loc")); }
            }
        }

        /// <summary>
        /// Get list of Move objects
        /// </summary>
        /// <returns></returns>
        internal List<Move> GetMoveObjects()
        { return listMoveObjects; }

        /// <summary>
        /// Run from ProcessGameStart -> handles all the last minute player stuff
        /// </summary>
        private void InitialiseFinalPlayer()
        {
            Game.logTurn?.Write("--- InitialiseFinalPlayer (World.cs)");
            //Player's start location added to dict & list
            Player player = GetPlayer();
            Game.director.AddVisitedLoc(player.LocID, 0);
            //Horse
            GetNewHorse();
        }

        /// <summary>
        /// get Player a new horse and take care of all the details
        /// </summary>
        public void GetNewHorse()
        {
            Player player = Game.world.GetPlayer();
            if (player != null)
            {
                player.HorseName = Game.director.GetAssortedRandom(Assorted.HorseName);
                player.HorseType = Game.director.GetAssortedRandom(Assorted.HorseType);
                int health = rnd.Next(1, 10);
                health = Math.Min(5, Game.constant.GetValue(Global.HORSE_HEALTH)); //max capped at 5, min capped at 1
                player.HorseHealth = health;
                player.HorseMaxHealth = health;
                if (player.Status == ActorStatus.AtLocation) { player.horseStatus = HorseStatus.Stabled; }
                else { player.horseStatus = HorseStatus.Normal; }
                player.HorseDays = 1;
                player.SetTravelMode(TravelMode.Mounted);
                //admin
                string text = $"{player.Name} has acquired a new horse, a {player.HorseType} named \"{player.HorseName}\" (stamina {player.HorseHealth})";
                SetMessage(new Message(text, 1, player.LocID, MessageType.Horse));
                SetPlayerRecord(new Record(text, 1, player.LocID, CurrentActorEvent.Horse));
            }
        }

        /// <summary>
        /// create a new record of a dead/gone horse and add to list
        /// </summary>
        /// <param name="gone"></param>
        /// <param name="locText">descriptive -> 'On the road to...', 'At ....', etc.</param>
        internal void CreateHorseRecord(HorseGone gone, string locText)
        {
            if (gone != HorseGone.None)
            {
                if (String.IsNullOrEmpty(locText) == false)
                {
                    Player player = GetPlayer();
                    if (player != null)
                    {
                        HorseRecord horseRec = new HorseRecord();
                        horseRec.Name = player.HorseName;
                        horseRec.Type = player.HorseType;
                        horseRec.Health = player.HorseMaxHealth;
                        horseRec.Days = player.HorseDays;
                        horseRec.Gone = gone;
                        horseRec.Turn = Game.gameTurn;
                        horseRec.LocText = locText;
                        //add to list
                        listHorses.Add(horseRec);
                        Game.logTurn?.Write($"[Horse Record Added] \"{horseRec.Name}\" was {horseRec.Gone} {horseRec.LocText} on turn {horseRec.Turn}");
                    }
                    else { Game.SetError(new Error(301, "Invalid Player (null) -> No record created")); }
                }
                else { Game.SetError(new Error(301, "Invalid locText (null or MT) -> No record created")); }
            }
            else { Game.SetError(new Error(301, "Invalid HorseGone reason ('None') -> No record created")); }
        }

        /// <summary>
        /// gives houses population, Men At Arms, food data, resources and castle walls
        /// </summary>
        private void InitialiseHouseData()
        {
            Game.logStart?.Write("--- InitialiseHouseData (World.cs)");
            int timeSpan = Game.constant.GetValue(Global.GAME_REVOLT) - Game.constant.GetValue(Global.GAME_PAST);
            int timeBase = Game.constant.GetValue(Global.GAME_PAST);
            //Men at Arms drives all pop matters. Assumed to be 4 other people for every able bodied man
            int menAtArms = Game.constant.GetValue(Global.MEN_AT_ARMS);
            int popFactor = Game.constant.GetValue(Global.POPULATION_FACTOR);
            int foodCapacity = Game.constant.GetValue(Global.FOOD_CAPACITY);
            int goodsMinTerrain = Game.constant.GetValue(Global.GOODS_FACTOR); //number of terrain squares in 3 x 3 grid needed to qualify for a particular good
            int goodsLow = Game.constant.GetValue(Global.GOODS_LOW); //% chance of a low probability good being present
            int goodsMed = Game.constant.GetValue(Global.GOODS_MED); //% chance of a medium probability good being present
            int loanChance = Game.constant.GetValue(Global.LOAN_CHANCE); //% chance of new king taking on loans to make up a resource shortfall
            int food, balance, absBalance, tally, resources, numLocs, modifier, granary, stockFactor;
            int overallTally = 0;
            string descriptor;
            //
            // Men At Arms and Population (MenAtArms done earlier in InitialiseHouses due to need for data then but redo here with different stats if need be)
            //
            foreach (var house in dictAllHouses)
            {
                food = 0;
                if (house.Value is MajorHouse)
                {
                    house.Value.MenAtArms = menAtArms;
                    house.Value.Population = house.Value.MenAtArms * popFactor;
                }
                else if (house.Value is MinorHouse)
                {
                    house.Value.MenAtArms = menAtArms / 2;
                    house.Value.Population = house.Value.MenAtArms * popFactor;
                }
                else if (house.Value is CapitalHouse)
                {
                    house.Value.MenAtArms = menAtArms; //City Watch
                    house.Value.Population = house.Value.MenAtArms * popFactor * 3;
                }
                //
                //Goods & food production capacity
                //
                Location loc = Game.network.GetLocation(house.Value.LocID);
                if (loc != null)
                {
                    food = loc.NumPlain * foodCapacity;
                    food += loc.NumSea * foodCapacity / 2;
                    food += loc.NumForest * foodCapacity / 4;
                    house.Value.FoodCapacity = food;
                    Game.logStart?.Write($"House {house.Value.Name} at {house.Value.LocName} -> MenAtArms {house.Value.MenAtArms}, Population {house.Value.Population}, Food Capacity {house.Value.FoodCapacity}");
                    //Importer or Exporter of food if Abs(food balance) > foodCapacity
                    balance = house.Value.FoodCapacity - house.Value.Population;
                    //Food stockpile in granary? (higher chance if an ongoing food surplus)
                    if (balance > 0) { stockFactor = foodCapacity; } else { stockFactor = foodCapacity * 3; }
                    granary = (stockFactor - rnd.Next(0, foodCapacity / 1000 * 4) * 1000);
                    if (granary > 0)
                    {
                        house.Value.FoodStockpile = granary;
                        Game.logStart?.Write($"House {house.Value.Name} at {house.Value.LocName} has a food surplus (granary) of {granary}");
                        descriptor = $"There is food in the granary as a result of astute management and a productive previous season";
                        Record record = new Record(descriptor, house.Value.LocID, house.Value.RefID, Game.gameYear, HistHouseEvent.Food);
                        SetHistoricalRecord(record);
                    }
                    
                    descriptor = "";
                    if (Math.Abs(balance) > foodCapacity)
                    {
                        if (balance > 0)
                        {
                            house.Value.AddExport(Goods.Food); Game.logStart?.Write($"{house.Value.Name} Exports Food");
                            descriptor = "Fertile fields provide a surplus of food which is exported for a profit";
                        }
                        else
                        {
                            house.Value.AddImport(Goods.Food); Game.logStart?.Write($"{house.Value.Name} Imports Food");
                            descriptor = "A shortage of arable land creates a food shortfall which is made up by imports from elsewhere at a cost to the economy";
                        }
                        if (descriptor.Length > 0)
                        {
                            //add record to house
                            Record record = new Record(descriptor, house.Value.LocID, house.Value.RefID, timeBase + rnd.Next(timeSpan), HistHouseEvent.Food);
                            SetHistoricalRecord(record);
                        }
                    }
                    if (loc.NumMountain >= goodsMinTerrain)
                    {
                        //Iron -> Medium frequency
                        if (rnd.Next(100) <= goodsMed) { house.Value.AddExport(Goods.Iron); Game.logStart?.Write($"House {house.Value.Name} Exports Iron"); }
                        //Gold -> Low frequency
                        if (rnd.Next(100) <= goodsLow) { house.Value.AddExport(Goods.Gold); Game.logStart?.Write($"House {house.Value.Name} Exports Gold"); }
                    }
                    if (loc.NumForest >= goodsMinTerrain)
                    {
                        //Timber -> Medium frequency
                        if (rnd.Next(100) <= goodsMed) { house.Value.AddExport(Goods.Timber); Game.logStart?.Write($"House {house.Value.Name} Exports Timber"); }
                        //Furs -> Low frequency
                        if (rnd.Next(100) <= goodsLow) { house.Value.AddExport(Goods.Furs); Game.logStart?.Write($"House {house.Value.Name} Exports Furs"); }
                    }
                    //Oil -> Low frequency
                    if (loc.NumSea >= goodsMinTerrain)
                    { if (rnd.Next(100) <= goodsLow) { house.Value.AddExport(Goods.Oil); Game.logStart?.Write($"House {house.Value.Name} Exports Oil"); } }

                    if (loc.NumPlain >= goodsMinTerrain)
                    {
                        //Wine -> Low frequency
                        if (rnd.Next(100) <= goodsLow) { house.Value.AddExport(Goods.Wine); Game.logStart?.Write($"House {house.Value.Name} Exports Wine"); }
                        //Wool -> Low frequency
                        if (rnd.Next(100) <= goodsLow) { house.Value.AddExport(Goods.Wool); Game.logStart?.Write($"House {house.Value.Name} Exports Wool"); }
                    }
                }
                else { Game.SetError(new Error(303, $"Invalid loc (null) for house {house.Value.Name}")); }
            }
            //
            //Adjust resource levels to reflect trade goods situation (all start from a base level of 1)
            //
            int foodLimit = 2 * foodCapacity; //threshold for the effect of food surplus/deficit being small or large
            foreach (var house in dictAllHouses)
            {
                tally = 0;
                //take care of individual house first -> food (+/- 1/2 depending on severity of balance)
                balance = house.Value.GetFoodBalance();
                absBalance = Math.Abs(balance);
                if (absBalance > foodLimit )
                {
                    if (balance < 0) { tally -= 2; arrayTradeData[(int)Goods.Food] -= 1; }
                    else { tally += 2; arrayTradeData[(int)Goods.Food] += 1; }
                }
                //must be more than a minimum and less than the limit
                else if (absBalance <= foodLimit && absBalance > (foodCapacity/2))
                {
                    if (balance < 0) { tally -= 1; arrayTradeData[(int)Goods.Food] -= 1; }
                    else { tally += 1; arrayTradeData[(int)Goods.Food] += 1; }
                }
                //goods -> exports as food is the only import and it's already been catered for
                Goods good = Goods.None;
                if (house.Value.GetNumExports() > 0)
                {
                    int[,] tempGoods = house.Value.GetExports();
                    for(int i = 0; i < tempGoods.GetUpperBound(0); i++)
                    {
                        if (tempGoods[i, 0] > 0)
                        {
                            descriptor = "";
                            good = (Goods)i;
                            //different goods have different effects
                            switch (good)
                            {
                                case Goods.Gold:
                                    tally += 3;
                                    arrayTradeData[(int)Goods.Gold] += 1;
                                    descriptor = "Rich Veins of Gold mined from within the nearby mountains provide a significant boost to the economy";
                                    break;
                                case Goods.Wine:
                                    tally += 2;
                                    arrayTradeData[(int)Goods.Wine] += 1;
                                    descriptor = "Fine Wines made from high yielding Grapes provide a sizeable boost to the economy";
                                    break;
                                case Goods.Furs:
                                    tally += 1;
                                    arrayTradeData[(int)Goods.Furs] += 1;
                                    descriptor = "Thick Furs from the hunting and trapping of animals in the nearby forests provide a boost to the economy";
                                    break;
                                case Goods.Oil:
                                    tally += 1;
                                    arrayTradeData[(int)Goods.Oil] += 1;
                                    descriptor = "Oil distilled from the hunting of Whales provide a boost to the economy";
                                    break;
                                case Goods.Iron:
                                    tally += 1;
                                    arrayTradeData[(int)Goods.Iron] += 1;
                                    descriptor = "Deposits of Iron located in the nearby mountains provide a boost to the economy";
                                    break;
                                case Goods.Timber:
                                    tally += 1;
                                    arrayTradeData[(int)Goods.Timber] += 1;
                                    descriptor = "An abundance of Timer in the nearby Forests provide a boost to the economy";
                                    break;
                            }
                            if (descriptor.Length > 0)
                            {
                                //add record to house
                                Record record = new Record(descriptor, house.Value.LocID, house.Value.RefID, timeBase + rnd.Next(timeSpan), HistHouseEvent.Goods);
                                SetHistoricalRecord(record);
                            }
                        }
                    }
                }
                //keep tabs of overallTally
                overallTally += tally;
                //adjust house Resource level (allowable range of 1 to 5)
                resources = house.Value.Resources;
                resources += tally;
                resources = Math.Min(5, resources);
                resources = Math.Max(1, resources);
                house.Value.Resources = resources;
                Game.logStart?.Write($"House {house.Value.Name} has a Resource level of {resources}");
                //
                //adjust Castle walls to reflect resource level (properous houses are more likely to have stronger castles) -> Base value from Major/Minorhouse.txt's
                //
                if (house.Value.Special == HouseSpecial.None)
                {
                    int origValue = house.Value.CastleWalls;
                    descriptor = "";
                    switch (resources)
                    {
                        case 4:
                            //DM +1
                            house.Value.CastleWalls += 1;

                            break;
                        case 5:
                            //DM +2
                            house.Value.CastleWalls += 2;
                            break;
                    }
                    //limit check
                    house.Value.CastleWalls = Math.Min(5, house.Value.CastleWalls);
                    house.Value.CastleWalls = Math.Max(1, house.Value.CastleWalls);
                    if (origValue != house.Value.CastleWalls)
                    {
                        Game.logStart?.Write($"House {house.Value.Name} -> CastleWalls Now {house.Value.CastleWalls}, Before {origValue}, Resources {house.Value.Resources} ");
                        //add record to house
                        descriptor = "A strong economy has allowed the castle walls to be upgraded";
                        Record record = new Record(descriptor, house.Value.LocID, house.Value.RefID, timeBase + rnd.Next(timeSpan / 2, timeSpan), HistHouseEvent.Goods);
                        SetHistoricalRecord(record);
                    }
                }
            }
            //end all houses loop
            arrayTradeData[0] = overallTally;
            //Capital Resources
            CapitalHouse capital = GetCapital();
            if (capital != null)
            {
                resources = capital.Resources;
                numLocs = Game.network.GetNumLocations();
                resources = overallTally / numLocs;
                resources = Math.Min(5, resources);
                resources = Math.Max(1, resources);
                capital.Resources += resources;
                Game.logStart?.Write($"Capital has resources level of {capital.Resources}, overallTally {overallTally}, Locs {numLocs}, Modifier {overallTally / numLocs}");
                //Any loans taken out by new King?
                int deficit = 5 - capital.Resources;
                if (deficit > 0)
                {
                    for (int i = 0; i < deficit; i++)
                    {
                        if (rnd.Next(100) < loanChance)
                        {
                            //king takes on a loan
                            capital.Resources++;
                            Finance loan = (Finance)rnd.Next(1, (int)Finance.Count);
                            capital.AddLoan(loan);
                            Game.logStart?.Write($"The New King has taken on a Loan with the {loan}, Capital resources now {capital.Resources}");
                        }
                    }
                }
            }
            else { Game.SetError(new Error(303, "Invalid Capital (null) -> Resources not adjusted")); }
            //
            //Major House Resources -> adjusted for wealth of bannerLords -> + (total Bannerlord Resources - Num BannerLords) / 3
            //
            foreach(var major in dictMajorHouses)
            {
                modifier = 0;
                if (major.Value.GetNumBannerLords() > 0)
                {
                    List<int> listBannerLords = major.Value.GetBannerLords();
                    for (int i = 0; i < listBannerLords.Count; i++)
                    {
                        House bannerLord = GetHouse(listBannerLords[i]);
                        modifier += bannerLord.Resources;
                    }
                }
                if (modifier > 0)
                {
                    resources = major.Value.Resources;
                    resources += (modifier - major.Value.GetNumBannerLords()) / 3;
                    resources = Math.Min(5, resources);
                    major.Value.Resources = resources;
                    Game.logStart?.Write($"House {major.Value.Name}, Resources {resources}, Modifier {modifier}, Num BannerLords {major.Value.GetNumBannerLords()}");
                    //add record to house
                    descriptor = $"Bannerlords with valuable exports have provided a boost to the House {major.Value.Name} economy";
                    Record record = new Record(descriptor, major.Value.LocID, major.Value.RefID, timeBase + rnd.Next(timeSpan/2, timeSpan), HistHouseEvent.Goods);
                    SetHistoricalRecord(record);
                }
            }
            //
            // Capital Imports (all exports other than Capitals)
            //
            CapitalHouse capitalHouse = GetCapital();
            int existing;
            if (capitalHouse != null)
            {
                int[,] arrayCapitalImports = capitalHouse.GetImports();
                int[,] arrayCapitalExports = capitalHouse.GetExports();
                //should be of identical lengths (use GetUpperBound for both as apples for apples)
                if (arrayCapitalExports.GetUpperBound(0) == arrayTradeData.GetUpperBound(0))
                {
                    Game.logStart?.Write($"- Capital Imports");
                    for (int i = 1; i < arrayTradeData.Length; i++)
                    {
                        //all other house exports become capital imports
                        existing = arrayCapitalExports[i, 0];
                        arrayCapitalImports[i, 0] += arrayTradeData[i] - arrayCapitalExports[i, 0];
                        arrayCapitalImports[i, 0] = Math.Max(0, arrayCapitalImports[i, 0]);
                        Game.logStart?.Write($"{(Goods)i} x {arrayCapitalImports[i, 0]}");
                    }
                }
                else { Game.SetError(new Error(303, "Array lengths don't match, ArrayCapitalImports & arrayTradeData -> Capital Imports not calculated")); }
                //
                // Capital Groups -> initial relationship levels
                //
                int lower, upper;
                int kingWits = Game.lore.NewKing.GetSkill(SkillType.Wits);
                //adjust range of possible relationship levels by King's wits. Higher wits, tighter lower range, lower wits, wider lower range
                lower = 0 + (kingWits - 1) * 10;
                upper = 100;
                Game.logStart?.Write($"[Group Relations] King's Wits {kingWits}, Range -> lower {lower} to upper {upper}");
                for(int i = 2; i < (int)WorldGroup.Count; i++)
                { capitalHouse.SetGroupRelations((WorldGroup)i, rnd.Next(lower, upper)); }
                //Lords is the average of all Major Lords rels
                capitalHouse.SetGroupRelations(WorldGroup.Lords, GetAverageLordRelations());
                //
                // Relationships with Lender (actual if loans and possible future lenders)
                //
                for (int i = 1; i < (int)Finance.Count; i++)
                {
                    //capital.SetLenderRelations((Finance)i, rnd.Next(100)); 
                    capitalHouse.SetFinanceData(Account.Lender, i, rnd.Next(100));
                }
                //Merchant Guild relationship  same as King's relationship with Merchants
                int relLvl = capitalHouse.GetGroupRelations(WorldGroup.Merchants);
                capitalHouse.SetFinanceData(Account.Lender, (int)Finance.Merchant_Guild, relLvl);
            }
            else { Game.SetError(new Error(303, "Invalid capitalHouse (null)")); }

        }

        /// <summary>
        /// Gets Info for ShowFoodRL
        /// </summary>
        /// <param name="mode"></param>
        /// <returns></returns>
        public List<String> GetFoodInfo(FoodInfo mode)
        {
            int food, population, balance;
            List<string> tempList = new List<String>();
            switch (mode)
            {
                case FoodInfo.Surplus:
                    IEnumerable<string> surplusHouses =
                        from house in dictAllHouses
                        let surplus = house.Value.GetFoodBalance()
                        where surplus > 0
                        orderby surplus descending
                        select Convert.ToString($"House {house.Value.Name} at {house.Value.LocName}, {GetLocationCoords(house.Value.LocID)}, has a food Surplus of {surplus:N0}");
                    tempList = surplusHouses.ToList();
                    break;
                case FoodInfo.Deficit:
                    IEnumerable<string> deficitHouses =
                        from house in dictAllHouses
                        let deficit = house.Value.GetFoodBalance()
                        where deficit < 0
                        orderby deficit
                        select Convert.ToString($"House {house.Value.Name} at {house.Value.LocName}, {GetLocationCoords(house.Value.LocID)}, has a food Deficit of {deficit:N0}");
                    tempList = deficitHouses.ToList();
                    break;
                case FoodInfo.House:
                    Dictionary<int, int> tempHouseDict = new Dictionary<int, int>(); //key is RefId, value is surplus
                    foreach(var house in dictMajorHouses)
                    {
                        food = house.Value.FoodCapacity;
                        population = house.Value.Population;
                        List<int> listBanners = house.Value.GetBannerLords();
                        if (listBanners != null)
                        {
                            for (int i = 0; i < listBanners.Count; i++)
                            {
                                House bannerHouse = GetHouse(listBanners[i]);
                                if (bannerHouse != null)
                                {
                                    food += bannerHouse.FoodCapacity;
                                    population += bannerHouse.Population;
                                }
                                else { Game.SetError(new Error(304, $"Invalid bannerHouse RefID {listBanners[i]}")); }
                            }
                        }
                        else { Game.SetError(new Error(304, "Invalid listBanners (null)")); }
                        balance = food - population;
                        tempHouseDict.Add(house.Value.RefID, balance);
                    }
                    //add capital
                    CapitalHouse capital = GetCapital();
                    if (capital != null)
                    { tempHouseDict.Add(9999, capital.FoodCapacity - capital.Population); }
                    //sort dictionary by balance
                    var items = from foodBalance in tempHouseDict
                                orderby foodBalance.Value descending
                                select foodBalance;
                    //place into the list
                    foreach(var houseData in items)
                    { tempList.Add($"House {GetHouseName(houseData.Key)} has a food balance of {houseData.Value:N0}"); }
                    break;
                case FoodInfo.Branch:
                    Dictionary<int, int> tempBranchDict = new Dictionary<int, int>(); //key is BranchID, value is surplus
                    int[,] branchArray = new int[5, 2]; //x -> 0 Capital, 1 north, 2 east, 3 south, 4 west [x ,0] Population [x ,1] Food
                    foreach (var house in dictAllHouses)
                    {
                        switch(house.Value.Branch)
                        {
                            case 0:
                                branchArray[0, 0] += house.Value.Population;
                                branchArray[0, 1] += house.Value.FoodCapacity;
                                break;
                            case 1:
                                branchArray[1, 0] += house.Value.Population;
                                branchArray[1, 1] += house.Value.FoodCapacity;
                                break;
                            case 2:
                                branchArray[2, 0] += house.Value.Population;
                                branchArray[2, 1] += house.Value.FoodCapacity;
                                break;
                            case 3:
                                branchArray[3, 0] += house.Value.Population;
                                branchArray[3, 1] += house.Value.FoodCapacity;
                                break;
                            case 4:
                                branchArray[4, 0] += house.Value.Population;
                                branchArray[4, 1] += house.Value.FoodCapacity;
                                break;
                            default:
                                Game.SetError(new Error(304, $"Invalid BranchID {house.Value.Branch}"));
                                break;
                        }
                    }
                    //place branch data in dictionary
                    int upper = branchArray.GetUpperBound(0);
                    for(int i = 0; i <= upper; i++)
                    { tempBranchDict.Add(i, branchArray[i, 1] - branchArray[i, 0]); }
                    //sort dictionary
                    var branches = from branchBalance in tempBranchDict
                                orderby branchBalance.Value descending
                                select branchBalance;
                    //place into the list
                    foreach (var houseData in branches)
                    { tempList.Add($"Branch {houseData.Key} has a food balance of {houseData.Value:N0}"); }
                    break;
                default:
                    Game.SetError(new Error(304, $"Invalid mode \"{mode}\""));
                    break;
            }
            return tempList;
        }


        /// <summary>
        /// royal Scribes tally up the Kingdom's financial situation (used during gamestart and throughout game)
        /// </summary>
        internal void InitialiseRoyalAccounts()
        {
            if (Game.gameTurn == 0) { Game.logStart?.Write("--- InitialiseRoyalAccounts (World.cs)"); }
            else { Game.logTurn?.Write("--- InitialiseRoyalAccounts (World.cs)"); }
            CapitalHouse capital = GetCapital();
            bool status;
            int divisor = 15; //used to work out default tax rates based on initial relationships (slightly skewed to good relations & low tax rates)
            int balance = 0;
            int cashflow = 0;
            int tally, income, expense, trade, relLvl;
            int taxRate, budget; //taxRate for Income, budget for Expenses -> both work off director.cs Rate enum
            if (capital != null)
            {
                //Income ---

                int goldAmount = Game.constant.GetValue(Global.LOAN_AMOUNT);
                int importTax = Game.constant.GetValue(Global.IMPORT_TAX);
                int exportTax = Game.constant.GetValue(Global.EXPORT_TAX);
                int churchTax = Game.constant.GetValue(Global.CHURCH_TAX);
                int crafterTax = Game.constant.GetValue(Global.CRAFTER_TAX);
                int roadTax = Game.constant.GetValue(Global.ROAD_TAX);
                int harbourTax = Game.constant.GetValue(Global.HARBOUR_TAX);
                int virginTax = Game.constant.GetValue(Global.VIRGIN_TAX);

                //Treasury at game start (one gold LOAN_AMOUNT per level + random half level)
                if (Game.gameTurn == 0)
                {
                    for (int i = 0; i < capital.Resources; i++)
                    { balance += goldAmount; }
                    balance += rnd.Next(goldAmount / 2);
                    capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Treasury, balance);
                    capital.SetFinanceData(Account.FinSummary, (int)FinSummary.Balance, balance);
                    //set key data to active status
                    capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.Treasury, true);
                    capital.SetFinanceStatus(Account.FinSummary, (int)FinSummary.CashFlow, true);
                    capital.SetFinanceStatus(Account.FinSummary, (int)FinSummary.Balance, true);
                    Game.logTurn?.Write($"Initial Treasury {balance:N0}");
                }
                //current treasury = previous balance
                int previousBalance = capital.GetFinanceInfo(Account.FinSummary, (int)FinSummary.Balance, FinArray.Data);
                capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Treasury, previousBalance);

                // Import taxes (Lords) based on num and type of imports (include any exports from Capital in this) -> Food is excluded
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Lords)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Lords, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Lords, FinArray.Rate); }
                int[,] arrayOfImports = capital.GetImports();
                int[,] arrayOfExports = capital.GetExports();
                trade = GetValueOfGoods(arrayOfImports);
                trade += GetValueOfGoods(arrayOfExports);
                income = Convert.ToInt32(trade * importTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Lords, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Lords, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Lords, trade);
                capital.SetFinanceConstant(Account.Income, (int)Income.Lords, importTax);

                // Export taxes (Merchants) base on num and type of Exports (finished products, essentially identical to above) -> Food is excluded
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Merchants)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Merchants, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Merchants, FinArray.Rate); }
                income = Convert.ToInt32(trade * exportTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Merchants, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Merchants, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Merchants, trade);
                capital.SetFinanceConstant(Account.Income, (int)Income.Merchants, exportTax);

                // Church tax (fixed amount * # Churches in Major Houses + Capital, that varies depending on tax Rate)
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Churches)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Churches, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Churches, FinArray.Rate); }
                tally = 5 + GetNumMajorHouses();
                income = Convert.ToInt32(tally * churchTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Churches, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Churches, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Churches, tally);
                capital.SetFinanceConstant(Account.Income, (int)Income.Churches, churchTax);

                // Crafter tax (fixed amount * # of finished trade goods)
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Crafters)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Crafters, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Crafters, FinArray.Rate); }
                income = Convert.ToInt32(trade * crafterTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Crafters, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Crafters, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Crafters, trade);
                capital.SetFinanceConstant(Account.Income, (int)Income.Crafters, crafterTax);

                // Road tax (fixed amount * # of squares length of King's Road)
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Officials)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Roads, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Roads, FinArray.Rate); }
                tally = Game.map.KingsRoadLength;
                income = Convert.ToInt32(tally * roadTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Roads, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Roads, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Roads, tally);
                capital.SetFinanceConstant(Account.Income, (int)Income.Roads, roadTax);

                // Harbour tax (fixed amount per port in the Kingdom)
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Officials)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Harbours, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Harbours, FinArray.Rate); }
                tally = Game.network.GetNumPorts();
                income = Convert.ToInt32(tally * harbourTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Harbours, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Harbours, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Harbours, tally);
                capital.SetFinanceConstant(Account.Income, (int)Income.Harbours, harbourTax);

                // Virgin tax (fixed amount per two thousand population in the Kingdom)
                if (Game.gameAct == Act.One)
                {
                    relLvl = (100 - capital.GetGroupRelations(WorldGroup.Peasants)) / divisor;
                    taxRate = Math.Min(5, relLvl);
                    capital.SetFinanceRate(Account.Income, (int)Income.Virgins, taxRate);
                }
                else { taxRate = capital.GetFinanceInfo(Account.Income, (int)Income.Virgins, FinArray.Rate); }
                tally = GetWorldPopulation() / 2000;
                income = Convert.ToInt32(tally * virginTax * GetRate((Rate)taxRate));
                cashflow += income;
                if (income > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Income, (int)Income.Virgins, income);
                capital.SetFinanceStatus(Account.Income, (int)Income.Virgins, status);
                capital.SetFinanceReference(Account.Income, (int)Income.Virgins, tally);
                capital.SetFinanceConstant(Account.Income, (int)Income.Virgins, virginTax);

                //Expenses ---

                int cityWatchCost = Game.constant.GetValue(Global.CITYWATCH_COST);
                int officialsCost = Game.constant.GetValue(Global.OFFICIALS_COST);
                int defenceCost = Game.constant.GetValue(Global.DEFENSE_COST);
                int lifestyleCost = Game.constant.GetValue(Global.LIFESTYLE_COST);
                int loanCost = Game.constant.GetValue(Global.LOAN_COST);
                int foodCost = Game.constant.GetValue(Global.FOOD_COST);
                int essentialCost = Game.constant.GetValue(Global.ESSENTIAL_COST);
                int patrolCost = Game.constant.GetValue(Global.PATROL_COST);
                int pirateCost = Game.constant.GetValue(Global.PIRATE_COST);
                int inquisitorCost = Game.constant.GetValue(Global.INQUISITOR_COST);

                //City Watch  (MenAtArms at Capital / 2 * cost)
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.City_Watch_Wages, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.City_Watch_Wages, FinArray.Rate); }
                tally = capital.MenAtArms / 2 * cityWatchCost;
                expense = Convert.ToInt32(tally * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.City_Watch_Wages, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.City_Watch_Wages, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.City_Watch_Wages, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.City_Watch_Wages, cityWatchCost);

                //Officials (number of Major Houses + 5 for capital * cost) 
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Officials_Wages, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Officials_Wages, FinArray.Rate); }
                tally = 5 + GetNumMajorHouses();
                expense = Convert.ToInt32(tally * officialsCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Officials_Wages, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Officials_Wages, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Officials_Wages, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Officials_Wages, officialsCost);

                //Maintain Castle Defences (capital.CastleWalls * cost) 
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Capital_Defenses, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Capital_Defenses, FinArray.Rate); }
                tally = capital.CastleWalls;
                expense = Convert.ToInt32(tally * defenceCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Capital_Defenses, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Capital_Defenses, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Capital_Defenses, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Capital_Defenses, defenceCost);

                //Royal Lifestyle (12 - (Queen wits + kings wits) * cost) -> if Queen dead then King's wits x 2
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Royal_Lifestyle, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Royal_Lifestyle, FinArray.Rate); }
                int witsTally = Game.lore.NewKing.GetSkill(SkillType.Wits);
                if (Game.lore.NewQueen.Status != ActorStatus.Gone) { witsTally += Game.lore.NewQueen.GetSkill(SkillType.Wits); } else { witsTally *= 2; }
                tally = 12 - witsTally;
                expense = Convert.ToInt32(tally * lifestyleCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Royal_Lifestyle, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Royal_Lifestyle, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Royal_Lifestyle, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Royal_Lifestyle, lifestyleCost);

                //Loan interest (cost varies depending on who the loan was from -> Gold Bank is Normal, Merchant Guild is High and Goblin Bank is Excessive)
                List<Finance> listOfLoans = capital.GetLoans();
                expense = 0;
                int averageInterestRate = 0;
                int numLoans = listOfLoans.Count;
                if (numLoans > 0)
                {
                    for (int i = 0; i < numLoans; i++)
                    {
                        switch (listOfLoans[i])
                        {
                            case Finance.Gold_Bank: budget = (int)Rate.Normal; break;
                            case Finance.Merchant_Guild: budget = (int)Rate.High; break;
                            case Finance.Goblin_Bank: budget = (int)Rate.Excessive; break;
                            default:
                                Game.SetError(new Error(310, $"Invalid Loan type \"{listOfLoans[i]}\""));
                                break;
                        }
                        expense += Convert.ToInt32(loanCost * GetRate((Rate)budget));
                        averageInterestRate += budget;
                        cashflow -= expense;
                    }
                    averageInterestRate /= numLoans;
                }
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Loan_Interest, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Loan_Interest, status);
                capital.SetFinanceRate(Account.Expense, (int)Expense.Loan_Interest, averageInterestRate);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Loan_Interest, numLoans);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Loan_Interest, loanCost);

                //Food imports (kingdom food deficit / 2 * cost, not required if a food surplus) 
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Food_Imports, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Food_Imports, FinArray.Rate); }
                tally = GetWorldFoodBalance();
                if (tally < 0) { expense = Convert.ToInt32(Math.Abs(tally) / 2 *  foodCost * GetRate((Rate)budget)); cashflow -= expense; }
                else { expense = 0; }
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Food_Imports, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Food_Imports, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Food_Imports, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Food_Imports, foodCost);


                //Essential Goods Imports (must one each available of all goods except wine and gold, number of unique imported goods * cost)
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Essential_Goods, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Essential_Goods, FinArray.Rate); }
                int[,] arrayImports = capital.GetImports();
                int[,] arrayExports = capital.GetExports();
                int[] arrayGoods = new int[(int)Goods.Count];
                for (int i = 1; i < arrayGoods.Length; i++)
                {
                    //tally up number of goods 
                    if (arrayImports[i, 0] > 0) { arrayGoods[i]++; }
                    if (arrayExports[i, 0] > 0) { arrayGoods[i]++; }
                }
                //loop through looking for empty goods
                tally = 0;
                for (int i = 1; i < arrayGoods.Length; i++)
                {
                    //exclude luxury goods
                    if ((Goods)i != Goods.Wine && (Goods)i != Goods.Gold)
                    { if (arrayGoods[i] == 0) { tally++; } }
                }
                expense = Convert.ToInt32(tally * essentialCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Essential_Goods, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Essential_Goods, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Essential_Goods, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Essential_Goods, essentialCost);

                //Road Patrols (Length of King's road * cost) 
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Road_Patrols, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Road_Patrols, FinArray.Rate); }
                tally = Game.map.KingsRoadLength;
                expense = Convert.ToInt32(tally * patrolCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Road_Patrols, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Road_Patrols, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Road_Patrols, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Road_Patrols, patrolCost);

                //Pirate Patrol Subsidy (Number of ports * cost) 
                if (Game.gameTurn == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Pirate_Patrols, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Pirate_Patrols, FinArray.Rate); }
                tally = Game.network.GetNumPorts();
                expense = Convert.ToInt32(tally * pirateCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Pirate_Patrols, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Pirate_Patrols, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Pirate_Patrols, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Pirate_Patrols, pirateCost);

                //Inquisitors (Number of Inquisitors * cost) 
                if (Game.gameAct == 0)
                {
                    budget = rnd.Next(2, 5);
                    capital.SetFinanceRate(Account.Expense, (int)Expense.Inquisitors, budget);
                }
                else { budget = capital.GetFinanceInfo(Account.Expense, (int)Expense.Inquisitors, FinArray.Rate); }
                tally = 0;
                foreach (var enemy in dictEnemyActors)
                { if (enemy.Value is Inquisitor) { tally++; } }
                expense = Convert.ToInt32(tally * inquisitorCost * GetRate((Rate)budget));
                cashflow -= expense;
                if (expense > 0) { status = true; } else { status = false; }
                capital.SetFinanceData(Account.Expense, (int)Expense.Inquisitors, expense);
                capital.SetFinanceStatus(Account.Expense, (int)Expense.Inquisitors, status);
                capital.SetFinanceReference(Account.Expense, (int)Expense.Inquisitors, tally);
                capital.SetFinanceConstant(Account.Expense, (int)Expense.Inquisitors, inquisitorCost);

                //LumpSums & Summary ---

                //current treasury = previous balance
                balance = capital.GetFinanceInfo(Account.LumpSum, (int)LumpSum.Treasury, FinArray.Data);

                //Update previous corruption with recent corruption data (kept in FinArray.Reference)
                int previousData = capital.GetFinanceInfo(Account.LumpSum, (int)LumpSum.Corruption, FinArray.Reference);
                capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Corruption, previousData);
                int newData = 0; //to do -> latest corruption (provided as a positive number)
                newData *= -1;
                if (newData != 0)
                { balance += newData; capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.Corruption, true); }
                else { capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.Corruption, false); }
                capital.SetFinanceReference(Account.LumpSum, (int)LumpSum.Corruption, newData);
                if (Game.gameTurn == 0) { capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Corruption, newData); }

                //Update previous appropriations with recent appropriation data (kept in FinArray.Reference)
                previousData = capital.GetFinanceInfo(Account.LumpSum, (int)LumpSum.Appropriations, FinArray.Reference);
                capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Appropriations, previousData);
                newData = 0; //to do -> latest financial appropriations
                if (newData != 0)
                { balance += newData; capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.Appropriations, true); }
                else { capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.Appropriations, false); }
                capital.SetFinanceReference(Account.LumpSum, (int)LumpSum.Appropriations, newData);
                if (Game.gameTurn == 0) { capital.SetFinanceData(Account.LumpSum, (int)LumpSum.Appropriations, newData); }

                //Update previous loans with recent loan data (kept in FinArray.Reference)
                previousData = capital.GetFinanceInfo(Account.LumpSum, (int)LumpSum.New_Loans, FinArray.Reference);
                capital.SetFinanceData(Account.LumpSum, (int)LumpSum.New_Loans, previousData);
                newData = 0; //to do -> latest loans
                if (newData != 0)
                { balance += newData; capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.New_Loans, true); }
                else { capital.SetFinanceStatus(Account.LumpSum, (int)LumpSum.New_Loans, false); }
                capital.SetFinanceReference(Account.LumpSum, (int)LumpSum.New_Loans, newData);
                if (Game.gameTurn == 0) { capital.SetFinanceData(Account.LumpSum, (int)LumpSum.New_Loans, newData); }

                //update cashflow with current data
                capital.SetFinanceData(Account.FinSummary, (int)FinSummary.CashFlow, cashflow);
                balance += cashflow;
                //update Balance
                capital.SetFinanceData(Account.FinSummary, (int)FinSummary.Balance, balance);
                //admin
                SetMessage(new Message($"Royal Scribes have update the Kingdom Accounts to show a Balance of {balance:N0} gold coins", MessageType.Finance));
            }
            else { Game.SetError(new Error(310, "Invalid Capital (null) -> Royal Accounts not initialised")); }
        }

        /// <summary>
        /// returns multiplier for the Rate (taxRate or budget Rate)
        /// </summary>
        /// <param name="rate"></param>
        /// <returns></returns>
        private float GetRate(Rate rate)
        {
            float value = 0;
            switch (rate)
            {
                case Rate.Excessive:    value = 3;      break;
                case Rate.High:         value = 1.5f;   break;
                case Rate.Normal:       value = 1;      break;
                case Rate.Low:          value = 0.5f;   break;
                case Rate.Minimal:      value = 0.25f;  break;
            }
            return value;
        }

        /// <summary>
        /// returns expected income from taxing a particular income item at a given tax rate
        /// </summary>
        /// <param name="income"></param>
        /// <param name="rate"></param>
        /// <returns></returns>
        private int GetTaxableIncome(Income income, Rate rate)
        {
            int amount = 0;
            CapitalHouse capital = GetCapital();
            if (capital != null)
            {
                switch (income)
                {
                    case Income.Lords:
                    case Income.Merchants:
                    case Income.Crafters:
                        //calculate trade 
                        int[,] arrayOfImports = capital.GetImports();
                        int[,] arrayOfExports = capital.GetExports();
                        int trade = GetValueOfGoods(arrayOfImports);
                        trade += GetValueOfGoods(arrayOfExports);
                        //apply constant
                        switch (income)
                        {
                            case Income.Lords:
                                amount = trade * Game.constant.GetValue(Global.IMPORT_TAX);
                                break;
                            case Income.Merchants:
                                amount = trade * Game.constant.GetValue(Global.EXPORT_TAX);
                                break;
                            case Income.Crafters:
                                amount = trade * Game.constant.GetValue(Global.CRAFTER_TAX);
                                break;
                        }
                        break;
                    case Income.Churches:
                        int tally = 5 + GetNumMajorHouses();
                        amount = tally * Game.constant.GetValue(Global.CHURCH_TAX);
                        break;
                    case Income.Roads:
                        tally = Game.map.KingsRoadLength;
                        amount = tally * Game.constant.GetValue(Global.ROAD_TAX);
                        break;
                    case Income.Harbours:
                        tally = Game.network.GetNumPorts();
                        amount = tally * Game.constant.GetValue(Global.HARBOUR_TAX);
                        break;
                    case Income.Virgins:
                        tally = GetWorldPopulation() / 1000;
                        amount = tally * Game.constant.GetValue(Global.VIRGIN_TAX);
                        break;
                    default:
                        Game.SetError(new Error(318, $"Invalid Income \"{income}\" -> Default taxable income of Zero returned"));
                        break;
                }
                //adjust for tax rate
                amount = Convert.ToInt32(amount * GetRate((Rate)rate));
            }
            else { Game.SetError(new Error(318, "Invalid capital (null) -> default zero income returned")); }

            return amount;
        }

        /// <summary>
        /// returns expected cost from budgeting a particular expense item at a given rate
        /// </summary>
        /// <param name="expense"></param>
        /// <param name="budget"></param>
        /// <returns></returns>
        private int GetExpenseCost(Expense expense, Rate budget)
        {
            int tally = 0;
            CapitalHouse capital = GetCapital();
            if (capital != null)
            {
                switch (expense)
                {
                    case Expense.City_Watch_Wages:
                        tally = capital.MenAtArms / Game.constant.GetValue(Global.CITYWATCH_COST);
                        break;
                    case Expense.Capital_Defenses:
                        tally = capital.CastleWalls * Game.constant.GetValue(Global.DEFENSE_COST);
                        break;
                    case Expense.Officials_Wages:
                        tally = 5 + GetNumMajorHouses();
                        tally *= Game.constant.GetValue(Global.OFFICIALS_COST);
                        break;
                    case Expense.Royal_Lifestyle:
                        int witsTally = Game.lore.NewKing.GetSkill(SkillType.Wits);
                        if (Game.lore.NewQueen.Status != ActorStatus.Gone) { witsTally += Game.lore.NewQueen.GetSkill(SkillType.Wits); } else { witsTally *= 2; }
                        tally = (12 - witsTally) * Game.constant.GetValue(Global.LIFESTYLE_COST);
                        break;
                    case Expense.Loan_Interest:
                        //budget is ignored for loans as the cost depends on their interest rates which vary depending on the source of finance
                        List<Finance> listOfLoans = capital.GetLoans();
                        tally = 0;
                        int interestRate = 0;
                        int numLoans = listOfLoans.Count;
                        if (numLoans > 0)
                        {
                            for (int i = 0; i < numLoans; i++)
                            {
                                switch (listOfLoans[i])
                                {
                                    case Finance.Gold_Bank: interestRate = (int)Rate.Normal; break;
                                    case Finance.Merchant_Guild: interestRate = (int)Rate.High; break;
                                    case Finance.Goblin_Bank: interestRate = (int)Rate.Excessive; break;
                                    default:
                                        Game.SetError(new Error(310, $"Invalid Loan type \"{listOfLoans[i]}\""));
                                        break;
                                }
                                tally += Game.constant.GetValue(Global.LOAN_COST) * interestRate / 2;
                            }
                        }
                        break;
                    case Expense.Food_Imports:
                        int balance = GetWorldFoodBalance();
                        if (balance < 0) { tally = Math.Abs(balance) / Game.constant.GetValue(Global.FOOD_COST); }
                        else { tally = 0; }
                        break;
                    case Expense.Essential_Goods:
                        int[,] arrayImports = capital.GetImports();
                        int[,] arrayExports = capital.GetExports();
                        int[] arrayGoods = new int[(int)Goods.Count];
                        for (int i = 1; i < arrayGoods.Length; i++)
                        {
                            //add up number of goods 
                            if (arrayImports[i, 0] > 0) { arrayGoods[i]++; }
                            if (arrayExports[i, 0] > 0) { arrayGoods[i]++; }
                        }
                        //loop through looking for empty goods
                        for (int i = 1; i < arrayGoods.Length; i++)
                        {
                            //exclude luxury goods
                            if ((Goods)i != Goods.Wine && (Goods)i != Goods.Gold)
                            { if (arrayGoods[i] == 0) { tally++; } }
                        }
                        tally *= Game.constant.GetValue(Global.ESSENTIAL_COST);
                        break;
                    case Expense.Road_Patrols:
                        tally = Game.map.KingsRoadLength;
                        tally *= Game.constant.GetValue(Global.PATROL_COST);
                        break;
                    case Expense.Pirate_Patrols:
                        tally = Game.network.GetNumPorts();
                        tally *= Game.constant.GetValue(Global.PIRATE_COST);
                        break;
                    case Expense.Inquisitors:
                        foreach (var enemy in dictEnemyActors)
                        { if (enemy.Value is Inquisitor) { tally++; } }
                        tally *= Game.constant.GetValue(Global.INQUISITOR_COST);
                        break;
                    default:
                        Game.SetError(new Error(319, $"Invalid Expense \"{expense}\" -> default zero cost returned"));
                        break;
                }
                //adjust for budget rate 
                if (expense != Expense.Loan_Interest)
                { tally = Convert.ToInt32(tally * GetRate((Rate)budget)); }
            }
            else { Game.SetError(new Error(319, "Invalid capital (null) -> default zero cost returned")); }
            return tally;
        }

        /// <summary>
        /// Updates countdown timer and, if zero, resets and initiates a new set of Royal accounts
        /// </summary>
        private void CheckRoyalAccounts()
        {
            Game.logTurn?.Write("--- CheckRoyalAccounts (World.cs)");
            int timer = Game.variable.GetValue(GameVar.Account_Timer);
            timer--;
            Game.logTurn?.Write($"New Accounts tallied in {timer} days");
            if (timer > 0)
            { Game.variable.SetValue(GameVar.Account_Timer, timer); }
            else
            {
                //new set of accounts
                InitialiseRoyalAccounts();
                //reset timer
                Game.variable.SetValue(GameVar.Account_Timer, Game.constant.GetValue(Global.ACCOUNT_INTERVAL));
            }
        }

        /// <summary>
        /// private submethod to calculate the value of trade goods in capital (used for Imports/Exports). All goods are value 1 except wine being 2 and gold is worth 3. Food is excluded.
        /// </summary>
        /// <param name="tempGoods">arrayOfImports or arrayOfExports</param>
        /// <returns></returns>
        private int GetValueOfGoods(int[,] tempGoods)
        {
            Goods good;
            
            int total = 0;
            for (int i = 0; i < tempGoods.GetUpperBound(0); i++)
            {
                int tally = 0;
                if (tempGoods[i, 0] > 0)
                {
                    good = (Goods)i;
                    //different goods have different effects
                    switch (good)
                    {
                        case Goods.Gold:
                            tally += 3;
                            break;
                        case Goods.Wine:
                            tally += 2;
                            break;
                        case Goods.Furs:
                        case Goods.Oil:
                        case Goods.Iron:
                        case Goods.Timber:
                            tally += 1;
                            break;
                    }
                    total += tally * tempGoods[i, 0];
                }
            }
            return total;
        }

        /// <summary>
        /// Returns total world population
        /// </summary>
        /// <returns></returns>
        internal int GetWorldPopulation()
        {
            int population = 0;
            foreach (var house in dictAllHouses)
            { population += house.Value.Population; }
            return population;
        }

        /// <summary>
        /// Returns total world food capacity (ignores stockpiles)
        /// </summary>
        /// <returns></returns>
        internal int GetWorldFoodCapacity()
        {
            int capacity = 0;
            foreach (var house in dictAllHouses)
            { capacity += house.Value.FoodCapacity; }
            return capacity;
        }

        /// <summary>
        /// Returns total world food surplus / deficit (1 food feeds 1 person through winter)
        /// </summary>
        /// <returns></returns>
        internal int GetWorldFoodBalance()
        {
            int population = 0; int food = 0;
            foreach (var house in dictAllHouses)
            { population += house.Value.Population; food += house.Value.FoodCapacity; }
            return food - population;
        }

        /// <summary>
        /// End of Game Turn Game related housekeeping
        /// </summary>
        private void HousekeepGame()
        {
            //update Game timers
            Game.gameTurn++;
            Game.HarvestTimer--;
            Game.WinterTimer--;
            Game.SeasonTimer--;
            Game.PlantTimer--;
            //rollover timers
            if (Game.SeasonTimer <= 0) { Game.SeasonTimer = 360; Game.WinterTimer = 270; }
            if (Game.HarvestTimer == 0) { Game.HarvestTimer = 360; Game.PlantTimer = 35; }
            //determine season
            Game.UpdateSeason();
        }

        /// <summary>
        /// End of Game turn House related housekeeping
        /// </summary>
        private void HousekeepHouses()
        {
            Game.logTurn?.Write("--- HouseKeepHouses (world.cs)");
            //capital
            CapitalHouse capital = GetCapital();
            if (capital != null)
            {
                int lordRel = GetAverageLordRelations();
                //Lords is the average of all Major Lords rels
                capital.SetGroupRelations(WorldGroup.Lords, lordRel );
                Game.logTurn?.Write($"Average Lord Relations updated, now {lordRel}");
            }
            else { Game.SetError(new Error(311, "Invalid capital (null)")); }
        }


        internal int[] GetTradeData()
        { return arrayTradeData; }


        internal Dictionary<int, int> GetHousePower()
        { return dictHousePower; }


        internal List<HorseRecord> GetHorses()
        { return listHorses; }

        internal int GetNumMajorHouses()
        { return dictMajorHouses.Count; }

        /// <summary>
        /// Returns the average relationship value (0 - 100) with Lords from all Major Houses
        /// </summary>
        /// <returns></returns>
        public int GetAverageLordRelations()
        {
            int averageRel = 0;
            float totalRel = 0;
            float numLords = 0;
            foreach (var house in dictMajorHouses)
            {
                Passive lord = Game.world.GetPassiveActor(house.Value.LordID);
                if (lord != null)
                {
                    totalRel += (100 - lord.GetRelPlyr());
                    numLords++;
                }
                else { Game.SetError(new Error(308, $"Invalid Lord (null) from house.Value.LordID {house.Value.LordID}")); }
            }
            averageRel = Convert.ToInt32(totalRel / numLords);
            averageRel = Math.Min(100, averageRel);
            averageRel = Math.Max(0, averageRel);
            return averageRel;
        }

        //new Methods above here
    }
}