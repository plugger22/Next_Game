using System;
using System.Collections.Generic;
using Next_Game.Cartographic;
using System.Linq;
using RLNET;
using System.Diagnostics;

namespace Next_Game
{
    //handles living world for the game (data generated by History.cs at game start)
    public class World
    {
        static Random rnd;
        private List<Move> listMoveObjects; //actors moving through the world
        private List<ActorSpy> listTempActiveActors; //bloodhound temp lists
        private List<ActorSpy> listTempEnemyActors; //bloodhound temp lists
        private int[,] arrayAI; //'0' -> # enemies at capital, '1,2,3,4' -> # enemies patrolling each branch, [0,] -> actual, [1,] -> desired [2,] -> temp data
        private readonly Queue<Snippet> messageQueue; //short term queue to display recent messages
        private Dictionary<int, Active> dictActiveActors; //list of all Player controlled actors keyed off actorID (non-activated followers aren't in dictionary)
        private Dictionary<int, Passive> dictPassiveActors; //list of all NPC actors keyed of actorID
        private Dictionary<int, Enemy> dictEnemyActors; //list of all Enemy actors keyed of actorID
        private Dictionary<int, Special> dictSpecialActors; //list of all Special NPC actors -> key is SpecialID
        private Dictionary<int, Actor> dictAllActors; //list of all Actors keyed of actorID
        private Dictionary<int, MajorHouse> dictMajorHouses; //list of all Greathouses keyed off houseID
        private Dictionary<int, House> dictAllHouses; //list of all houses & special locations keyed off RefID
        private Dictionary<int, int> dictMajorHouseID; //list of Great Houses, unsorted (Key is House ID, value is # of bannerlords)
        private Dictionary<int, int> dictHousePower; // list of Great Houses, Sorted (key is House ID, value is # of bannerlords (power))
        private Dictionary<int, Record> dictHistoricalRecords; //all historical records (including Players) in a central collection (key is trackerID)
        private Dictionary<int, Record> dictCurrentRecords; //all current records (non-Player) in a central collection (key is trackerID)
        private Dictionary<int, Record> dictPlayerRecords; //all current Player records, (key is trackerID)
        private Dictionary<int, Message> dictMessages; //all Player to Game & Game to Player messages
        private Dictionary<int, GeoCluster> dictGeoClusters; //all GeoClusters (key is geoID)
        private Dictionary<int, Skill> dictTraits; //all triats (key is traitID)
        private Dictionary<int, Possession> dictPossessions; //all possession (key is PossID)
        private Dictionary<int, Passive> dictRoyalCourt; //advisors and royal retainers (assumed to always be at Kingskeep) excludes family
        private Dictionary<int, int> dictConvertLocToRef; //dictionary to convert LocID's to RefID's (key is LocID, value is RefID)
        private Dictionary<int, int> dictConvertRefToLoc; //dictionary to convert RefID's to LocID's (key is RefID, value is LocID)
        private Dictionary<int, BloodHound> dictBloodHound; //dictionary of all active & enemy actors movements (key is Turn #)

        //default constructor
        public World(int seed)
        {
            rnd = new Random(seed);
            listMoveObjects = new List<Move>();
            listTempActiveActors = new List<ActorSpy>();
            listTempEnemyActors = new List<ActorSpy>();
            arrayAI = new int[3, 5];
            messageQueue = new Queue<Snippet>();
            dictActiveActors = new Dictionary<int, Active>();
            dictPassiveActors = new Dictionary<int, Passive>();
            dictEnemyActors = new Dictionary<int, Enemy>();
            dictSpecialActors = new Dictionary<int, Special>();
            dictAllActors = new Dictionary<int, Actor>();
            dictMajorHouses = new Dictionary<int, MajorHouse>();
            dictAllHouses = new Dictionary<int, House>();
            dictMajorHouseID = new Dictionary<int, int>();
            dictHousePower = new Dictionary<int, int>();
            dictHistoricalRecords = new Dictionary<int, Record>();
            dictCurrentRecords = new Dictionary<int, Record>();
            dictPlayerRecords = new Dictionary<int, Record>();
            dictMessages = new Dictionary<int, Message>();
            dictGeoClusters = new Dictionary<int, GeoCluster>();
            dictTraits = new Dictionary<int, Skill>();
            dictPossessions = new Dictionary<int, Possession>();
            dictRoyalCourt = new Dictionary<int, Passive>();
            dictConvertLocToRef = new Dictionary<int, int>();
            dictConvertRefToLoc = new Dictionary<int, int>();
            dictBloodHound = new Dictionary<int, BloodHound>();
        }


        /// <summary>
        /// main method to initialise all world collections
        /// </summary>
        public void InitialiseWorld()
        {
            Game.logStart?.Write("--- InitialiseWorld (World.cs)");
            Stopwatch timer_2 = new Stopwatch();
            timer_2.Start();
            InitialiseGeoClusters();
            Game.StopTimer(timer_2, "W: InitialiseGeoClusters");
            timer_2.Start();
            InitialiseItems();
            InitialiseActiveActors(Game.history.GetActiveActors());
            Game.StopTimer(timer_2, "W: InitiatePlayerActors");
            timer_2.Start();
            InitialiseHouses();
            Game.StopTimer(timer_2, "W: InitialiseHouses");
            timer_2.Start();
            InitialiseTraits();
            Game.StopTimer(timer_2, "W: InitialiseTraits");
            timer_2.Start();
            //need to be here for sequencing issues
            Game.history.InitialiseOverthrow(dictPassiveActors);
            Game.history.InitialisePastHistoryHouses();
            Game.history.InitialiseLordRelations();
            Game.history.InitialiseSpecialCharacters(Game.file.GetCharacters("Characters.txt"));
            Game.StopTimer(timer_2, "W: InitialiseHistory");
            timer_2.Start();
            InitialiseSecrets();
            Game.StopTimer(timer_2, "W: InitialiseSecrets");
            timer_2.Start();
            InitialiseConversionDicts(); //needs to be after history methods (above) & before InitialiseEnemyActors
            InitialiseAI();
            InitialiseEnemyActors();
            InitialiseWorldDevelopment();
            Game.StopTimer(timer_2, "W: InitialiseAI");
        }

        /// <summary>
        /// Sets up actors in dictionaries and places them on the map.
        /// </summary>
        /// <param name="listOfActiveActors"></param>
        internal void InitialiseActiveActors(List<Active> listOfActiveActors)
        {

            int numFollowers = Game.constant.GetValue(Global.NUM_FOLLOWERS);
            int locID, index;

            for (int i = 0; i <= numFollowers; i++)
            {
                if (i > 0)
                {
                    //choose a random follower
                    index = rnd.Next(0, listOfActiveActors.Count);
                    Follower follower = (Follower)listOfActiveActors[index];
                    if (follower != null)
                    {
                        //remove from list
                        listOfActiveActors.RemoveAt(index);
                        //add to list and Dictionaries in World
                        SetActiveActor(follower);
                        //assign to random location on map
                        locID = Game.network.GetRandomLocation();
                        Location loc = Game.network.GetLocation(locID);
                        if (loc != null)
                        {
                            //place characters at Location
                            follower.LocID = locID;
                            follower.LastKnownLocID = locID;
                            follower.SetActorPosition(loc.GetPosition());
                            //set to activated
                            follower.Activated = true;
                            //add to Location list of Characters
                            loc.AddActor(follower.ActID);
                        }
                        else { Game.SetError(new Error(63, "Invalid Loc (null) Active Actor not placed on map")); }
                    }
                    else
                    { Game.SetError(new Error(63, "Invalid Actor in listOfActiveActors")); }
                }
                else
                {
                    //player (first in list)
                    Player player = (Player)listOfActiveActors[0];
                    if (player != null)
                    {
                        //player goes in first
                        SetActiveActor(player);
                        listOfActiveActors.RemoveAt(0);
                        //assign to random location on map -> EDIT: Already done in history.cs InitialisePlayer

                        //DEBUG ----
                        //Add an random, active, Item to the Player at game start that has a challenge effect
                        List<Possession> listPossessions = new List<Possession>(dictPossessions.Values);
                        List<Item> listItems = new List<Item>();
                        {
                            for (int k = 0; k < listPossessions.Count; k++)
                            {
                                Possession possObject = listPossessions[k];
                                if (possObject.Active == true && possObject is Item)
                                {
                                    Item itemObject = possObject as Item;
                                    if (itemObject.ChallengeFlag == true)
                                    { listItems.Add(itemObject); }
                                }
                            }
                        }
                        //randomly choose one item from list
                        if (listItems.Count > 0)
                        {
                            int rndIndex = rnd.Next(listItems.Count);
                            int itemID = listItems[rndIndex].PossID;
                            if (itemID > 0)
                            {
                                player.AddItem(itemID);
                                Game.logStart?.Write(string.Format("[Item] {0}, PossID {1}, ItemID {2} added to Player's Inventory", listItems[rndIndex].Description, listItems[rndIndex].PossID,
                                    listItems[rndIndex].ItemID));
                            }
                        }
                        //DEBUG---


                    }
                    else
                    { Game.SetError(new Error(63, "Invalid Player in listOfActiveActors")); }
                }
            }
        }

        /// <summary>
        /// set up inquisitors and any other enemies -> NOTE: must come AFTER InitialiseAI
        /// </summary>
        private void InitialiseEnemyActors()
        {
            Game.logStart?.Write("--- InitialiseEnemyActors (World.cs)");
            int numInquisitors = Game.constant.GetValue(Global.INQUISITORS);
            //loop for # of inquisitors
            for (int i = 0; i < numInquisitors; i++)
            {
                //create at capital
                Game.history.CreateInquisitor(1);
            }
            //create The Nemesis
            Game.history.CreateNemesis(1);
            //assign specific enemies to tasks (based on InitialiseAI)
            Game.logStart?.Write("- Assign Enemies");

            foreach (var enemy in dictEnemyActors)
            {
                enemy.Value.MoveOut = true;
                enemy.Value.HuntMode = false;
                if (enemy.Value is Nemesis)
                {
                    enemy.Value.AssignedBranch = 0;
                    Game.logStart?.Write(string.Format(" [Goal -> {0}] {1}, ActID {2} Branch -> {3}", enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID, enemy.Value.AssignedBranch));
                }
                else
                {
                    for (int i = 0; i <= arrayAI.GetUpperBound(1); i++)
                    {
                        if (enemy.Value is Inquisitor)
                        {
                            if (arrayAI[2, i] > 0)
                            {
                                enemy.Value.AssignedBranch = i;
                                arrayAI[2, i]--;
                                Game.logStart?.Write(string.Format(" [Goal -> {0}] {1}, ActID {2} Branch -> {3}", enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID, i));
                                break;
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Initiate character Movement (creates a Move object)
        /// </summary>
        /// <param name="charID">Character</param>
        /// <param name="posOrigin"></param>
        /// <param name="posDestination"></param>
        /// <param name="path">sequenced List of Positions to destination</param>
        internal string InitiateMoveActor(int charID, Position posOrigin, Position posDestination/*, List<Position> path*/)
        {
            Game.logTurn?.Write("--- InitiateMoveActor (World.cs)");
            string returnText = "Error in World.InitiateMoveCharacters";
            //viable Character & Position?
            if (charID > 0 && posOrigin != null && posDestination != null/* && path != null*/)
            {
                //find in dictionary
                if (dictAllActors.ContainsKey(charID))
                {
                    Game.logTurn?.Write("--- Move Actor (Director.cs)");
                    Actor person = dictAllActors[charID];
                    if (person != null)
                    {
                        if (person.Status == ActorStatus.AtLocation)
                        {
                            List<Position> path = Game.network.GetPathAnywhere(posOrigin, posDestination);
                            List<int> party = new List<int>(); //list of charID's of all characters in party
                            party.Add(charID);
                            string name = person.Name;
                            bool playerInParty = false;
                            if (charID == 1)
                            { playerInParty = true; }
                            int speed = person.Speed;
                            int distance = path.Count;
                            int time = (distance / speed) + 1; //prevents 0 result
                                                               //return string
                            string originLocation = GetLocationName(posOrigin);
                            string destinationLocation = GetLocationName(posDestination);
                            returnText = string.Format("{0} commences a {1} day journey from {2} to {3}", name, time, originLocation, destinationLocation);
                            //remove character from current location 
                            int locID_Origin = Game.map.GetMapInfo(MapLayer.LocID, posOrigin.PosX, posOrigin.PosY);
                            Location loc = Game.network.GetLocation(locID_Origin);
                            if (loc != null)
                            {
                                //check an existing Move object doesn't already exist, e.g if user issued > 1 move orders during a turn
                                //reverse loop, deleting any that contain the Player as you go
                                for (int i = listMoveObjects.Count - 1; i >= 0; i--)
                                {
                                    Move tempMove = listMoveObjects[i];
                                    if (tempMove.GetPrimaryCharacter() == charID)
                                    {
                                        Position pos = tempMove.GetCurrentPosition();
                                        Game.logTurn?.Write(string.Format("[Move -> Alert] Move Object DELETED PlayerInParty -> {0}, charID {1} at Loc {2}:{3}", tempMove.PlayerInParty, tempMove.GetPrimaryCharacter(),
                                            pos.PosX, pos.PosY));
                                        Active tempActive = Game.world.GetActiveActor(charID);
                                        if (tempActive != null)
                                        {
                                            Game.world.SetMessage(new Message(string.Format("{0} {1}'s journey to {2} has been cancelled", tempActive.Title, tempActive.Name, tempMove.GetDestination()),
                                              MessageType.Move));
                                        }
                                        else { Game.SetError(new Error(175, "Invalid Player (null)")); }
                                        listMoveObjects.RemoveAt(i);
                                    }
                                }
                                //housekeep all move tasks
                                loc.RemoveActor(charID);
                                //create new move object
                                Move moveObject = new Move(path, party, speed, playerInParty, Game.gameTurn);
                                //insert into moveList
                                listMoveObjects.Add(moveObject);
                                //update character status to 'travelling'
                                person.Status = ActorStatus.Travelling;
                                //update characterLocationID (now becomes destination)
                                int locID_Destination = Game.map.GetMapInfo(MapLayer.LocID, posDestination.PosX, posDestination.PosY);
                                person.LocID = locID_Destination;
                                //admin
                                SetMessage(new Message(returnText, person.ActID, locID_Destination, MessageType.Move));
                                int refID = GetRefID(locID_Destination);
                                if (charID == 1)
                                { Game.world.SetPlayerRecord(new Record(returnText, charID, locID_Destination, refID, CurrentActorIncident.Travel)); }
                                else if (charID > 1)
                                { Game.world.SetCurrentRecord(new Record(returnText, charID, locID_Destination, refID, CurrentActorIncident.Travel)); }
                                //show route (Player only)
                                if (playerInParty == true)
                                {
                                    Game.map.UpdateMap();
                                    Game.map.DrawRoutePath(path);
                                }
                            }
                            else
                            { returnText = "ERROR: The Journey has been cancelled (Destination not Found)"; }
                        }
                        else
                        {
                            //main error conditions
                            if (person.Status == ActorStatus.Travelling)
                            { Game.logTurn?.Write(string.Format("[Move -> Error] {0} {1}, ActID {2}, currently Travelling. Move Cancelled", person.Title, person.Name, person.ActID));
                                returnText = "ERROR: The Journey has been cancelled (Actor Travelling))"; }
                            else if (person.Status == ActorStatus.Captured)
                            { Game.logTurn?.Write(string.Format("[Move -> Error] {0} {1}, ActID {2}, currently Captured. Move Cancelled", person.Title, person.Name, person.ActID));
                                returnText = "ERROR: The Journey has been cancelled (Actor Captured))"; }
                            else if (person.Status == ActorStatus.Gone)
                            { Game.logTurn?.Write(string.Format("[Move -> Error] {0} {1}, ActID {2}, is Deceased. Move Cancelled", person.Title, person.Name, person.ActID));
                                returnText = "ERROR: The Journey has been cancelled (Actor Deceased))"; }
                            else
                            { Game.SetError(new Error(175, string.Format("{0} {1}, ActID {2} Status \"{3}\" Unknown. Move Cancelled", person.Title, person.Name, person.ActID, person.Status)));
                                returnText = "ERROR: The Journey has been cancelled (Actor Status Unknown)"; }
                        }
                    }
                    else { Game.SetError(new Error(175, "Invalid Actor (null) Move Cancelled")); returnText = "ERROR: The Journey has been cancelled (Actor not Found)"; }
                }
            }
            return returnText;
        }

        /// <summary>
        /// Handles movement of all Player characters througout world
        /// </summary>
        /// <returns>returns a dictionary of mapMarkers and coordinates for the "Movement" mapGrid layer</returns>
        internal Dictionary<int, Position> MoveActors()
        {
            //create a dictionary of position and map markers to return (passed up to game thence to map to update mapgrid
            Dictionary<int, Position> dictMapMarkers = new Dictionary<int, Position>();
            Game.logTurn?.Write(string.Format("--- MoveActors -> {0} Records (World.cs)", listMoveObjects.Count));
            //loop moveList. Update each move object - update Character Location ID
            for (int i = 0; i < listMoveObjects.Count; i++)
            {

                //get move object
                Move moveObject = listMoveObjects[i];
                //debug
                int actorID = moveObject.GetPrimaryCharacter();
                Actor actor = GetAnyActor(actorID);
                if (actor != null)
                {
                    Position pos = moveObject.GetCurrentPosition();
                    if (pos != null)
                    {
                        Game.logTurn?.Write(string.Format(" [Move -> MoveObject] {0} {1}, ActID {2} travelling to {3} (current Loc {4}:{5})", actor.Title, actor.Name, actor.ActID,
                            moveObject.GetDestination(), pos.PosX, pos.PosY));
                    }
                    else { Game.SetError(new Error(42, "Invalid pos (null) in actor console printout")); }
                }
                else { Game.SetError(new Error(42, "Invalid Actor (null) in actor console printout")); }
                //move speed clicks down list of positions (ignore locations at present)
                moveObject.UpdatePartyStatus();
                if (moveObject.Status == PartyStatus.Active)
                {
                    if (moveObject.MoveParty() == true)
                    {
                        //update location list at destination
                        Position posDestination = moveObject.GetCurrentPosition();
                        int locID = Game.map.GetMapInfo(MapLayer.LocID, posDestination.PosX, posDestination.PosY);
                        Location loc = Game.network.GetLocation(locID);
                        List<int> charListMoveObject = new List<int>(moveObject.GetCharacterList());
                        //find location, get list, update for each character
                        if (loc != null)
                        {
                            foreach (int charID in charListMoveObject)
                            {
                                loc.AddActor(charID);
                                //find character and update details
                                if (dictAllActors.ContainsKey(charID))
                                {
                                    Actor person = new Actor();
                                    person = dictAllActors[charID];
                                    person.Status = ActorStatus.AtLocation;
                                    person.SetActorPosition(posDestination);
                                    person.LocID = locID;
                                    int refID = GetRefID(locID);
                                    string tempText = string.Format("{0}, Aid {1}, has arrived safely at {2}", person.Name, person.ActID, loc.LocName);
                                    Message message = new Message(tempText, person.ActID, loc.LocationID, MessageType.Move);
                                    SetMessage(message);
                                    if (person.ActID == 1)
                                    { SetPlayerRecord(new Record(tempText, person.ActID, person.LocID, refID, CurrentActorIncident.Travel)); }
                                    else if (person.ActID > 1)
                                    { SetCurrentRecord(new Record(tempText, person.ActID, person.LocID, refID, CurrentActorIncident.Travel)); }
                                    //enemy -> arrives at destination, assign goal
                                    if (person is Enemy)
                                    {
                                        Enemy enemy = person as Enemy;
                                        if (enemy.HuntMode == true) { enemy.Goal = ActorGoal.Search; }
                                        else { enemy.Goal = ActorGoal.Wait; }
                                        Game.logTurn?.Write(string.Format(" [Goal -> Arrival] {0} {1}, ActID {2}, currently at {3}, new Goal -> {4}", enemy.Title, enemy.Name, enemy.ActID, loc.LocName, enemy.Goal));
                                    }
                                }
                                else
                                { Game.SetError(new Error(42, "Character not found")); }
                            }
                        }
                        else
                        { Game.SetError(new Error(42, "Character not found")); }
                        //update Party status to enable deletion of moveObject from list (below)
                        moveObject.Status = PartyStatus.Done;
                    }
                    else
                    //still enroute
                    {
                        //update dictionary
                        try
                        { dictMapMarkers.Add(moveObject.MapMarker, moveObject.GetCurrentPosition()); }
                        catch (ArgumentException)
                        { Game.SetError(new Error(42, "Error adding to dictMapMarkers (duplicate key -> Normal)")); }
                        //update Characters in list (charPos)
                        Position pos = moveObject.GetCurrentPosition();
                        List<int> characterList = new List<int>(moveObject.GetCharacterList());
                        for (int j = 0; j < characterList.Count; j++)
                        {
                            int charID = characterList[j];
                            //find in dictionary
                            if (dictAllActors.ContainsKey(charID))
                            {
                                Actor person = dictAllActors[charID];
                                person.SetActorPosition(pos);
                            }
                        }
                    }
                }
                else if (moveObject.Status == PartyStatus.Delayed)
                {
                    /*message about delay?*/
                    try
                    { dictMapMarkers.Add(moveObject.MapMarker, moveObject.GetCurrentPosition()); }
                    catch (ArgumentException)
                    { Game.SetError(new Error(42, "Error adding to dictMapMarkers (duplicate key -> Delayed)")); }
                }
            }
            //reverse loop through list of Moveobjects and delete any that are marked as 'Done'
            for (int i = listMoveObjects.Count; i > 0; i--)
            {
                if (listMoveObjects[i - 1].Status == PartyStatus.Done)
                {
                    try
                    { listMoveObjects.RemoveAt(i - 1); }
                    catch (Exception e)
                    { Game.SetError(new Error(61, e.Message)); }
                }
            }
            //pass dictionary of markers back to map object via Game
            return dictMapMarkers;
        }


        /// <summary>
        /// Returns a list of characters in string format to pass to InfoChannel to display in multi-Console
        /// </summary>
        /// <returns>List with info on each character a single, sequential, entry in the list</returns>
        /// <param name="locationsOnly">If true only show those at Locations, default is show all</param>
        public List<Snippet> ShowActiveActorsRL(bool locationsOnly = false)
        {
            List<Snippet> listToDisplay = new List<Snippet>();
            listToDisplay.Add(new Snippet("--- Player Characters", RLColor.Yellow, RLColor.Black));
            int chance, locID;
            ActorStatus status;
            string locName, coordinates, distText, crowText;
            string locStatus = "who knows?";
            string charString; //overall string
            RLColor textColor = RLColor.White;
            //loop actors
            foreach (var actor in dictActiveActors)
            {
                status = actor.Value.Status;
                //ignore dead actors
                if (status != ActorStatus.Gone)
                {
                    locID = actor.Value.LocID;
                    locName = GetLocationName(locID);
                    switch (status)
                    {
                        case ActorStatus.AtLocation:
                            locStatus = $"At {locName}";
                            break;
                        case ActorStatus.Travelling:
                            locStatus = $"Moving to {locName}";
                            break;
                        case ActorStatus.AtSea:
                            locStatus = string.Format("On a ship to {0}, arriving in {1} day{2}", locName, actor.Value.VoyageTimer, actor.Value.VoyageTimer != 1 ? "s" : "");
                            break;
                        case ActorStatus.Adrift:
                            locStatus = string.Format("Adrift in {0}. Survival time {1} day{2}", actor.Value.SeaName, actor.Value.DeathTimer, actor.Value.DeathTimer != 1 ? "s" : "");
                            break;
                        case ActorStatus.Captured:
                            locStatus = string.Format("Held at {0}. Survival time {1} day{2}", locName, actor.Value.DeathTimer, actor.Value.DeathTimer != 1 ? "s" : "");
                            break;
                    }
                    /*//get location coords
                    Location loc = Game.network.GetLocation(locID);*/
                    //only show chosen characters (at Location or not depending on parameter)
                    if (locationsOnly == true && status == ActorStatus.AtLocation || !locationsOnly)
                    {
                        Position pos = actor.Value.GetActorPosition();
                        coordinates = string.Format("(Loc {0}:{1})", pos.PosX, pos.PosY);
                        if (actor.Value is Player)
                        {
                            //player (no distance display)
                            textColor = Color._player;
                            switch(actor.Value.Status)
                            {
                                case ActorStatus.AtLocation:
                                case ActorStatus.Travelling:
                                    charString = string.Format("Aid {0,-2} {1,-18} {2,-30}{3,-15}", actor.Key, actor.Value.Name, locStatus, coordinates);
                                    break;
                                case ActorStatus.AtSea:
                                case ActorStatus.Adrift:
                                case ActorStatus.Captured:
                                    charString = string.Format("Aid {0,-2} {1,-18} {2,-30}", actor.Key, actor.Value.Name, locStatus);
                                    break;
                                default:
                                    charString = "Unknown Actor.Value.Status";
                                    break;
                            }
                        }
                        else
                        {
                            if (actor.Value.Delay == 0)
                            {
                                if (actor.Value.Activated == true) { textColor = Color._active; }
                                else { textColor = RLColor.White; }
                            }
                            else { textColor = RLColor.LightGray; }
                            //distance = Game.utility.GetDistance(posPlayer.PosX, posPlayer.PosY, pos.PosX, pos.PosY);
                            distText = string.Format("{0} {1}", "dist:", actor.Value.CrowDistance);
                            chance = actor.Value.CrowChance + actor.Value.CrowBonus;
                            chance = Math.Min(100, chance);
                            crowText = string.Format("{0} {1}{2}", "crow:", chance, "%");
                            charString = string.Format("Aid {0,-2} {1,-18} {2,-30}{3,-15} {4,-11} {5,-12} {6,-12}", actor.Key, actor.Value.Name, locStatus, coordinates, distText, crowText,
                                actor.Value.Known == true ? "Known" : "Unknown");
                        }
                        listToDisplay.Add(new Snippet(charString, textColor, RLColor.Black));
                    }
                }
            }
            return listToDisplay;
        }

        /// <summary>
        /// Display a list of all enemies
        /// </summary>
        /// <param name="debugMode">If true shows actual data, if false shows only what the Player knows</param>
        /// <returns></returns>
        public List<Snippet> ShowEnemiesRL(bool debugMode = false)
        {
            ActorStatus status;
            int locID;
            int expire = Game.constant.GetValue(Global.KNOWN_REVERT);
            string locName = "Unknown";
            string coordinates = "Unknown";
            string charString = "Unknown";
            string locStatus = "Unknown";
            List<Snippet> listInquistors = new List<Snippet>();
            List<Snippet> listOthers = new List<Snippet>(); //all other enemies
            List<Snippet> listToDisplay = new List<Snippet>();
            //loop dict of enemies
            foreach (var enemy in dictEnemyActors)
            {
                status = enemy.Value.Status;
                locID = enemy.Value.LocID;
                locName = GetLocationName(locID);
                //known
                if (enemy.Value.Known == true || debugMode == true)
                {
                    if (status == ActorStatus.AtLocation)
                    {
                        string activity = "?";
                        switch (enemy.Value.Goal)
                        {
                            case ActorGoal.Hide:
                                activity = "Hiding";
                                break;
                            case ActorGoal.Search:
                                activity = "Searching";
                                break;
                            case ActorGoal.Wait:
                                activity = "Waiting";
                                break;
                        }
                        locStatus = activity + " at " + locName;
                    }
                    else if (status == ActorStatus.Travelling)
                    { locStatus = "Moving to " + locName; }
                }
                //unknown
                else
                {
                    locID = enemy.Value.LastKnownLocID;
                    locName = GetLocationName(locID);
                    if (enemy.Value.LastKnownGoal == ActorGoal.Move)
                    { locStatus = "Moving to " + locName; }
                    else
                    {
                        string activity = "?";
                        switch (enemy.Value.LastKnownGoal)
                        {
                            case ActorGoal.Hide:
                                activity = "Hiding";
                                break;
                            case ActorGoal.Search:
                                activity = "Searching";
                                break;
                            case ActorGoal.Wait:
                                activity = "Waiting";
                                break;
                        }
                        locStatus = activity + " at " + locName;
                    }
                }
                //get location coords
                Location loc = Game.network.GetLocation(locID);
                if (loc != null) { coordinates = string.Format("(Pos {0}:{1})", loc.GetPosX(), loc.GetPosY()); }
                else { Game.SetError(new Error(184, "Invalid Loc (null) default Cordinate text used")); }
                //split enemies into two lists for display purposes
                if (enemy.Value is Inquisitor)
                {
                    //Inquisitor
                    if (enemy.Value.Known == true || debugMode == true)
                    {
                        //known status
                        if (debugMode == true)
                        { charString = string.Format("Aid {0,-3} {1,-23} {2,-35}{3,-15} {4,-12}  Goal -> {5,-8} Branch -> {6}", enemy.Key, enemy.Value.Name, locStatus, coordinates,
                            enemy.Value.Known == true ? "Known" : "Unknown", enemy.Value.Goal, enemy.Value.AssignedBranch); }
                        else { charString = string.Format("Aid {0,-3} {1,-23} {2,-35}{3,-15}", enemy.Key, enemy.Value.Name, locStatus, coordinates); }
                        listInquistors.Add(new Snippet(charString, RLColor.White, RLColor.Black));
                    }
                    else
                    {
                        if (enemy.Value.TurnsUnknown <= expire)
                        {
                            //unknown status and info is 'x' turns or less old
                            charString = string.Format("Aid {0,-3} {1,-23} {2,-35}{3,-15} {4} day{5} old information", enemy.Key, enemy.Value.Name, locStatus, coordinates, enemy.Value.TurnsUnknown,
                                enemy.Value.TurnsUnknown == 1 ? "" : "s");
                            listInquistors.Add(new Snippet(charString, RLColor.LightRed, RLColor.Black));
                        }
                        else
                        {
                            //unknown status and beyond the time horizon
                            charString = string.Format("Aid {0,-3} {1,-23} Whereabouts unknown", enemy.Key, enemy.Value.Name);
                            listInquistors.Add(new Snippet(charString, RLColor.LightGray, RLColor.Black));
                        }
                    }
                }
                else
                {
                    //All other Enemies
                    if (enemy.Value.Known == true || debugMode == true)
                    {
                        //known status
                        if (debugMode == true)
                        { charString = string.Format("Aid {0,-3} {1,-23} {2,-35}{3,-15} {4,-12}  Goal -> {5,-8} Branch -> {6}", enemy.Key, enemy.Value.Name, locStatus, coordinates,
                            enemy.Value.Known == true ? "Known" : "Unknown", enemy.Value.Goal, enemy.Value.AssignedBranch); }
                        else
                        { charString = string.Format("Aid {0,-3} {1,-23} {2,-35}{3,-15}", enemy.Key, enemy.Value.Name, locStatus, coordinates); }
                        listOthers.Add(new Snippet(charString, RLColor.White, RLColor.Black));
                    }
                    else
                    {
                        if (enemy.Value.TurnsUnknown <= expire)
                        {
                            //unknown status and info is 'x' turns or less old
                            charString = string.Format("Aid {0,-3} {1,-23} {2,-35}{3,-15} {4} day{5} old information", enemy.Key, enemy.Value.Name, locStatus, coordinates, enemy.Value.TurnsUnknown,
                                enemy.Value.TurnsUnknown == 1 ? "" : "s");
                            listOthers.Add(new Snippet(charString, RLColor.LightRed, RLColor.Black));
                        }
                        else
                        {
                            //unknown status and beyond the time horizon
                            charString = string.Format("Aid {0,-3} {1,-23} Whereabouts unknown", enemy.Key, enemy.Value.Name);
                            listOthers.Add(new Snippet(charString, RLColor.LightGray, RLColor.Black));
                        }
                    }
                }
            }
            //set up display list
            if (listInquistors.Count > 0)
            {
                listToDisplay.Add(new Snippet("--- Inquisitors", RLColor.Yellow, RLColor.Black));
                for (int i = 0; i < listInquistors.Count; i++)
                { listToDisplay.Add(listInquistors[i]); }
            }
            if (listOthers.Count > 0)
            {
                listToDisplay.Add(new Snippet(""));
                listToDisplay.Add(new Snippet("--- Other Enemies", RLColor.Yellow, RLColor.Black));
                for (int i = 0; i < listOthers.Count; i++)
                { listToDisplay.Add(listOthers[i]); }
            }
            return listToDisplay;
        }

        /// <summary>
        /// Display a single Actor in detail
        /// </summary>
        /// <param name="ActID"></param>
        /// <returns></returns>
        public List<Snippet> ShowActorRL(int actorID)
        {
            List<Snippet> listToDisplay = new List<Snippet>();
            Actor person = new Actor();
            string actorType;
            if (dictAllActors.TryGetValue(actorID, out person))
            {
                int locID = person.LocID;
                int refID = GetRefID(locID);
                //Set up people types
                Player player = null;
                Active active = null;
                //player
                if (person is Player)
                { player = person as Player; }
                if (person is Active)
                { active = person as Active; }
                //advisors can be one of three different categories
                if (person is Advisor) { actorType = GetAdvisorType((Advisor)person); }
                else { actorType = person.Title; }
                if ((int)person.Office > 0)
                { actorType = Convert.ToString(person.Office); }
                string name = string.Format("{0} {1}", actorType, person is Follower ? "\"" + person.Name + "\"" : person.Name);
                string handle = null;
                bool newLine = true;
                //nickname
                if (person.Age >= 15)
                {
                    newLine = false;
                    handle = string.Format(" \"{0}\"", person.Handle);
                }
                RLColor color = RLColor.White;
                RLColor locColor = RLColor.White;
                string locString = "?";
                listToDisplay.Add(new Snippet(name, RLColor.Yellow, RLColor.Black, false));
                //nickname (show as White)?
                if (handle != null)
                { listToDisplay.Add(new Snippet(handle, Color._star, RLColor.Black, false)); }
                //actorID
                listToDisplay.Add(new Snippet(string.Format(", Aid {0}", actorID), RLColor.Yellow, RLColor.Black));
                //realm
                if ((int)person.Realm > 0)
                { listToDisplay.Add(new Snippet(string.Format("Realm Title: {0}", person.Realm))); }
                //office
                if ((int)person.Office > 0)
                { listToDisplay.Add(new Snippet(string.Format("Office: {0}", person.Office), RLColor.Yellow, RLColor.Black)); }
                //location (if special replace with description)
                if (!(person is Special))
                {
                    //location descriptor
                    switch (person.Status)
                    {
                        case ActorStatus.AtLocation:
                            locString = string.Format("Located at {0} {1}, Lid {2}, Rid {3}", GetLocationName(locID), ShowLocationCoords(locID), locID, refID);
                            break;
                        case ActorStatus.Travelling:
                            Position pos = person.GetActorPosition();
                            locString = string.Format("Currently at {0}:{1}, travelling towards {2} {3}, Lid {4}, Rid {5}", pos.PosX, pos.PosY, GetLocationName(locID),
                                ShowLocationCoords(locID), locID, refID);
                            break;
                        case ActorStatus.AtSea:
                            if (person is Player)
                            {
                                locString = string.Format("At Sea onboard the S.S \"{0}\" bound for {1}, arriving in {2} more day{3}", player.ShipName, GetLocationName(locID),
                                    player.VoyageTimer, player.VoyageTimer != 1 ? "s" : "");
                            }
                            break;
                        case ActorStatus.Captured:
                            locString = string.Format("Incarcerated in the bowels of the {0} dungeons. Survival time {1} more day{2}", GetLocationName(locID), player.DeathTimer,
                                player.DeathTimer != 1 ? "s" : "");
                            break;
                        case ActorStatus.Adrift:
                            if (person is Player)
                            { locString = string.Format("Adrift in {0}. Survival time {1} day{2}", player.SeaName, player.DeathTimer, player.DeathTimer != 1 ? "s" : ""); }
                            break;
                        case ActorStatus.Gone:
                            locString = string.Format("Passed away ({0}) in {1}", person.ReasonGone, person.Gone);
                            locColor = RLColor.Red;
                            break;
                    }
                    listToDisplay.Add(new Snippet(locString, locColor, RLColor.Black));
                }
                else { listToDisplay.Add(new Snippet(person.Description)); }
                //Delayed
                if (person.Delay > 0)
                { listToDisplay.Add(new Snippet(string.Format("Delayed (\"{0}\") for {1} {2}", person.DelayReason, person.Delay, person.Delay == 1 ? "turn" : "turns"), RLColor.LightRed, RLColor.Black)); }
                if (person is Knight)
                {
                    Knight knight = person as Knight;
                    string houseName;
                    if (knight.HouseID == Game.lore.OldHouseID) { houseName = Game.lore.OldHouseName; }
                    //deals with case of knight belonging to old King (he's been deleted from dictMajorHouses)
                    else { houseName = GetMajorHouseName(knight.HouseID); }
                    listToDisplay.Add(new Snippet(string.Format("Has sworn allegiance to House {0}", houseName)));
                }
                //Loyalty
                if (person is Passive && !(person is Special))
                { listToDisplay.Add(new Snippet(string.Format("Loyal to the {0} (originally {1})", person.Loyalty_Current, person.Loyalty_AtStart))); }
                listToDisplay.Add(new Snippet(string.Format("{0} y.o {1}, born {2}", person.Age, person.Sex, person.Born)));
                //stats - natural ---
                string effectText = null;
                int abilityStars;
                RLColor traitColor;
                SkillType trait;
                //age of actor
                SkillAge age = SkillAge.Fifteen;
                if (person.Age >= 5 && person.Age < 15)
                { age = SkillAge.Five; }
                //only show abilities if age >= 5 & not dead
                if (person.Age >= 5)
                {
                    //header
                    listToDisplay.Add(new Snippet("Abilities (some at 5 y.o, all at 15 y.o)", RLColor.Brown, RLColor.Black));
                    //combat
                    trait = SkillType.Combat;
                    effectText = person.GetTraitEffectText(trait, age);
                    abilityStars = person.GetSkill(trait, age);
                    if (abilityStars < 3) { traitColor = Color._badTrait; }
                    else if (abilityStars == 3) { traitColor = Color._star; }
                    else { traitColor = Color._goodTrait; }
                    //display
                    newLine = true;
                    if (abilityStars != 3 /*|| influenceDisplay == true*/)
                    { newLine = false; }
                    if ((age == SkillAge.Five && abilityStars != 3) || age == SkillAge.Fifteen)
                    {
                        listToDisplay.Add(new Snippet(string.Format("{0, -16}", "Combat"), false));
                        listToDisplay.Add(new Snippet(string.Format("{0, -12}", GetStars(abilityStars)), Color._star, RLColor.Black, newLine));
                        if (abilityStars != 3 /*|| influenceDisplay == true*/)
                        { listToDisplay.Add(new Snippet(string.Format("{0} {1}", person.arrayOfTraitNames[(int)trait], effectText), traitColor, RLColor.Black)); }
                    }
                    //Wits
                    trait = SkillType.Wits;
                    effectText = person.GetTraitEffectText(trait, age);
                    abilityStars = person.GetSkill(trait, age);
                    if (abilityStars < 3) { traitColor = Color._badTrait; }
                    else if (abilityStars == 3) { traitColor = Color._star; }
                    else { traitColor = Color._goodTrait; }
                    //display
                    newLine = true;
                    if (abilityStars != 3 /*|| influenceDisplay == true*/)
                    { newLine = false; }
                    if ((age == SkillAge.Five && abilityStars != 3) || age == SkillAge.Fifteen)
                    {
                        listToDisplay.Add(new Snippet(string.Format("{0, -16}", "Wits"), false));
                        listToDisplay.Add(new Snippet(string.Format("{0, -12}", GetStars(abilityStars)), Color._star, RLColor.Black, newLine));
                        if (abilityStars != 3 /*|| influenceDisplay == true*/)
                        { listToDisplay.Add(new Snippet(string.Format("{0} {1}", person.arrayOfTraitNames[(int)trait], effectText), traitColor, RLColor.Black)); }
                    }
                    //charm
                    trait = SkillType.Charm;
                    effectText = person.GetTraitEffectText(trait, age);
                    abilityStars = person.GetSkill(trait, age);
                    if (abilityStars < 3) { traitColor = Color._badTrait; }
                    else if (abilityStars == 3) { traitColor = Color._star; }
                    else { traitColor = Color._goodTrait; }
                    //display
                    newLine = true;
                    if (abilityStars != 3 /*|| influenceDisplay == true*/)
                    { newLine = false; }
                    if ((age == SkillAge.Five && abilityStars != 3) || age == SkillAge.Fifteen)
                    {
                        listToDisplay.Add(new Snippet(string.Format("{0, -16}", "Charm"), false));
                        listToDisplay.Add(new Snippet(string.Format("{0, -12}", GetStars(abilityStars)), Color._star, RLColor.Black, newLine));
                        if (abilityStars != 3 /*|| influenceDisplay == true*/)
                        { listToDisplay.Add(new Snippet(string.Format("{0} {1}", person.arrayOfTraitNames[(int)trait], effectText), traitColor, RLColor.Black)); }
                    }
                    //treachery
                    trait = SkillType.Treachery;
                    effectText = person.GetTraitEffectText(trait, age);
                    abilityStars = person.GetSkill(trait, age);
                    if (abilityStars < 3) { traitColor = Color._badTrait; }
                    else if (abilityStars == 3) { traitColor = Color._star; }
                    else { traitColor = Color._goodTrait; }
                    //display
                    newLine = true;
                    if (abilityStars != 3 /*|| influenceDisplay == true*/)
                    { newLine = false; }
                    if ((age == SkillAge.Five && abilityStars != 3) || age == SkillAge.Fifteen)
                    {
                        listToDisplay.Add(new Snippet(string.Format("{0, -16}", "Treachery"), false));
                        listToDisplay.Add(new Snippet(string.Format("{0, -12}", GetStars(abilityStars)), Color._star, RLColor.Black, newLine));
                        if (abilityStars != 3 /*|| influenceDisplay == true*/)
                        { listToDisplay.Add(new Snippet(string.Format("{0} {1}", person.arrayOfTraitNames[(int)trait], effectText), traitColor, RLColor.Black)); }
                    }
                    //Leadership
                    trait = SkillType.Leadership;
                    effectText = person.GetTraitEffectText(trait, age);
                    abilityStars = person.GetSkill(trait, age);
                    if (abilityStars < 3) { traitColor = Color._badTrait; }
                    else if (abilityStars == 3) { traitColor = Color._star; }
                    else { traitColor = Color._goodTrait; }
                    //display
                    newLine = true;
                    if (abilityStars != 3 /*|| influenceDisplay == true*/)
                    { newLine = false; }
                    if ((age == SkillAge.Five && abilityStars != 3) || age == SkillAge.Fifteen)
                    {
                        listToDisplay.Add(new Snippet(string.Format("{0, -16}", "Leadership"), false));
                        listToDisplay.Add(new Snippet(string.Format("{0, -12}", GetStars(abilityStars)), Color._star, RLColor.Black, newLine));
                        if (abilityStars != 3 /*|| influenceDisplay == true*/)
                        { listToDisplay.Add(new Snippet(string.Format("{0} {1}", person.arrayOfTraitNames[(int)trait], effectText), traitColor, RLColor.Black)); }
                    }
                    //Touched
                    if (person.Touched > 0)
                    {
                        trait = SkillType.Touched;
                        effectText = person.GetTraitEffectText(trait, age);
                        abilityStars = person.GetSkill(trait, age);
                        if (abilityStars < 3) { traitColor = Color._badTrait; }
                        else if (abilityStars == 3) { traitColor = Color._star; }
                        else { traitColor = Color._goodTrait; }
                        //display
                        newLine = true;
                        if (abilityStars != 3 /*|| influenceDisplay == true*/)
                        { newLine = false; }
                        if ((age == SkillAge.Five && abilityStars != 3) || age == SkillAge.Fifteen)
                        {
                            listToDisplay.Add(new Snippet(string.Format("{0, -16}", "Touched"), false));
                            listToDisplay.Add(new Snippet(string.Format("{0, -12}", GetStars(abilityStars)), Color._star, RLColor.Black, newLine));
                            if (abilityStars != 3 /*|| influenceDisplay == true*/)
                            { listToDisplay.Add(new Snippet(string.Format("{0} {1}", person.arrayOfTraitNames[(int)trait], effectText), traitColor, RLColor.Black)); }
                        }
                    }
                }
                //Conditions
                if (person.CheckConditions() == true)
                {
                    List<Condition> tempConditions = person.GetConditions();
                    listToDisplay.Add(new Snippet("Conditions (additional Skill modifiers)", RLColor.Brown, RLColor.Black));
                    string tempCondition_0, tempCondition_1;
                    RLColor tempColor = RLColor.White;
                    foreach (Condition condition in tempConditions)
                    {
                        if (condition.Timer != 999)
                        { tempCondition_0 = string.Format("\"{0}\", {1} day{2}", condition.Text, condition.Timer, condition.Timer == 1 ? "" : "s"); }
                        else { tempCondition_0 = string.Format("\"{0}\"", condition.Text); }
                        tempCondition_1 = string.Format("{0} ({1}{2})", condition.Skill, condition.Effect > 0 ? "+" : "", condition.Effect);
                        if (condition.Effect > 0) { tempColor = Color._goodTrait; }
                        else { tempColor = Color._badTrait; }
                        listToDisplay.Add(new Snippet(string.Format("{0, -28}", tempCondition_0), false));
                        listToDisplay.Add(new Snippet(string.Format("{0}", tempCondition_1), tempColor, RLColor.Black));
                    }
                }
                //Crow explanation for loyal followers
                if (person is Follower)
                {
                    Active tempPerson = person as Active;
                    List<string> tempList = tempPerson.GetCrowTooltips();
                    if (tempList.Count > 0)
                    {
                        listToDisplay.Add(new Snippet("Crow Explanation", RLColor.Brown, RLColor.Black));
                        foreach (string tip in tempList)
                        { listToDisplay.Add(new Snippet(tip)); }
                        if (tempPerson.Activated == true)
                        { listToDisplay.Add(new Snippet("Activated", RLColor.Yellow, RLColor.Black)); }
                        else
                        { listToDisplay.Add(new Snippet("Not activated", RLColor.Red, RLColor.Black)); }
                    }
                }
                //relationships (ignore for dead actors)
                if (!(person is Player || person is Special) && person.Status != ActorStatus.Gone)
                {
                    listToDisplay.Add(new Snippet("Relationships", RLColor.Brown, RLColor.Black));
                    //with Player
                    int relStars = person.GetRelPlyrStars();
                    listToDisplay.Add(new Snippet(string.Format("{0, -16}", "Player"), false));
                    listToDisplay.Add(new Snippet(string.Format("{0, -12}", GetStars(relStars)), RLColor.LightRed, RLColor.Black, false));
                    int change = person.GetPlayerChange();
                    int relPlyr = person.GetRelPlyr();
                    string tagText = string.Format("(Change {0}{1})", change > 0 ? "+" : "", change);
                    if (change == 0) { tagText = ""; }
                    RLColor tagColor = Color._badTrait;
                    if (relPlyr >= 50) { tagColor = Color._goodTrait; }
                    listToDisplay.Add(new Snippet(string.Format("{0}, Rel {1}, {2}", person.GetPlayerTag(), relPlyr, tagText),
                        tagColor, RLColor.Black, true));
                    //with Lord
                    if (person.Type != ActorType.Lord && person is Passive || person is Inquisitor && person.Status != ActorStatus.Gone)
                    {
                        relStars = person.GetRelLordStars();
                        listToDisplay.Add(new Snippet(string.Format("{0, -16}", "Lord"), false));
                        listToDisplay.Add(new Snippet(string.Format("{0, -12}", GetStars(relStars)), RLColor.LightRed, RLColor.Black, false));
                        change = person.GetLordChange();
                        int relLord = person.GetRelLord();
                        tagText = string.Format("(Change {0}{1})", change > 0 ? "+" : "", change);
                        if (change == 0) { tagText = ""; }
                        tagColor = Color._badTrait;
                        if (relLord >= 50) { tagColor = Color._goodTrait; }
                        listToDisplay.Add(new Snippet(string.Format("{0}, Rel {1}, {2}", person.GetLordTag(), relLord, tagText),
                            tagColor, RLColor.Black, true));
                    }
                }
                //Possessions -> active followers
                if (person is Active)
                {
                    int resources = active.Resources;
                    resources = Math.Min(5, resources);
                    //resources = Math.Max(1, resources);
                    listToDisplay.Add(new Snippet("Possessions", RLColor.Brown, RLColor.Black));
                    listToDisplay.Add(new Snippet(string.Format("{0, -16}", "Resources"), false));
                    listToDisplay.Add(new Snippet(string.Format("{0, -12}", GetStars(resources)), RLColor.LightRed, RLColor.Black, false));
                    listToDisplay.Add(new Snippet(string.Format("{0}", (ResourceLevel)resources), true));
                }
                //Possessions -> Lords and BannerLords
                else if (person.Type == ActorType.Lord || person.Type == ActorType.BannerLord)
                {
                    int resources = person.Resources;
                    resources = Math.Min(5, resources);
                    //resources = Math.Max(1, resources);
                    listToDisplay.Add(new Snippet("Possessions", RLColor.Brown, RLColor.Black));
                    listToDisplay.Add(new Snippet(string.Format("{0, -16}", "Resources"), false));
                    listToDisplay.Add(new Snippet(string.Format("{0, -12}", GetStars(resources)), RLColor.LightRed, RLColor.Black, false));
                    listToDisplay.Add(new Snippet(string.Format("{0}", (ResourceLevel)resources), true));
                }
                //Possessions -> Items
                List<int> listItems = person.GetItems();
                if (listItems.Count > 0)
                {
                    foreach (int possID in listItems)
                    {
                        Item item = GetItem(possID);
                        //add possession label for all non-Lords who wouldn't normally have one
                        if (person is Passive && (person.Type != ActorType.Lord && person.Type != ActorType.BannerLord))
                        { listToDisplay.Add(new Snippet("Possessions", RLColor.Brown, RLColor.Black)); }
                        listToDisplay.Add(new Snippet(string.Format("Item ID {0}, \"{1}\", {2}", item.ItemID, item.Description, item.ItemType)));
                    }
                }
                //family
                SortedDictionary<int, ActorRelation> dictTempFamily = null;
                if (person is Noble) { Noble tempPerson = person as Noble; dictTempFamily = tempPerson.GetFamily(); }
                else if (person is Player) { Player tempPerson = person as Player; dictTempFamily = tempPerson.GetFamily(); }
                if (dictTempFamily != null)
                {
                    //SortedDictionary<int, ActorRelation> dictTempFamily = tempFamilyPerson.GetFamily();
                    if (dictTempFamily?.Count > 0)
                    {
                        listToDisplay.Add(new Snippet("Family", RLColor.Brown, RLColor.Black));
                        string maidenName;
                        foreach (KeyValuePair<int, ActorRelation> kvp in dictTempFamily)
                        {
                            Noble relPerson = (Noble)GetPassiveActor(kvp.Key);
                            RLColor familyColor = RLColor.White;
                            if (relPerson.Status == ActorStatus.Gone)
                            { familyColor = RLColor.LightGray; }
                            maidenName = "";
                            if (relPerson.MaidenName != null)
                            { maidenName = string.Format(" (nee {0})", relPerson.MaidenName); }
                            int relAge = Game.gameStart - relPerson.Born;
                            string houseName;
                            //needed 'cause old King's house has been removed from the dictionaries
                            if (relPerson.HouseID == Game.lore.OldHouseID)
                            { houseName = Game.lore.OldHouseName; }
                            else { houseName = GetMajorHouseName(relPerson.HouseID); }
                            string text = string.Format("{0} Aid {1}: {2} {3}{4} of House {5}, Age {6}",
                              kvp.Value, relPerson.ActID, relPerson.Type, relPerson.Name, maidenName, houseName, relAge);

                            listToDisplay.Add(new Snippet(text, familyColor, RLColor.Black));
                        }
                    }
                }
                //secrets
                List<int> listOfSecrets = person.GetSecrets();
                if (listOfSecrets.Count > 0)
                {
                    listToDisplay.Add(new Snippet("Secrets", RLColor.Brown, RLColor.Black));
                    foreach (int possessionID in listOfSecrets)
                    {
                        Secret secret = (Secret)GetPossession(possessionID);
                        if (secret != null)
                        {
                            listToDisplay.Add(new Snippet(string.Format("{0} {1} ", secret.Year, secret.Description), false));
                            listToDisplay.Add(new Snippet(string.Format("{0}", GetStars(secret.Strength)), RLColor.LightRed, RLColor.Black));
                        }
                    }
                }
                //player specific Soft possessions - Favours & Introductions
                if (person is Player)
                {
                    //favours (Player only)
                    List<int> listOfFavours = player.GetFavours();
                    if (listOfFavours.Count > 0)
                    {
                        listToDisplay.Add(new Snippet("Favours", RLColor.Brown, RLColor.Black));
                        foreach (int possessionID in listOfFavours)
                        {
                            Favour favour = (Favour)GetPossession(possessionID);
                            if (favour != null)
                            {
                                listToDisplay.Add(new Snippet(string.Format("{0} {1} ", favour.Year, favour.Description), false));
                                listToDisplay.Add(new Snippet(string.Format("{0}", GetStars(favour.Strength)), RLColor.LightRed, RLColor.Black));
                            }
                        }
                    }
                    //Introductions (Player only)
                    List<int> listOfIntroductions = player.GetIntroductions();
                    if (listOfIntroductions.Count > 0)
                    {
                        listToDisplay.Add(new Snippet("Introductions", RLColor.Brown, RLColor.Black));
                        foreach (int possessionID in listOfIntroductions)
                        {
                            Introduction introduction = (Introduction)GetPossession(possessionID);
                            if (introduction != null)
                            {
                                listToDisplay.Add(new Snippet(string.Format("{0} {1} ", introduction.Year, introduction.Description), false));
                                listToDisplay.Add(new Snippet(string.Format("{0}", GetStars(introduction.Strength)), RLColor.LightRed, RLColor.Black));
                            }
                        }
                    }
                }
                //personal history
                List<string> actorHistory = new List<string>();
                if (person is Player)
                {
                    //Player -> get original (pre-game start history)
                    actorHistory = GetActorHistoricalRecords(player.HistoryID);
                }
                actorHistory.AddRange(GetActorHistoricalRecords(person.ActID));
                if (actorHistory.Count > 0)
                {
                    listToDisplay.Add(new Snippet("Personal History", RLColor.Brown, RLColor.Black));
                    foreach (string text in actorHistory)
                    { listToDisplay.Add(new Snippet(text)); }
                }
                //Current events
                List<string> actorCurrent = new List<string>();
                if (person is Player)
                { actorCurrent.AddRange(GetPlayerCurrentRecords(person.ActID)); }
                else
                { actorCurrent.AddRange(GetActorCurrentRecords(person.ActID)); }
                if (actorCurrent.Count > 0)
                {
                    listToDisplay.Add(new Snippet("Recent Events", RLColor.Brown, RLColor.Black));
                    foreach (string text in actorCurrent)
                    { listToDisplay.Add(new Snippet(text)); }
                }
                //Relationship records
                if (!(person is Player) && person.Status != ActorStatus.Gone)
                {
                    //with Player
                    List<Relation> playerRelations = person.GetRelEventPlyr();
                    if (playerRelations.Count > 0)
                    {
                        listToDisplay.Add(new Snippet("Relationship History with Player", RLColor.Brown, RLColor.Black));
                        foreach (Relation relationship in playerRelations)
                        { listToDisplay.Add(new Snippet(relationship.GetRelationText())); }
                    }
                    //with Lord
                    List<Relation> lordRelations = person.GetRelEventLord();
                    lordRelations = person.GetRelEventLord();
                    if (lordRelations.Count > 0)
                    {
                        listToDisplay.Add(new Snippet("Relationship History with Lord", RLColor.Brown, RLColor.Black));
                        foreach (Relation relationship in lordRelations)
                        { listToDisplay.Add(new Snippet(relationship.GetRelationText())); }
                    }
                }
            }
            else
            { listToDisplay.Add(new Snippet(string.Format("No Character with ID {0} exists", actorID), RLColor.LightRed, RLColor.Black)); }
            return listToDisplay;
        }


        /// <summary>
        /// creates a string showing the number of stars for traits, secrets, etc.
        /// </summary>
        /// <param name="num">number of stars</param>
        /// <returns></returns>
        internal string GetStars(int num)
        {
            string stars = null;
            num = Math.Min(5, num);
            num = Math.Max(1, num);
            for (int i = 0; i < num; i++)
            { stars += "o "; }
            return stars;
        }


        /// <summary>
        /// used to display character data when first selected by a # key in main menu
        /// </summary>
        /// <param name="inputConsole"></param>
        /// <param name="consoleDisplay"></param>
        /// <param name="charID"></param>
        public Snippet ShowSelectedActor(int charID)
        {
            string returnText = "Character NOT KNOWN";
            //find in dictionary
            if (dictActiveActors.ContainsKey(charID))
            {
                Actor person = dictActiveActors[charID];
                Position pos = person.GetActorPosition();
                returnText = person.Name + " at ";
                returnText += this.GetLocationName(person.LocID);
                returnText += string.Format(" ({0}:{1}) has been selected", pos.PosX, pos.PosY);
            }
            return new Snippet(returnText);
        }

        internal string GetLocationName(int locID)
        {
            string locName = "Unknown";
            Location loc = Game.network.GetLocation(locID);
            if (loc != null)
            { locName = loc.LocName; }
            else { Game.SetError(new Error(185, "Invalid Loc (null) -> By LocID")); }
            return locName;
        }

        /// <summary>
        /// returns blank string if not found
        /// </summary>
        /// <param name="pos"></param>
        /// <returns></returns>
        internal string GetLocationName(Position pos)
        {
            string locName = "Unknown";
            int locID = Game.map.GetMapInfo(MapLayer.LocID, pos.PosX, pos.PosY);
            if (locID > 0)
            {
                Location loc = Game.network.GetLocation(locID);
                if (loc != null) { locName = loc.LocName; }
                else { Game.SetError(new Error(185, "Invalid Loc (null) -> By Position")); }
            }
            return locName;
        }

        /// <summary>
        /// Get location coords in a formatted string
        /// </summary>
        /// <param name="locID"></param>
        /// <returns>returns '(loc 20:4)' format string</returns>
        public string ShowLocationCoords(int locID)
        {
            string coords = "Unknown";
            Location loc = Game.network.GetLocation(locID);
            if (loc != null) { coords = string.Format("(loc {0}:{1})", loc.GetPosX(), loc.GetPosY()); }
            else { Game.SetError(new Error(186, "Invalid Loc (null) Unknown Coordinates")); }
            return coords;
        }



        /// <summary>
        /// click on a location to get info
        /// </summary>
        /// <param name="pos"></param>
        internal List<Snippet> ShowLocationRL(int locID, int mouseX, int mouseY)
        {
            int relFriends = Game.constant.GetValue(Global.FRIEND_THRESHOLD);
            int relEnemies = Game.constant.GetValue(Global.ENEMY_THRESHOLD);
            int numFriends = 0; int numEnemies = 0; int relPlyr = 0;
            List<Snippet> locList = new List<Snippet>();
            //Location display
            if (locID > 0)
            {
                string description = "House";
                RLColor color = RLColor.Cyan;
                bool houseCapital = false;
                Location loc = Game.network.GetLocation(locID);
                if (loc != null)
                {
                    House house = GetHouse(loc.RefID);
                    //if a House Capital show in Yellow
                    if (Game.map.GetMapInfo(MapLayer.Capitals, loc.GetPosX(), loc.GetPosY()) > 0)
                    { color = RLColor.Yellow; houseCapital = true; }
                    //ignore the capital and special locations for the moment until they are included in dictAllHouses
                    if (house != null)
                    {
                        int eventCount = house.GetNumFollowerEvents();
                        if (loc.HouseID != 99)
                        {
                            int resources = house.Resources;
                            //normal houses - major / minor / capital 
                            locList.Add(new Snippet(string.Format("House {0} of {1}, Lid {2}, Rid {3}, Branch {4}", house.Name, loc.LocName, loc.LocationID, loc.RefID, loc.GetBranch()), color, RLColor.Black));
                            locList.Add(new Snippet(string.Format("Motto \"{0}\"", house.Motto)));
                            locList.Add(new Snippet(string.Format("Banner \"{0}\"", house.Banner)));
                            locList.Add(new Snippet(string.Format("Seated at {0} {1}", house.LocName, ShowLocationCoords(locID))));
                            RLColor loyaltyColor = Color._goodTrait;
                            if (house.Loyalty_Current == KingLoyalty.New_King) { loyaltyColor = Color._badTrait; }
                            locList.Add(new Snippet(string.Format("Loyal to the {0}", house.Loyalty_Current), loyaltyColor, RLColor.Black));

                            locList.Add(new Snippet(string.Format("Strength of Castle Walls ({0}) ", (CastleDefences)house.CastleWalls), false));
                            locList.Add(new Snippet(string.Format("{0}", GetStars((int)house.CastleWalls)), RLColor.LightRed, RLColor.Black));
                            locList.Add(new Snippet(string.Format("House Resources ({0}) ", (ResourceLevel)resources), false));
                            locList.Add(new Snippet(string.Format("{0}", GetStars((int)resources)), RLColor.LightRed, RLColor.Black));
                            if (eventCount > 0)
                            {
                                locList.Add(new Snippet(string.Format("Archetype \"{0}\" with {1} events", Game.director.GetArchetypeName(house.ArcID), eventCount),
                                  RLColor.LightGray, RLColor.Black));
                            }
                        }
                        else
                        {
                            //special Inn
                            locList.Add(new Snippet(string.Format("{0} Inn, LocID {1}, RefID {2}, Branch {3}", house.Name, loc.LocationID, loc.RefID, loc.GetBranch(), color, RLColor.Black)));
                            locList.Add(new Snippet(string.Format("Motto \"{0}\"", house.Motto)));
                            locList.Add(new Snippet(string.Format("Signage \"{0}\"", house.Banner)));
                            locList.Add(new Snippet(string.Format("Found at {0}", ShowLocationCoords(locID))));
                            if (eventCount > 0)
                            {
                                locList.Add(new Snippet(string.Format("Archetype \"{0}\" with {1} events", Game.director.GetArchetypeName(house.ArcID), eventCount),
                                  RLColor.LightGray, RLColor.Black));
                            }
                        }
                    }
                    //correct location description
                    if (loc.HouseID == 99)
                    { description = "A homely Inn"; }
                    else if (loc.LocationID == 1)
                    { description = loc.LocName + ": the Home of the King"; }
                    else if (Game.map.GetMapInfo(MapLayer.Capitals, loc.GetPosX(), loc.GetPosY()) == 0)
                    { description = "BannerLord of House"; }
                    //bannerlord details if applicable
                    if (houseCapital == false)
                    {
                        string locDetails = string.Format("{0} {1}", description, GetMajorHouseName(loc.HouseID));
                        locList.Add(new Snippet(locDetails));
                    }
                    if (loc.IsCapital() == true)
                    {
                        locList.Add(new Snippet("KINGDOM CAPITAL", RLColor.Yellow, RLColor.Black));
                        int capitalWalls = Game.history.CapitalWalls;
                        int capitalResources = Game.history.CapitalTreasury;
                        locList.Add(new Snippet(string.Format("Strength of Castle Walls ({0}) ", (CastleDefences)capitalWalls), false));
                        locList.Add(new Snippet(string.Format("{0}", GetStars(capitalWalls)), RLColor.LightRed, RLColor.Black));
                        locList.Add(new Snippet(string.Format("House Resources ({0}) ", (ResourceLevel)capitalResources), false));
                        locList.Add(new Snippet(string.Format("{0}", GetStars((int)capitalResources)), RLColor.LightRed, RLColor.Black));
                    }
                    if (loc.Connector == true)
                    { locList.Add(new Snippet("CONNECTOR", RLColor.Red, RLColor.Black)); }
                    if (loc.Port == true)
                    {
                        int numPorts = loc.GetNumConnectedPorts();
                        locList.Add(new Snippet(string.Format("PORT, connected to {0} other port{1}. Sea Passages available.", numPorts, numPorts != 1 ? "s" : ""), RLColor.LightRed, RLColor.Black));
                    }
                    //characters at location
                    List<int> charList = loc.GetActorList();
                    charList.Sort();
                    if (charList.Count > 0)
                    {
                        RLColor textColor = RLColor.White;
                        int row = 3;
                        locList.Add(new Snippet(string.Format("Characters at {0}", loc.LocName), RLColor.Brown, RLColor.Black));
                        string actorDetails;
                        string actorType;
                        foreach (int charID in charList)
                        {
                            row++;
                            if (dictAllActors.ContainsKey(charID))
                            {
                                textColor = RLColor.White;
                                //Actor person = new Actor();
                                Actor person = dictAllActors[charID];
                                //advisors can be one of three different categories
                                if (person is Advisor) { actorType = GetAdvisorType((Advisor)person); }
                                else { actorType = Convert.ToString(person.Type); }
                                if ((int)person.Office > 0)
                                { actorType = Convert.ToString(person.Office); }
                                actorDetails = string.Format("Aid {0} {1} {2}, age {3}", person.ActID, actorType, person.Name, person.Age);
                                //player controlled (change color of text)?
                                if (person is Active)
                                {
                                    if (person is Player)
                                    { textColor = Color._player; }
                                    else
                                    { textColor = Color._active; }
                                }
                                //tally friends and enemies
                                if (person.ActID > 1)
                                {
                                    relPlyr = person.GetRelPlyr();
                                    if (relPlyr >= relFriends) { numFriends++; }
                                    else if (relPlyr <= relEnemies) { numEnemies++; }
                                }
                            }
                            else
                            { actorDetails = string.Format("unknown ID " + Convert.ToString(charID)); }
                            locList.Add(new Snippet(actorDetails, textColor, RLColor.Black));
                        }
                        //display friends and enemies
                        if (numFriends > 0 || numEnemies > 0)
                        {
                            locList.Add(new Snippet(string.Format("Current Standing at {0}", loc.LocName), RLColor.Brown, RLColor.Black));
                            locList.Add(new Snippet(string.Format("You have {0} Friend{1} and {2} Enem{3} here", numFriends, numFriends != 1 ? "s" : "", numEnemies,
                                numEnemies != 1 ? "ies" : "y")));
                        }
                    }
                }
                else { Game.SetError(new Error(187, "Invalid Loc (null)")); }
            }
            else if (locID == 0)
            {
                //Non-Location -> Terrain
                int geoID = Game.map.GetMapInfo(MapLayer.GeoID, mouseX, mouseY, true);
                int numEvents;
                //geo sea zone or terrain cluster present?
                if (geoID > 0)
                {
                    GeoCluster cluster = GetGeoCluster(geoID);
                    if (cluster != null)
                    {
                        locList.Add(new Snippet(string.Format("{0}, geoID {1}", cluster.Name, cluster.GeoID), RLColor.Yellow, RLColor.Black));
                        locList.Add(new Snippet(cluster.Description));
                        locList.Add(new Snippet(string.Format("Size {0}, Terrain {1}, Type {2}", cluster.Size, cluster.Terrain, cluster.Type)));
                        numEvents = cluster.GetNumFollowerEvents() + cluster.GetNumPlayerEvents();
                        if (numEvents > 0)
                        { locList.Add(new Snippet(string.Format("Archetype \"{0}\" with {1} Events", Game.director.GetArchetypeName(cluster.Archetype), numEvents))); }
                    }
                    else
                    { locList.Add(new Snippet(string.Format("ERROR: GeoCluster couldn't be found for geoID {0}", geoID), RLColor.Red, RLColor.Black)); }
                }
                //nothing there apart from plains
                else
                { locList.Add(new Snippet("ERROR: There is no Location present here", RLColor.Red, RLColor.Black)); }

            }
            else
            { locList.Add(new Snippet("ERROR: Please click on the map", RLColor.Red, RLColor.Black)); }
            return locList;
        }

        /// <summary>
        /// Display Major House data to main infoConsole (input either houseID or refID, will check houseID first)
        /// </summary>
        /// <param name="houseID"></param>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal List<Snippet> ShowHouseRL(int houseID, int refID = 0)
        {
            MajorHouse majorHouse = null;
            //check input type
            if (houseID > 0)
            { majorHouse = GetMajorHouse(houseID); }
            else if (refID > 0)
            { House house = GetHouse(refID); majorHouse = house as MajorHouse; }
            else
            { Game.SetError(new Error(36, "Invalid input data (houseID and refID are both Zero, or less)")); return null; }
            List<Snippet> houseList = new List<Snippet>();
            if (majorHouse != null)
            {
                List<int> listLordLocations = majorHouse.GetBannerLordLocations();
                //details
                houseList.Add(new Snippet("House " + majorHouse.Name, RLColor.Yellow, RLColor.Black));
                string motto = string.Format("Motto \"{0}\"", majorHouse.Motto);
                houseList.Add(new Snippet(motto));
                string banner = string.Format("Banner \"{0}\"", majorHouse.Banner);
                houseList.Add(new Snippet(banner));
                string seat = string.Format("Seated at {0} {1}", majorHouse.LocName, ShowLocationCoords(majorHouse.LocID));
                houseList.Add(new Snippet(seat));
                string loyalty = string.Format("Loyal to the {0} (originally: {1})", majorHouse.Loyalty_Current, majorHouse.Loyalty_AtStart);
                houseList.Add(new Snippet(loyalty));
                int bannerTotal = listLordLocations.Count * Game.constant.GetValue(Global.MEN_AT_ARMS) / 2;
                int armyTotal = bannerTotal + majorHouse.MenAtArms;
                string army = string.Format("Can call upon {0:N0} Men At Arms in Total ({1:N0} from Lord, {2:N0} from Bannerlords)", armyTotal, majorHouse.MenAtArms, bannerTotal);
                houseList.Add(new Snippet(army));
                houseList.Add(new Snippet(string.Format("Strength of Castle Walls ({0}) ", (CastleDefences)majorHouse.CastleWalls), false));
                houseList.Add(new Snippet(string.Format("{0}", GetStars(majorHouse.CastleWalls)), RLColor.LightRed, RLColor.Black));
                houseList.Add(new Snippet(string.Format("House Resources ({0}) ", (ResourceLevel)majorHouse.Resources), false));
                houseList.Add(new Snippet(string.Format("{0}", GetStars((int)majorHouse.Resources)), RLColor.LightRed, RLColor.Black));
                //bannerlords
                if (listLordLocations.Count > 0)
                {
                    houseList.Add(new Snippet("BannerLords", RLColor.Yellow, RLColor.Black));
                    string bannerLord;
                    foreach (int locID in listLordLocations)
                    {
                        Location loc = Game.network.GetLocation(locID);
                        if (loc != null)
                        {
                            refID = Game.map.GetMapInfo(MapLayer.RefID, loc.GetPosX(), loc.GetPosY());
                            House house = GetHouse(refID);
                            bannerLord = string.Format("House {0} at {1} {2}", house.Name, GetLocationName(locID), ShowLocationCoords(locID));
                            houseList.Add(new Snippet(bannerLord));
                        }
                        else { Game.SetError(new Error(36, "Invalid Loc (null) BannerLord not added to list")); }
                    }
                }
                //family - get list of all actorID's in family
                houseList.Add(new Snippet("Family", RLColor.Brown, RLColor.Black));
                List<int> listOfFamily = new List<int>();
                refID = majorHouse.RefID;
                IEnumerable<int> familyMembers =
                    from person in dictPassiveActors
                    where person.Value.RefID == refID && person.Value is Noble
                    orderby person.Value.ActID
                    select person.Value.ActID;
                listOfFamily = familyMembers.ToList();
                //loop list and display each actor appropriately (dead, or missing, in Lt.Gray)
                string personText;
                string actorType;
                foreach (int actorID in listOfFamily)
                {
                    Passive person = GetPassiveActor(actorID);
                    if ((int)person.Office > 0) { actorType = Convert.ToString(person.Office); }
                    else { actorType = Convert.ToString(person.Type); }
                    personText = string.Format("Aid {0} {1} {2}, age {3}, ", person.ActID, actorType, person.Name, person.Age);
                    //valid actor?
                    if (person.Name != null)
                    {
                        RLColor locColor = RLColor.White;
                        string locString = "?";
                        //location descriptor
                        switch (person.Status)
                        {
                            case ActorStatus.AtLocation:
                                locString = string.Format("at {0} {1}", GetLocationName(person.LocID), ShowLocationCoords(person.LocID));
                                break;
                            case ActorStatus.Travelling:
                                Position pos = person.GetActorPosition();
                                locString = string.Format("travelling to {0} {1}", GetLocationName(person.LocID), ShowLocationCoords(person.LocID));
                                break;
                            case ActorStatus.Gone:
                                locString = string.Format("Passed away ({0}) in {1}", person.ReasonGone, person.Gone);
                                locColor = RLColor.LightGray;
                                break;
                        }
                        houseList.Add(new Snippet(personText + locString, locColor, RLColor.Black));
                    }
                }
                //House Retainers - get list of all actorID's
                houseList.Add(new Snippet("Retainers", RLColor.Brown, RLColor.Black));
                List<int> listOfRetainers = new List<int>();
                refID = majorHouse.RefID;
                IEnumerable<int> Retainers =
                    from person in dictPassiveActors
                    where person.Value.RefID == refID && !(person.Value is Noble)
                    orderby person.Value.ActID
                    select person.Value.ActID;
                listOfRetainers = Retainers.ToList();
                // loop list and display each actor appropriately (dead in Lt.Gray)
                string type;
                foreach (int actorID in listOfRetainers)
                {
                    Passive person = GetPassiveActor(actorID);
                    //advisors can be one of three different categories
                    if (person is Advisor) { type = GetAdvisorType((Advisor)person); }
                    else { type = Convert.ToString(person.Type); }
                    personText = string.Format("Aid {0} {1} {2}, age {3}, ", person.ActID, type, person.Name, person.Age);
                    //valid actor?
                    if (person.Name != null)
                    {
                        RLColor locColor = RLColor.White;
                        string locString = "?";
                        //location descriptor
                        switch (person.Status)
                        {
                            case ActorStatus.AtLocation:
                                locString = string.Format("at {0} {1}", GetLocationName(person.LocID), ShowLocationCoords(person.LocID));
                                break;
                            case ActorStatus.Travelling:
                                Position pos = person.GetActorPosition();
                                locString = string.Format("travelling to {0} {1}", GetLocationName(person.LocID), ShowLocationCoords(person.LocID));
                                break;
                            case ActorStatus.Gone:
                                locString = string.Format("passed away ({0}) in {1}", person.ReasonGone, person.Gone);
                                locColor = RLColor.LightGray;
                                break;
                        }
                        houseList.Add(new Snippet(personText + locString, locColor, RLColor.Black));
                    }
                }
                //Relationships
                List<Relation> tempListRelations = majorHouse.GetRelations();
                if (tempListRelations != null && tempListRelations.Count > 0)
                {
                    houseList.Add(new Snippet("Relations with Other Houses", RLColor.Brown, RLColor.Black));
                    //display relations in chronological order
                    IEnumerable<string> relRecords =
                        from relation in tempListRelations
                        orderby relation.Year
                        select string.Format("{0}  {1} {2}, \"{3}\", Rel {4}{5}", relation.Year, relation.RefID >= 100 ? "(Minor)" : "(Major)",
                        GetHouseName(relation.RefID), relation.Text, relation.Change > 0 ? "+" : "", relation.Change);
                    List<string> tempRelRecords = relRecords.ToList();
                    //add snippets
                    foreach (string relText in tempRelRecords)
                    { houseList.Add(new Snippet(relText)); }
                }
                //house history
                List<string> houseHistory = GetHistoricalHouseRecords(majorHouse.RefID);
                if (houseHistory.Count > 0)
                {
                    houseList.Add(new Snippet("House History", RLColor.Brown, RLColor.Black));
                    foreach (string text in houseHistory)
                    { houseList.Add(new Snippet(text)); }
                }
            }
            return houseList;
        }


        /// <summary>
        /// display Royal Court, retainers and others at Kingskeep
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowCapitalRL()
        {
            List<Snippet> capitalList = new List<Snippet>();
            capitalList.Add(new Snippet(string.Format("Kingskeep, Kingdom Capital {0}", ShowLocationCoords(1)), RLColor.Yellow, RLColor.Black));
            int capitalWalls = Game.history.CapitalWalls;
            int capitalResources = Game.history.CapitalTreasury;
            capitalList.Add(new Snippet(string.Format("Strength of Castle Walls ({0}) ", (CastleDefences)capitalWalls), false));
            capitalList.Add(new Snippet(string.Format("{0}", GetStars(capitalWalls)), RLColor.LightRed, RLColor.Black));
            //placeholder
            capitalList.Add(new Snippet(string.Format("Kingdom Treasury Resources ({0}) ", (ResourceLevel)capitalResources), false));
            capitalList.Add(new Snippet(string.Format("{0}", GetStars(capitalResources)), RLColor.LightRed, RLColor.Black));
            //ROYAL FAMILY
            capitalList.Add(new Snippet("Royal Family", RLColor.Brown, RLColor.Black));
            int royalRefID = Game.lore.RoyalRefIDCurrent;
            //query royal family members at capital
            List<Passive> royalFamily = new List<Passive>();
            IEnumerable<Passive> listOfNobles =
                from actor in dictPassiveActors
                where actor.Value.LocID == 1 && actor.Value.RefID == royalRefID && actor.Value is Noble && actor.Value.Status == ActorStatus.AtLocation
                orderby actor.Value.ActID
                select actor.Value;
            royalFamily = listOfNobles.ToList();
            //add to list
            string actorOffice;
            foreach (Passive actor in royalFamily)
            {
                Noble noble = actor as Noble;
                if (noble.Office > ActorOffice.None)
                { actorOffice = Convert.ToString(noble.Office); }
                else { actorOffice = Convert.ToString(noble.Type); }
                capitalList.Add(new Snippet(string.Format("Aid {0} {1} {2}, age {3} at Kingskeep {4}", noble.ActID, actorOffice, noble.Name, noble.Age, ShowLocationCoords(1))));
            }
            //ROYAL COURT
            capitalList.Add(new Snippet("Royal Court", RLColor.Brown, RLColor.Black));
            foreach (KeyValuePair<int, Passive> kvp in dictRoyalCourt)
            {
                if (kvp.Value is Advisor)
                {
                    Advisor advisor = kvp.Value as Advisor;
                    actorOffice = Convert.ToString(advisor.advisorRoyal);
                }
                else { actorOffice = Convert.ToString(kvp.Value.Office); }
                capitalList.Add(new Snippet(string.Format("Aid {0} {1} {2}, age {3} at Kingskeep {4}", kvp.Value.ActID, actorOffice, kvp.Value.Name, kvp.Value.Age, ShowLocationCoords(1))));
            }
            //OTHERS
            List<Actor> assortedActors = new List<Actor>();
            IEnumerable<Actor> listOfActors =
                from actor in dictActiveActors
                where actor.Value.LocID == 1
                orderby actor.Value.ActID
                select actor.Value;
            assortedActors = listOfActors.ToList();
            //add to list
            if (assortedActors.Count > 0)
            {
                capitalList.Add(new Snippet("Others", RLColor.Brown, RLColor.Black));
                RLColor textColor;
                foreach (Actor actor in assortedActors)
                {
                    if (actor.Office > ActorOffice.None)
                    { actorOffice = Convert.ToString(actor.Office); }
                    else { actorOffice = Convert.ToString(actor.Type); }
                    //highlight active players
                    textColor = RLColor.White;
                    if (actor is Active)
                    {
                        if (actor is Player)
                        { textColor = Color._player; }
                        else
                        { textColor = Color._active; }
                    }
                    capitalList.Add(new Snippet(string.Format("Aid {0} {1} {2}, age {3} at Kingskeep {4}", actor.ActID, actorOffice, actor.Name, actor.Age, ShowLocationCoords(1)),
                        textColor, RLColor.Black));
                }
            }
            //Relationships (identical for the King's house)
            MajorHouse majorHouse = (MajorHouse)GetHouse(Game.lore.RoyalRefIDNew);
            if (majorHouse != null)
            {
                List<Relation> tempListRelations = majorHouse.GetRelations();
                if (tempListRelations != null && tempListRelations.Count > 0)
                {
                    capitalList.Add(new Snippet("Relations with Other Houses", RLColor.Brown, RLColor.Black));
                    //display relations in chronological order
                    IEnumerable<string> relRecords =
                        from relation in tempListRelations
                        orderby relation.Year
                        select string.Format("{0}  {1} {2}, \"{3}\", Rel {4}{5}", relation.Year, relation.RefID >= 100 ? "(Minor)" : "(Major)",
                        GetHouseName(relation.RefID), relation.Text, relation.Change > 0 ? "+" : "", relation.Change);
                    List<string> tempRelRecords = relRecords.ToList();
                    //add snippets
                    foreach (string relText in tempRelRecords)
                    { capitalList.Add(new Snippet(relText)); }
                }
            }
            else { Game.SetError(new Error(136, "New King's House not found (null)")); }

            return capitalList;
        }

        /// <summary>
        /// Select a Player Character from the displayed list
        /// </summary>
        /// <returns>Character ID</returns>
        public int ChooseActor()
        {
            Game.logTurn?.Write("--- ChooseActor (World.cs)");
            Game.logTurn?.Write("Which Character do you want to move (Enter ID #)? ");
            //Console.WriteLine("Which Character do you want to move (Enter ID #)? ");
            int charID = Convert.ToInt32(Console.ReadLine());
            Active person = new Active();
            //check character exists
            if (dictActiveActors.ContainsKey(charID))
            {
                person = dictActiveActors[charID];
                if (person.Status != ActorStatus.AtLocation)
                {
                    Game.logTurn?.Write("That Character isn't at a Location and can't be selected");
                    //Console.WriteLine("That Character isn't at a Location and can't be selected");
                    charID = 0;
                }
            }
            else
            {
                Game.logTurn?.Write("Character doesn't exist!");
                //Console.WriteLine("Character doesn't exist!");
                charID = 0;
            }
            return charID;
        }

        /// <summary>
        /// return a Passive actor from dictPassiveActors
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Passive GetPassiveActor(int actorID)
        {
            Passive person = new Passive();
            if (dictPassiveActors.ContainsKey(actorID))
            { person = dictPassiveActors[actorID]; }
            return person;
        }

        internal Dictionary<int, Passive> GetAllPassiveActors()
        { return dictPassiveActors; }

        /// <summary>
        /// return an Active actor from dictActiveActors, otherwise null
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Active GetActiveActor(int actorID)
        {
            Active person = new Active();
            if (dictActiveActors.ContainsKey(actorID))
            { person = dictActiveActors[actorID]; }
            else { person = null; }
            return person;
        }

        /// <summary>
        /// return an Enemy actor from dictenemyActors, otherwise null
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Enemy GetEnemyActor(int actorID)
        {
            Enemy person = new Enemy();
            if (dictEnemyActors.ContainsKey(actorID))
            { person = dictEnemyActors[actorID]; }
            else { person = null; }
            return person;
        }

        /// <summary>
        /// returns any actor -> Passive or Active
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        internal Actor GetAnyActor(int actorID)
        {
            Actor person = new Actor();
            if (dictAllActors.ContainsKey(actorID))
            { person = dictAllActors[actorID]; }
            else { person = null; }
            return person;
        }

        /// <summary>
        /// returns dictionary of Active Actors
        /// </summary>
        /// <returns></returns>
        internal Dictionary<int, Active> GetAllActiveActors()
        { return dictActiveActors; }

        /// <summary>
        /// returns string showing character name (at 'x' loc)
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public Snippet GetActorStatusRL(int actID)
        {
            Actor person = new Actor();
            RLColor foreColor = RLColor.White;
            string charReturn = "Character doesn't exist!";
            //check character exists
            if (dictActiveActors.ContainsKey(actID))
            {
                person = dictActiveActors[actID];
                charReturn = person.Name;
                if (person.Status != ActorStatus.AtLocation)
                { charReturn += " isn't currently available (must be at a Location in order to be Moved)"; foreColor = RLColor.LightRed; }
                else
                {
                    Position pos = person.GetActorPosition();
                    charReturn += " is awaiting your orders at ";
                    charReturn += GetLocationName(person.LocID);
                    charReturn += string.Format(" (loc {0}:{1})", pos.PosX, pos.PosY);
                }
            }
            return new Snippet(charReturn, foreColor, RLColor.Black);
        }

        /// <summary>
        /// returns true if Player at specified location and their status is 'AtLocation' (used by DrawMapRL)
        /// </summary>
        /// <param name="locID"></param>
        /// <returns></returns>
        public bool GetPlayerLocStatus(int locID)
        {
            //check player in dictionary
            if (dictActiveActors.ContainsKey(1))
            {
                Active player = dictActiveActors[1];
                if (player.Status == ActorStatus.AtLocation)
                {
                    if (player.LocID == locID)
                    { return true; }
                }
            }
            return false;
        }

        /// <summary>
        /// returns Revert # of days for specified active actor. A value of 0 indicates a status of Unknown (eg. 'Known' = false)
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public int GetActiveActorKnownStatus(int actID)
        {
            //check active actor in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active active = dictActiveActors[actID];
                if (active.Status != ActorStatus.Gone)
                { return active.Revert; }
                else { Game.SetError(new Error(137, string.Format("Active Actor, actID {0},  \"Gone\"", active.ActID))); }
            }
            else { Game.SetError(new Error(137, "Active Actor not found in dictActiveActors")); }
            return 0;
        }

        /// <summary>
        /// returns true if specified actor has the indicated status, otherwise false
        /// </summary>
        /// <param name="actorID"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        public bool CheckActorStatus(int actorID, ActorStatus status)
        {
            Actor actor = GetAnyActor(actorID);
            if (actor != null)
            { if (actor.Status == status) { return true; } }
            else { Game.SetError(new Error(191, string.Format("Invalid Actor input (null), ActID {0}, status {1}", actorID, status))); }
            return false;
        }


        /// <summary>
        /// nameOnly true -> actor.Name, nameOnly false -> actors Title + Name + ActID + 'at' + Location ('Coords)
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public string GetActorDetails(int actID, bool nameOnly = true)
        {
            string details = "";
            //check active actor in dictionary
            if (dictAllActors.ContainsKey(actID))
            {
                Actor actor = dictAllActors[actID];
                if (nameOnly == true)
                { return actor.Name; }
                else
                { return string.Format("{0} {1}, ActID {2} at {3} {4}", actor.Title, actor.Name, actor.ActID, GetLocationName(actor.LocID), ShowLocationCoords(actor.LocID)); }
            }
            else { Game.SetError(new Error(172, string.Format("Actor not found in dictAllActors (ActID {0})", actID))); }
            return details;
        }

        /// <summary>
        /// returns num days since player was last Known
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public int GetActiveActorTrackingStatus(int actID)
        {
            //check active actor in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active active = dictActiveActors[actID];
                if (active.Status != ActorStatus.Gone)
                { return active.TurnsUnknown; }
                else { Game.SetError(new Error(137, string.Format("Active Actor, actID {0},  \"Gone\"", active.ActID))); }
            }
            else { Game.SetError(new Error(137, "Active Actor not found in dictActiveActors")); }
            return 0;
        }

        /// <summary>
        /// change an Active Actors known status -> data +ve then switch to UNKNOWN, if -ve then KNOWN (if already Known then reset Revert timer to 0). Returns MT if insuccessful
        /// </summary>
        /// <param name="actID"></param>
        /// <param name="data">data +ve then switch to UNKNOWN, if -ve then KNOWN</param>
        /// <returns></returns>
        public string SetActiveActorKnownStatus(int actID, int data)
        {
            string resultText = "";
            int maxRevert = Game.constant.GetValue(Global.KNOWN_REVERT);
            //check active actor in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active active = dictActiveActors[actID];
                if (active.Status != ActorStatus.Gone)
                {
                    if (data < 0)
                    {
                        //KNOWN -> if already known resert Revert timer to the max.
                        if (active.Known == true)
                        { resultText = string.Format("{0} {1} has had their Known timer increased to the maximum ({2} days)", active.Title, active.Name, maxRevert); }
                        else
                        { active.Known = true; resultText = string.Format("{0} {1} is now KNOWN ({2} days)", active.Title, active.Name, maxRevert); }
                        active.Revert = maxRevert;
                        //reset TurnsUnknown timer back to zero
                        active.TurnsUnknown = 0;
                        active.LastKnownLocID = active.LocID;
                    }
                    else if (data > 0)
                    {
                        //Unknown
                        active.Known = false;
                        active.Revert = 0;
                        resultText = string.Format("{0} {1} is now UNKNOWN", active.Title, active.Name);
                    }
                    else { Game.SetError(new Error(138, "Invalid Data Input (zero)")); }
                    return resultText;
                }
                else { Game.SetError(new Error(138, string.Format("Active Actor, actID {0},  \"Gone\"", active.ActID))); }
            }
            else { Game.SetError(new Error(138, "Active Actor not found in dictActiveActors")); }
            return resultText;
        }

        /// <summary>
        /// selects an active actor for movement orders if at a location and activated
        /// </summary>
        /// <param name="charID"></param>
        /// <returns></returns>
        internal Position GetActiveActorLocationByPos(int charID)
        {
            Position pos = new Position();
            //find in dictionary
            if (dictActiveActors.ContainsKey(charID))
            {
                Active person = dictActiveActors[charID];
                pos = person.GetActorPosition();
                //can't be selected if not activated
                if (person.Activated == false) { pos = null; }
            }
            else
            { pos = null; }
            return pos;
        }


        /// <summary>
        /// returns current Loc (their destination if travelling)
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public int GetActiveActorLocByID(int actID)
        {
            int locID = 0;
            //find in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active person = dictActiveActors[actID];
                locID = person.LocID;
            }
            return locID;
        }

        /// <summary>
        /// returns Last Known Loc of Active Actor (their destination if travelling)
        /// </summary>
        /// <param name="actID"></param>
        /// <returns></returns>
        public int GetActiveActorLastKnownLoc(int actID)
        {
            int locID = 0;
            //find in dictionary
            if (dictActiveActors.ContainsKey(actID))
            {
                Active person = dictActiveActors[actID];
                locID = person.LastKnownLocID;
            }
            return locID;
        }

        /// <summary>
        /// Checks dictSpecialActors and, if found, returns ActorID, otherwise '0'
        /// </summary>
        /// <param name="specialID"></param>
        /// <returns></returns>
        internal int GetSpecialActorID(int specialID)
        {
            int actorID = 0;
            if (specialID > 0)
            {
                if (dictSpecialActors.ContainsKey(specialID))
                {
                    Special person = dictSpecialActors[specialID];
                    return person.ActID;
                }
            }
            else { Game.SetError(new Error(213, "Invalid specialID (zero, or less)")); }
            return actorID;
        }

        /// <summary>
        /// receives list of Houses from Network and places in releveant House Dictionaries for permanent use
        /// </summary>
        /// <param name="listOfHouses"></param>
        internal void InitialiseHouses()
        {

            Game.network.UpdateHouses(Game.history.GetGreatHouses());
            Game.logStart?.Write("---  InitialiseHouses (World.cs) ---");
            //great houses
            List<MajorHouse> listOfGreatHouses = Game.history.GetGreatHouses();
            foreach (MajorHouse house in listOfGreatHouses)
            { AddMajorHouse(house); }
            //populate sorted dictionary (descending) of house ID's by Power (# of BannerLords)
            SortMajorHouses();
            //minor houses
            List<House> listOfMinorHouses = Game.history.GetMinorHouses();
            foreach (House house in listOfMinorHouses)
            { dictAllHouses.Add(house.RefID, house); }
            //initialise Special Locations
            Game.history.InitialiseSpecialHouses();
            //update Map layer for RefID
            int locID = 0;
            int refID = 0;
            foreach (KeyValuePair<int, House> record in dictAllHouses)
            {
                locID = record.Value.LocID;
                refID = record.Value.RefID;
                Location loc = Game.network.GetLocation(locID);
                if (loc != null) { Game.map.SetMapInfo(MapLayer.RefID, loc.GetPosX(), loc.GetPosY(), refID); }
                else { Game.SetError(new Error(188, "Invalid Loc (null) Map Layer not updated")); }
            }
            //populate list of Bannerlord RefID's in Great Houses
            foreach (MajorHouse house in listOfGreatHouses)
            {
                List<int> bannerLords = house.GetBannerLordLocations();
                int minorRefID;
                if (bannerLords.Count > 0)
                {
                    foreach (int minorLocID in bannerLords)
                    {
                        Location loc = Game.network.GetLocation(minorLocID);
                        if (loc != null)
                        {
                            minorRefID = Game.map.GetMapInfo(MapLayer.RefID, loc.GetPosX(), loc.GetPosY());
                            house.AddBannerLord(minorRefID);
                        }
                        else { Game.SetError(new Error(188, "Invalid minorLoc (null) Bannerlord not added to Great House list")); }
                    }
                }
            }
            //fill Great Houses with Lords and Ladies
            Game.logStart?.Write("- House Genetics (add Lords and Ladies)");
            foreach (KeyValuePair<int, MajorHouse> kvp in dictMajorHouses)
            {
                //create Lord and Lady for house
                Location loc = Game.network.GetLocation(kvp.Value.LocID);
                if (loc != null)
                {
                    Position pos = loc.GetPosition();
                    Noble actorLord = (Noble)Game.history.CreateStartingHouseActor(kvp.Value.Name, ActorType.Lord, pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID);
                    Noble actorLady = (Noble)Game.history.CreateStartingHouseActor(kvp.Value.Name, ActorType.Lady, pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID,
                        ActorSex.Female, WifeStatus.First_Wife);
                    //add Lord to House
                    kvp.Value.LordID = actorLord.ActID;
                    //create a knight, castellan and maester for each Major house
                    Knight actorKnight = Game.history.CreateKnight(pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID);
                    Advisor actorCastellan = Game.history.CreateAdvisor(pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID, ActorSex.Male, AdvisorNoble.Castellan);
                    Advisor actorMaester = Game.history.CreateAdvisor(pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID, ActorSex.Male, AdvisorNoble.Maester);
                    Advisor actorSepton = Game.history.CreateAdvisor(pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID, ActorSex.Male, AdvisorNoble.Septon);
                    //add to dictionaries of actors
                    SetPassiveActor(actorLord);
                    SetPassiveActor(actorLady);
                    SetPassiveActor(actorKnight);
                    SetPassiveActor(actorCastellan);
                    SetPassiveActor(actorMaester);
                    SetPassiveActor(actorSepton);
                    //create family
                    Game.history.CreateFamily(actorLord, actorLady);
                }
                else { Game.SetError(new Error(188, "Invalid Loc (null) Lord and Lady not created")); }
                //check if lady died in childbirth
                /* if (actorLady.Status == ActorStatus.Gone)
                 {
                     int yearWifeDied = actorLady.Died;
                     //40% chance of remarrying
                     if (rnd.Next(100) < 40)
                     {
                         //new wife
                         Passive actor2ndWife = Game.history.CreatePassiveActor(kvp.Value.Name, ActorTitle.Lady, pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID, 
                             ActorSex.Female, WifeStatus.Second_Wife);
                         //add to dictionaries of actors
                         dictPassiveActors.Add(actor2ndWife.ActID, actor2ndWife);
                         dictAllActors.Add(actor2ndWife.ActID, actor2ndWife);
                         //location born (different for lady)
                         House wife2ndHouse = GetHouse(actor2ndWife.BornRefID);
                         Location loc2ndWife = Game.network.GetLocation(wife2ndHouse.LocID);
                         descriptor = string.Format("{0} (nee {1}, Aid {2}) born at {3}", actor2ndWife.Name, actor2ndWife.MaidenName, actor2ndWife.ActID, loc2ndWife.LocName);
                         Record record2ndWife = new Record(descriptor, actor2ndWife.ActID, loc2ndWife.LocationID, actor2ndWife.BornRefID, actor2ndWife.Born, HistEvent.Born);
                         //create records of being born
                         SetRecord(record2ndWife);
                         //store actor in location
                         loc.AddActor(actor2ndWife.ActID);
                         //create family
                         Game.history.CreatePassiveFamily(actorLord, actor2ndWife);
                     }
                 }*/
            }
            //hand out bastards and adopted sons to lords with no heirs
            CheckGreatLords();
            //fill minor houses with BannerLords
            foreach (KeyValuePair<int, House> kvp in dictAllHouses)
            {
                //minor houses only
                if (kvp.Value is MinorHouse)
                {
                    //create BannerLord for house
                    Location loc = Game.network.GetLocation(kvp.Value.LocID);
                    if (loc != null)
                    {
                        Position pos = loc.GetPosition();
                        BannerLord bannerLord = (BannerLord)Game.history.CreateStartingHouseActor(kvp.Value.Name, ActorType.BannerLord, pos, kvp.Value.LocID, kvp.Value.RefID, kvp.Value.HouseID);
                        //add to dictionaries of actors
                        dictPassiveActors.Add(bannerLord.ActID, bannerLord);
                        dictAllActors.Add(bannerLord.ActID, bannerLord);
                        //add Lord to house
                        kvp.Value.LordID = bannerLord.ActID;
                    }
                    else { Game.SetError(new Error(188, "Invalid Loc (null) Bannerlord not created")); }
                }
            }
            //assign 9999 refId to the capital
            Location capital = Game.network.GetLocation(1);
            if (capital != null)
            { Game.map.SetMapInfo(MapLayer.RefID, capital.GetPosX(), capital.GetPosY(), 9999); }
            else { Game.SetError(new Error(188, "Invalid CapitalLoc (null) RefID not updated")); }
        }

        /// <summary>
        /// creates dictHousePower of strongest to weakest houses
        /// </summary>
        internal void SortMajorHouses()
        {
            dictHousePower.Clear();
            foreach (KeyValuePair<int, int> kvp in dictMajorHouseID.OrderByDescending(key => key.Value))
            { dictHousePower.Add(kvp.Key, kvp.Value); }
        }

        /// <summary>
        /// adds a Major House to all relevant dictionaries
        /// </summary>
        /// <param name="house"></param>
        internal void AddMajorHouse(MajorHouse house)
        {
            try
            {
                dictMajorHouses.Add(house.HouseID, house);
                dictAllHouses.Add(house.RefID, house);
                dictMajorHouseID.Add(house.HouseID, house.GetNumBannerLords());
            }
            catch (Exception e)
            { Game.SetError(new Error(34, e.Message)); }
        }

        /// <summary>
        /// Add non-Major house to the only relevant dictionary
        /// </summary>
        /// <param name="house"></param>
        internal void AddOtherHouse(House house)
        { dictAllHouses.Add(house.RefID, house); }

        /// <summary>
        /// Add a possession to the dictionary, return true if successful
        /// </summary>
        /// <param name="possID"></param>
        /// <param name="possObject"></param>
        /// <returns></returns>
        public bool AddPossession(int possID, Possession possObject)
        {
            try
            { dictPossessions.Add(possID, possObject); return true; }
            catch (ArgumentNullException)
            { Game.SetError(new Error(123, "Invalid Possession Object (null), possID")); }
            catch (ArgumentException)
            { Game.SetError(new Error(123, string.Format("Invalid possessionID (duplicate ID), possID {0}", possID))); }
            return false;
        }

        /// <summary>
        /// find entry with same RefID in dictAllHouses and removes it if present (used by lore.cs CreateNewMajorHouse)
        /// </summary>
        /// <param name="refID"></param>
        internal void RemoveMinorHouse(int refID)
        {
            if (!dictAllHouses.Remove(refID))
            { Game.SetError(new Error(35, "House not found")); }
        }

        /// <summary>
        /// find and remove Great House from all relevant dictionaries
        /// </summary>
        /// <param name="refID"></param>
        internal void RemoveMajorHouse(House house)
        {
            //if (!dictAllHouses.Remove(house.RefID)) -> leave this as it doesn't affect major house calculations and retains house records
            //{ Game.SetError(new Error(35, "House not found")); }
            if (!dictMajorHouses.Remove(house.HouseID))
            { Game.SetError(new Error(35, "House not found")); }
            if (!dictMajorHouseID.Remove(house.HouseID))
            { Game.SetError(new Error(35, "House not found")); }
        }

        /// <summary>
        /// checks GreatLords for having no sons at Game Start
        /// </summary>
        private void CheckGreatLords()
        {
            //loop all passive actors
            bool foundSon;
            int wifeID = 0;
            int yearUpper; //upper and lower bounds for determining what year child is born
            int yearLower;
            int yearBorn;
            List<int> listOfLords = new List<int>(); //ActID of lords who are in need of a son
            List<int> listOfLadies = new List<int>(); //ActID of ladies who are in need of a son (lord and lady have identical indexes)
            foreach (KeyValuePair<int, Passive> kvp in dictPassiveActors)
            {
                foundSon = false;
                //lord?
                if (kvp.Value.Type == ActorType.Lord && kvp.Value.Status != ActorStatus.Gone)
                {
                    //Loop family looking for a son
                    Noble noble = kvp.Value as Noble;
                    SortedDictionary<int, ActorRelation> tempDictFamily = noble.GetFamily();
                    foreach (KeyValuePair<int, ActorRelation> family_kvp in tempDictFamily)
                    {
                        if (family_kvp.Value == ActorRelation.Son)
                        { foundSon = true; }
                        else if (family_kvp.Value == ActorRelation.Wife)
                        { wifeID = family_kvp.Key; }
                    }
                    //if no son provide one
                    if (foundSon == false)
                    {
                        listOfLords.Add(kvp.Value.ActID);
                        listOfLadies.Add(wifeID);
                    }
                }
            }
            //who needs a son?
            if (listOfLords.Count > 0)
            {
                for (int i = 0; i < listOfLords.Count; i++)
                {
                    //50/50 bastard or adopted
                    ActorParents parents = ActorParents.Bastard;
                    if (rnd.Next(100) < 50)
                    { parents = ActorParents.Adopted; }
                    //create a child
                    Noble Lord = (Noble)GetPassiveActor(listOfLords[i]);
                    Noble Lady = (Noble)GetPassiveActor(listOfLadies[i]);
                    //get year
                    yearUpper = Game.gameRevolt;
                    if (Lady.Status == ActorStatus.Gone)
                    { yearUpper = Lady.Gone; }
                    yearLower = Lady.Married;
                    yearBorn = rnd.Next(yearLower, yearUpper);
                    Game.history.CreateChild(Lord, Lady, yearBorn, ActorSex.Male, parents);
                }
            }
        }


        /// <summary>
        /// populates dictionary of GeoLocations
        /// </summary>
        private void InitialiseGeoClusters()
        {
            List<GeoCluster> tempList = Game.history.GetGeoClusters();
            foreach (GeoCluster cluster in tempList)
            { dictGeoClusters.Add(cluster.GeoID, cluster); }
        }

        /// <summary>
        /// populates dictionary of Traits
        /// </summary>
        private void InitialiseTraits()
        {
            List<Skill> tempList = Game.history.GetTraits();
            foreach (Skill trait in tempList)
            { dictTraits.Add(trait.SkillID, trait); }
        }

        /// <summary>
        /// populates Possession dictionary with Secrets
        /// </summary>
        private void InitialiseSecrets()
        {
            List<Secret> tempList = Game.history.GetSecrets();
            if (tempList != null)
            {
                foreach (Secret secret in tempList)
                {
                    try
                    { dictPossessions.Add(secret.PossID, secret); }
                    catch (ArgumentNullException)
                    { Game.SetError(new Error(198, "Invalid Secret (null) -> Not added to Dictionary")); }
                    catch (ArgumentException)
                    { Game.SetError(new Error(198, string.Format("Invalid secret.PossID \"{0}\" (duplicate) -> Not added to Dictionary", secret.PossID))); }
                }
            }
            else { Game.SetError(new Error(198, "Invalid dictionary input -> history.GetSecrets (null)")); }
        }

        /// <summary>
        /// populates Possession dictionary with Items
        /// </summary>
        private void InitialiseItems()
        {
            Game.logStart?.Write("--- InitialiseItems (World.cs)");
            List<Item> tempList = Game.file.GetItems("Items.txt");
            if (tempList != null)
            {
                foreach (Item item in tempList)
                {
                    try
                    { dictPossessions.Add(item.PossID, item); }
                    catch (ArgumentNullException)
                    { Game.SetError(new Error(199, "Invalid Item (null) -> Not added to Dictionary")); }
                    catch (ArgumentException)
                    { Game.SetError(new Error(199, string.Format("Invalid item.PossID \"{0}\" (duplicate) -> Not added to Dictionary", item.PossID))); }
                }
            }
            else { Game.SetError(new Error(199, "Invalid dictionary input -> history.GetSecrets (null)")); }
        }

        /// <summary>
        /// places a message in info panel detailing all relevant data for a single generation
        /// </summary>
        public void ShowGeneratorStatsRL()
        {
            List<Snippet> listStats = new List<Snippet>();
            //calcs
            int numLocs = Game.network.GetNumLocations();
            int numGreatHouses = dictMajorHouses.Count;
            int numSpecialLocs = Game.network.GetNumSpecialLocations();
            int numBannerLords = dictAllHouses.Count - numGreatHouses - 1 - numSpecialLocs;
            int numActors = dictAllActors.Count;
            int numChildren = numActors - (numGreatHouses * 2) - numBannerLords;
            //int numSecrets = dictSecrets.Count;
            int numSecrets = GetPossessionsCount(PossessionType.Secret);
            //checksum
            if (numLocs != numGreatHouses + numSpecialLocs + numBannerLords + 1)
            { Game.SetError(new Error(25, "Locations don't tally")); }
            int numErrors = Game.GetErrorCount();
            //data
            listStats.Add(new Snippet("--- Generation Statistics", RLColor.Yellow, RLColor.Black));
            listStats.Add(new Snippet(string.Format("{0} Locations", numLocs)));
            listStats.Add(new Snippet(string.Format("{0} Great Houses", numGreatHouses)));
            listStats.Add(new Snippet(string.Format("{0} BannerLords", numBannerLords)));
            listStats.Add(new Snippet(string.Format("{0} Special Locations", numSpecialLocs)));
            listStats.Add(new Snippet("1 Capital"));
            listStats.Add(new Snippet(string.Format("{0} Actors ({1} Children)", numActors, numChildren)));
            if (numSecrets > 0) { listStats.Add(new Snippet(string.Format("{0} Secrets", numSecrets))); }
            if (numErrors > 0) { listStats.Add(new Snippet(string.Format("{0} Errors", numErrors), RLColor.LightRed, RLColor.Black)); }
            //list of all Greathouses by power
            listStats.Add(new Snippet("Great Houses", RLColor.Yellow, RLColor.Black));
            string housePower;
            foreach (KeyValuePair<int, int> kvp in dictHousePower)
            {
                MajorHouse house = GetMajorHouse(kvp.Key);
                housePower = string.Format("Hid {0} House {1} has {2} BannerLords  {3}, Loyal to the {4} (orig {5})", house.HouseID, house.Name, house.GetNumBannerLords(),
                    ShowLocationCoords(house.LocID), house.Loyalty_Current, house.Loyalty_AtStart);
                listStats.Add(new Snippet(housePower));
            }

            //if start of game also show Errors
            if (Game.gameTurn == 0)
            {
                List<Snippet> tempList = Game.ShowErrorsRL();
                if (tempList.Count > 0)
                {
                    listStats.Add(new Snippet(""));
                    listStats.Add(new Snippet(""));
                    listStats.Add(new Snippet(""));
                    listStats.Add(new Snippet("--- Errors ALL", RLColor.LightRed, RLColor.Black));
                    listStats.AddRange(tempList);
                }
            }
            //display data
            Game.infoChannel.SetInfoList(listStats, ConsoleDisplay.Multi);
        }

        /// <summary>
        /// Show game state as well as the date as the default input display (green if Good has increased, red if Bad)
        /// </summary>
        public void ShowGameStateRL()
        {
            int data, good, bad, change;
            List<Snippet> listStats = new List<Snippet>();
            RLColor increase = Color._increase;
            RLColor decrease = Color._decrease;
            RLColor foreground;
            //Date
            listStats.Add(new Snippet(Game.utility.ShowDate(), RLColor.Yellow, RLColor.Black));
            //justice
            data = Game.director.CheckGameState(DataPoint.Justice);
            good = Game.director.GetGameState(DataPoint.Justice, DataState.Good);
            bad = Game.director.GetGameState(DataPoint.Justice, DataState.Bad);
            change = Game.director.CheckGameStateChange(DataPoint.Justice);
            foreground = RLColor.White;
            if (change > 0) { foreground = increase; }
            else if (change < 0) { foreground = decrease; }
            listStats.Add(new Snippet(string.Format("{0, -18} {1} %  (good {2} bad {3})", "Justice (Cause)", data, good, bad), foreground, RLColor.Black));
            //legend_usurper
            data = Game.director.CheckGameState(DataPoint.Legend_Usurper);
            good = Game.director.GetGameState(DataPoint.Legend_Usurper, DataState.Good);
            bad = Game.director.GetGameState(DataPoint.Legend_Usurper, DataState.Bad);
            change = Game.director.CheckGameStateChange(DataPoint.Legend_Usurper);
            foreground = RLColor.White;
            if (change > 0) { foreground = increase; }
            else if (change < 0) { foreground = decrease; }
            listStats.Add(new Snippet(string.Format("{0, -18} {1} %  (good {2} bad {3})", "Legend (You)", data, good, bad), foreground, RLColor.Black));
            //legend_king
            data = Game.director.CheckGameState(DataPoint.Legend_King);
            good = Game.director.GetGameState(DataPoint.Legend_King, DataState.Good);
            bad = Game.director.GetGameState(DataPoint.Legend_King, DataState.Bad);
            change = Game.director.CheckGameStateChange(DataPoint.Legend_King);
            foreground = RLColor.White;
            if (change > 0) { foreground = increase; }
            else if (change < 0) { foreground = decrease; }
            listStats.Add(new Snippet(string.Format("{0, -18} {1} %  (good {2} bad {3})", "Legend (King)", data, good, bad), foreground, RLColor.Black));
            //honour_usurper
            data = Game.director.CheckGameState(DataPoint.Honour_Usurper);
            good = Game.director.GetGameState(DataPoint.Honour_Usurper, DataState.Good);
            bad = Game.director.GetGameState(DataPoint.Honour_Usurper, DataState.Bad);
            change = Game.director.CheckGameStateChange(DataPoint.Honour_Usurper);
            foreground = RLColor.White;
            if (change > 0) { foreground = increase; }
            else if (change < 0) { foreground = decrease; }
            listStats.Add(new Snippet(string.Format("{0, -18} {1} %  (good {2} bad {3})", "Honour (You)", data, good, bad), foreground, RLColor.Black));
            //honour_king
            data = Game.director.CheckGameState(DataPoint.Honour_King);
            good = Game.director.GetGameState(DataPoint.Honour_King, DataState.Good);
            bad = Game.director.GetGameState(DataPoint.Honour_King, DataState.Bad);
            change = Game.director.CheckGameStateChange(DataPoint.Honour_King);
            foreground = RLColor.White;
            if (change > 0) { foreground = increase; }
            else if (change < 0) { foreground = decrease; }
            listStats.Add(new Snippet(string.Format("{0, -18} {1} %  (good {2} bad {3})", "Honour (King)", data, good, bad), foreground, RLColor.Black));

            //show Visibility status
            int knownStatus = GetActiveActorKnownStatus(1);
            if (knownStatus > 0)
            { listStats.Add(new Snippet(string.Format("Known, reverts in {0} day{1}", knownStatus, knownStatus == 1 ? "" : "s"), Color._badTrait, RLColor.Black)); }
            else { listStats.Add(new Snippet("Unknown (the Inquisitors don't know your location)", Color._goodTrait, RLColor.Black)); }

            //display data
            Game.infoChannel.SetInfoList(listStats, ConsoleDisplay.Input);
        }

        /// <summary>
        /// Quickly access a house name using houseID
        /// </summary>
        /// <param name="houseID"></param>
        /// <returns></returns>
        public string GetMajorHouseName(int houseID)
        {
            string houseName = "";
            MajorHouse house = new MajorHouse();
            if (dictMajorHouses.TryGetValue(houseID, out house))
            { houseName = house.Name; }
            return houseName;
        }

        /// <summary>
        /// Returns name of house (major, minor or Inn) using Ref ID
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        public string GetHouseName(int refID)
        {
            string houseName = "";
            House house = new House();
            if (dictAllHouses.TryGetValue(refID, out house))
            { houseName = house.Name; }
            return houseName;
        }

        internal Dictionary<int, MajorHouse> GetAllMajorHouses()
        { return dictMajorHouses; }

        internal Dictionary<int, Passive> GetRoyalCourt()
        { return dictRoyalCourt; }

        /// <summary>
        /// Returns Great house if found, otherwise null, keyed of
        /// </summary>
        /// <param name="houseID"></param>
        /// <returns></returns>
        internal MajorHouse GetMajorHouse(int houseID)
        {
            MajorHouse house = new MajorHouse();
            if (dictMajorHouses.TryGetValue(houseID, out house))
            { return house; }
            return null;
        }

        /// <summary>
        /// Returns house (any type) if found, otherwise null, keyed off refID)
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal House GetHouse(int refID)
        {
            House house = new House();
            if (dictAllHouses.TryGetValue(refID, out house))
            { return house; }
            return null;
        }

        /// <summary>
        /// Query to return list of strings containing selected actor's personal history (includes those of Player)
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        private List<string> GetActorHistoricalRecords(int actorID)
        {
            List<string> actorRecords = new List<string>();
            if (actorID > 0)
            {
                //query
                IEnumerable<string> actorHistory =
                    from actor in dictHistoricalRecords
                    from actID in actor.Value.listOfActors
                    where actID == actorID
                    orderby actor.Value.Year
                    select Convert.ToString(actor.Value.Year + " " + actor.Value.Text);
                //place filtered data into list
                actorRecords = actorHistory.ToList();
            }
            else { Game.SetError(new Error(144, "Invalid actorID (0 or less)")); }
            return actorRecords;
        }

        /// <summary>
        /// Query to return list of strings containing selected actor's current game-start onwards records (excludes those of Player)
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        private List<string> GetActorCurrentRecords(int actorID)
        {
            List<string> actorRecords = new List<string>();
            if (actorID > 1)
            {
                //query
                IEnumerable<string> actorCurrent =
                    from actor in dictCurrentRecords
                    from actID in actor.Value.listOfActors
                    where actID == actorID
                    orderby actor.Value.Year
                    select Convert.ToString("Day " + actor.Value.Day + ", " + actor.Value.Year + " " + actor.Value.Text);
                //place filtered data into list
                actorRecords = actorCurrent.ToList();
            }
            else { Game.SetError(new Error(142, "Invalid actorID (1 or less)")); }
            return actorRecords;
        }

        /// <summary>
        /// Query to return list of strings containing Player's current game-start onwards records
        /// </summary>
        /// <param name="actorID"></param>
        /// <returns></returns>
        private List<string> GetPlayerCurrentRecords(int actorID)
        {
            List<string> actorRecords = new List<string>();
            if (actorID == 1)
            {
                //query
                IEnumerable<string> actorPlayer =
                    from actor in dictPlayerRecords
                    from actID in actor.Value.listOfActors
                    where actID == actorID
                    orderby actor.Value.Year
                    select Convert.ToString("Day " + actor.Value.Day + ", " + actor.Value.Year + " " + actor.Value.Text);
                //place filtered data into list
                actorRecords = actorPlayer.ToList();
            }
            else { Game.SetError(new Error(142, "Invalid actorID (Not that of the Players)")); }
            return actorRecords;
        }

        /// <summary>
        /// Query to return list of strings containing selected house's history
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        private List<string> GetHistoricalHouseRecords(int refID)
        {
            List<string> houseRecords = new List<string>();
            //query
            IEnumerable<string> houseHistory =
                from house in dictHistoricalRecords
                from _refID in house.Value.listOfHouses
                where _refID == refID
                orderby house.Value.Year
                select Convert.ToString(house.Value.Year + " " + house.Value.Text);
            //place filtered data into list
            houseRecords = houseHistory.ToList();
            return houseRecords;
        }

        public int GetGreatHouseRefID(int houseID)
        {
            MajorHouse house = new MajorHouse();
            if (dictMajorHouses.TryGetValue(houseID, out house))
            { return house.RefID; }
            return 0;
        }

        internal GeoCluster GetGeoCluster(int geoID)
        {
            GeoCluster cluster = new GeoCluster();
            if (dictGeoClusters.TryGetValue(geoID, out cluster))
            { return cluster; }
            return null;
        }

        internal Skill GetTrait(int traitID)
        {
            Skill trait = new Skill();
            if (dictTraits.TryGetValue(traitID, out trait))
            { return trait; }
            return null;
        }

        internal Possession GetPossession(int possID)
        {
            if (possID > 0)
            {
                Possession possession = new Possession();
                if (dictPossessions.TryGetValue(possID, out possession))
                { return possession; }
            }
            else { Game.SetError(new Error(205, "Invalid PossID (zero, or less)")); }
            return null;
        }

        /// <summary>
        /// returns an Item from the Possessions Dict, null if not found
        /// </summary>
        /// <param name="possID"></param>
        /// <returns></returns>
        internal Item GetItem(int possID)
        {
            if (possID > 0)
            {
                Possession possession = new Possession();
                if (dictPossessions.TryGetValue(possID, out possession))
                {
                    if (possession is Item)
                    {
                        Item item = possession as Item;
                        return item;
                    }
                    else { Game.SetError(new Error(204, string.Format("Invalid possession -> should be an Item but isn't (possID {0})", possID))); }
                }
            }
            else { Game.SetError(new Error(204, "Invalid PossID (zero, or less)")); }
            return null;
        }

        /// <summary>
        /// Pre-Game start records for everybody including Player
        /// </summary>
        /// <param name="record"></param>
        internal void SetHistoricalRecord(Record record)
        {
            try
            { dictHistoricalRecords.Add(record.trackerID, record); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(139, "Invalid record (null)")); }
            catch (ArgumentException)
            { Game.SetError(new Error(139, string.Format("Invalid Record TrackerID \"{0}\" (duplicate)", record.trackerID))); }
        }

        /// <summary>
        /// Game start onwards records for everybody except the Player
        /// </summary>
        /// <param name="record"></param>
        internal void SetCurrentRecord(Record record)
        {
            try
            { dictCurrentRecords.Add(record.trackerID, record); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(140, "Invalid record (null)")); }
            catch (ArgumentException)
            { Game.SetError(new Error(140, string.Format("Invalid Record TrackerID \"{0}\" (duplicate)", record.trackerID))); }
        }

        /// <summary>
        /// Game start onwards records for the Player
        /// </summary>
        /// <param name="record"></param>
        internal void SetPlayerRecord(Record record)
        {
            try
            { dictPlayerRecords.Add(record.trackerID, record); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(141, "Invalid record (null)")); }
            catch (ArgumentException)
            { Game.SetError(new Error(141, string.Format("Invalid Record TrackerID \"{0}\" (duplicate)", record.trackerID))); }
        }

        /// <summary>
        /// handle a new message appropriately
        /// </summary>
        /// <param name="message"></param>
        internal void SetMessage(Message message)
        {
            if (message != null)
            {
                RLColor color = RLColor.White;
                if (message.Type == MessageType.Activation) { color = Color._active; }
                //queue for the most recent messages to display at bottom right console window
                Snippet snippet = new Snippet(string.Format("Day {0}, {1}, {2}", message.Day, message.Year, message.Text), color, RLColor.Black);
                messageQueue.Enqueue(snippet);
                //max 8 entries in queue at any one time
                if (messageQueue.Count > 8)
                { messageQueue.Dequeue(); }
                //add to dictionary
                dictMessages.Add(message.trackerID, message);
                //debug -> doesn't work 'cause called by both logStart and logTurn
                //Game.logTurn.Write(string.Format("Message -> [{0}] Day {1}, {2}, {3}", message.Type, message.Day, message.Year, message.Text));
            }
        }


        /// <summary>
        /// Store a new actor (child,regent brother, etc.) in relevant dictionaries
        /// </summary>
        /// <param name="actor"></param>
        internal void SetPassiveActor(Passive actor)
        {
            try
            {
                dictPassiveActors.Add(actor.ActID, actor);
                dictAllActors.Add(actor.ActID, actor);
            }
            catch (ArgumentNullException)
            { Game.SetError(new Error(211, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(211, "Invalid actor.ActID (duplicate key exists) -> Record not saved")); }
        }

        /// <summary>
        /// store a new actor (player and follower)
        /// </summary>
        /// <param name="actor"></param>
        internal void SetActiveActor(Active actor)
        {
            try
            {
                dictActiveActors.Add(actor.ActID, actor);
                dictAllActors.Add(actor.ActID, actor);
            }
            catch (ArgumentNullException)
            { Game.SetError(new Error(150, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(150, "Invalid actor.ActID (duplicate key exists) -> Record not saved")); }
        }

        /// <summary>
        /// store a new special (NPC) actor
        /// </summary>
        /// <param name="actor"></param>
        internal void SetSpecialActor(Special actor)
        {
            try
            {
                dictPassiveActors.Add(actor.ActID, actor);
                dictAllActors.Add(actor.ActID, actor);
                dictSpecialActors.Add(actor.SpecialID, actor);
            }
            catch (ArgumentNullException)
            { Game.SetError(new Error(150, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(150, "Invalid ActID or SpecialID (duplicate key exists) -> Record not saved")); }
        }


        /// <summary>
        /// store a Royal court member in relevant dict
        /// </summary>
        /// <param name="actor"></param>
        internal void SetRoyalCourt(Passive actor)
        {
            try
            { dictRoyalCourt.Add(actor.ActID, actor); }
            catch (ArgumentNullException)
            { Game.SetError(new Error(212, "Invalid actor (null) -> Record not saved")); }
            catch (ArgumentException)
            { Game.SetError(new Error(212, "Invalid actor.ActID (duplicate key exists) -> Record not saved")); }
        }

        /// <summary>
        /// Returns a filtered set of Historical Records
        /// </summary>
        /// <param name="keyPress"></param>
        /// <returns></returns>
        internal List<Snippet> GetHistoricalRecordSet(RLKeyPress keyPress)
        {
            List<string> tempList = new List<string>();
            List<Snippet> snippetList = new List<Snippet>();
            IEnumerable<string> recordList;
            switch (keyPress.Key)
            {
                case RLKey.A:
                    //All records
                    recordList =
                        from record in dictHistoricalRecords
                        orderby record.Value.Year, record.Value.trackerID
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.C:
                    //CUSTOM (debugging purposes)
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfHistoricalActorIncidents
                        where eventType == HistActorIncident.Lordship
                        //where record.Value.Actual == false
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.D:
                    //deaths
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfHistoricalActorIncidents
                        where eventType == HistActorIncident.Died
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.G:
                    //Marriages
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfHistoricalActorIncidents
                        where eventType == HistActorIncident.Married
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
                case RLKey.K:
                    //Kingdom events
                    recordList =
                        from record in dictHistoricalRecords
                        from eventType in record.Value.listOfKingdomIncidents
                        where eventType == HistKingdomIncident.Battle || eventType == HistKingdomIncident.Siege
                        orderby record.Value.Year
                        select Convert.ToString(record.Value.Year + " " + record.Value.Text);
                    tempList = recordList.ToList();
                    break;
            }
            foreach (string text in tempList)
            { snippetList.Add(new Snippet(text)); }
            return snippetList;
        }

        /// <summary>
        /// Returns a filtered set of Lore records
        /// </summary>
        /// <param name="keyPress"></param>
        /// <returns></returns>
        internal List<Snippet> GetLoreSet(RLKeyPress keyPress)
        {
            List<string> tempList = new List<string>();
            List<Snippet> snippetList = new List<Snippet>();
            switch (keyPress.Key)
            {
                case RLKey.U:
                    tempList.AddRange(Game.lore.GetUprising());
                    break;
                case RLKey.F:
                    tempList.AddRange(Game.lore.GetRoyalFamilyFate());
                    break;
            }
            foreach (string text in tempList)
            { snippetList.Add(new Snippet(text)); }
            return snippetList;
        }

        /*
        /// <summary>
        /// Generate a list of All Secrets
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowSecretsRL()
        {
            List <string> tempList = GetPossessionsSummary(PossessionType.Secret);
            //snippet list
            List<Snippet> listData = new List<Snippet>();
            foreach(string data in tempList)
            { listData.Add(new Snippet(data)); }
            return listData;
        }*/

        /// <summary>
        /// Generate a list of a subtype of Possessions for display
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowPossessionsRL(PossessionType type)
        {
            //snippet list
            List<Snippet> listData = new List<Snippet>();
            List<string> tempList = GetPossessionsSummary(type);
            if (tempList.Count > 0)
            {
                foreach (string data in tempList)
                { listData.Add(new Snippet(data)); }
            }
            return listData;
        }

        /// <summary>
        /// Generate a list of all Bloodhound Actor info grouped by turns
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowSpyAllRL(bool showActive, bool showEnemy)
        {
            int turn;
            string description;
            List<Snippet> listData = new List<Snippet>();
            if (showActive == true)
            {
                if (showEnemy == true)
                { listData.Add(new Snippet("--- Spy ALL", RLColor.Yellow, RLColor.Black)); }
                else { listData.Add(new Snippet("--- Spy ACTIVE Actors", RLColor.Yellow, RLColor.Black)); }
            }
            else { listData.Add(new Snippet("--- Spy ENEMY Actors", RLColor.Yellow, RLColor.Black)); }
            List<ActorSpy> listTempActive = new List<ActorSpy>();
            List<ActorSpy> listTempEnemy = new List<ActorSpy>();
            foreach (var bloodhound in dictBloodHound)
            {
                turn = bloodhound.Key;
                //clear lists
                listTempActive.Clear();
                listTempEnemy.Clear();
                //get a new turn's worth of data
                listTempActive.AddRange(bloodhound.Value.GetActiveActors());
                listTempEnemy.AddRange(bloodhound.Value.GetEnemyActors());
                //snippets -> active actors
                listData.Add(new Snippet(string.Format("Day {0}", turn), RLColor.LightRed, RLColor.Black));
                if (showActive == true)
                {
                    foreach (ActorSpy spy in listTempActive)
                    {
                        description = string.Format("ID {0,-5} {1,-26} Pos {2,2}:{3,-5} Status -> {4,-12} Known -> {5,-8} Goal -> {6, -8} Mode -> {7}", spy.ActID, GetActorDetails(spy.ActID),
                            spy.Pos.PosX, spy.Pos.PosY, spy.Status, spy.Known, "n.a", "n.a");
                        listData.Add(new Snippet(description));
                    }
                }
                //snippets -> enemy actors
                if (showEnemy == true)
                {
                    foreach (ActorSpy spy in listTempEnemy)
                    {
                        description = string.Format("ID {0,-5} {1,-26} Pos {2,2}:{3,-5} Status -> {4,-12} Known -> {5,-8} Goal -> {6, -8} Mode -> {7}", spy.ActID, GetActorDetails(spy.ActID), spy.Pos.PosX,
                            spy.Pos.PosY, spy.Status, spy.Known, spy.Goal, spy.HuntMode == true ? "Hunt" : "normal");
                        listData.Add(new Snippet(description));
                    }
                }
            }
            return listData;
        }

        /// <summary>
        /// Show bloodhound data, turn by turn, for a specific active, or enemy, actor (input ActID)
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowSpyRL(int actID)
        {
            string description;
            List<Snippet> listData = new List<Snippet>();
            List<ActorSpy> tempList = new List<ActorSpy>();
            if (actID > 0)
            {
                if (actID < 10)
                {
                    //Active
                    IEnumerable<ActorSpy> actorData =
                        from bloodhound in dictBloodHound
                        from spy in bloodhound.Value.GetActiveActors()
                        where spy.ActID == actID
                        select spy;
                    tempList = actorData.ToList();
                }
                else
                {
                    //Enemy
                    IEnumerable<ActorSpy> actorData =
                        from bloodhound in dictBloodHound
                        from spy in bloodhound.Value.GetEnemyActors()
                        where spy.ActID == actID
                        select spy;
                    tempList = actorData.ToList();
                }
                //any records found?
                if (tempList.Count > 0)
                {
                    RLColor foreColor;
                    listData.Add(new Snippet(string.Format("--- Spy ACTOR ID {0}", actID), RLColor.Yellow, RLColor.Black));
                    //set up formatted Snippet list
                    foreach (ActorSpy spy in tempList)
                    {
                        if (spy.Known == true) { foreColor = Color._badTrait; }
                        else { foreColor = RLColor.White; }
                        description = string.Format("Day {0,-5} {1,-26} Pos {2,2}:{3,-5} Status -> {4,-12} Known -> {5,-8} Goal -> {6, -8} Mode -> {7}", spy.Turn, GetActorDetails(spy.ActID),
                            spy.Pos.PosX, spy.Pos.PosY, spy.Status, spy.Known, spy.Goal, spy.HuntMode == true ? "Hunt" : "normal");
                        listData.Add(new Snippet(description, foreColor, RLColor.Black));
                    }
                }
                else
                { listData.Add(new Snippet(string.Format("No records found for ActID {0}", actID))); }
            }
            else { listData.Add(new Snippet("Warning! Invalid ActorID Input", RLColor.LightRed, RLColor.Black)); }
            return listData;
        }

        /// <summary>
        /// Generate a list of All Messages
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowMessagesRL()
        {
            List<Snippet> tempList = new List<Snippet>();
            RLColor color = RLColor.White;
            foreach (var message in dictMessages)
            {
                if (message.Value.Type == MessageType.Activation) { color = Color._active; }
                else { color = RLColor.White; }
                tempList.Add(new Snippet(string.Format("Day {0}, {1}, {2}", message.Value.Day, message.Value.Year, message.Value.Text), color, RLColor.Black));
            }
            return tempList;
        }

        /// <summary>
        /// return 8 most recent messages to display at bottom right console window
        /// </summary>
        /// <returns></returns>
        public List<Snippet> ShowRecentMessagesRL()
        {
            List<Snippet> tempList = new List<Snippet>();
            tempList.Add(new Snippet("--- Message Log Recent", RLColor.Yellow, RLColor.Black));
            tempList.AddRange(messageQueue.ToList());
            return tempList;
        }


        /// <summary>
        /// gets the correct advisor type and returns as a string for display purposes
        /// </summary>
        /// <param name="advisor"></param>
        /// <returns></returns>
        private string GetAdvisorType(Advisor advisor)
        {
            string type = "unknown";
            if (advisor.advisorRoyal > 0)
            { type = Convert.ToString(advisor.advisorRoyal); }
            else if (advisor.advisorNoble > 0)
            { type = Convert.ToString(advisor.advisorNoble); }
            return type;
        }


        /// <summary>
        /// debug: highlights duplicate names in imported files
        /// </summary>
        /// <returns></returns>
        internal List<Snippet> ShowDuplicatesRL()
        {
            //get duplicates
            List<string> listOfStrings = new List<string>(Game.history.GetDuplicatesNames());
            List<Snippet> listOfDuplicates = new List<Snippet>();
            //convert to snippets
            foreach (string name in listOfStrings)
            { listOfDuplicates.Add(new Snippet(name)); }
            return listOfDuplicates;
        }

        /// <summary>
        /// if specified actor present at location then True
        /// </summary>
        /// <param name="actorID"></param>
        /// <param name="locID"></param>
        /// <returns></returns>
        public bool CheckActorPresent(int actorID, int locID)
        {
            Location loc = Game.network.GetLocation(locID);
            if (loc != null) { return loc.CheckActorStatus(actorID); }
            else { Game.SetError(new Error(189, "Invalid Loc (null)")); }
            return false;
        }

        /// <summary>
        /// permanently remove an actor from relevant dictionaries
        /// </summary>
        /// <param name="actorID"></param>
        public void RemovePassiveActor(int actorID)
        {
            if (!dictAllActors.Remove(actorID))
            { Game.SetError(new Error(37, "ActorID not found")); }
            if (!dictPassiveActors.Remove(actorID))
            { Game.SetError(new Error(37, "ActorID not found")); }
        }

        /// <summary>
        /// add a new actor to relevant dictionaries
        /// </summary>
        /// <param name="actor"></param>
        public void AddPassiveActor(Passive actor)
        {
            if (actor != null)
            {
                try
                {
                    dictAllActors.Add(actor.ActID, actor);
                    dictPassiveActors.Add(actor.ActID, actor);
                }
                catch (ArgumentException)
                { Game.SetError(new Error(60, string.Format("Invalid Passive ActorID (duplicate ID) for \"{0}\"", actor.Name))); }
            }
            else { Game.SetError(new Error(38, "null Actor input")); }
        }


        public void AddEnemyActor(Enemy actor)
        {
            if (actor != null)
            {
                try
                {
                    dictAllActors.Add(actor.ActID, actor);
                    dictEnemyActors.Add(actor.ActID, actor);
                }
                catch (ArgumentException)
                { Game.SetError(new Error(151, string.Format("Invalid Enemy ActorID (duplicate ID) for \"{0}\"", actor.Name))); }
            }
            else { Game.SetError(new Error(151, "Invalid Enemy Actor input (null)")); }
        }

        /// <summary>
        /// returns all availabe living Knights
        /// </summary>
        /// <returns></returns>
        public List<int> GetKnights()
        {
            List<int> listOfKnights = new List<int>();
            IEnumerable<int> knights =
                from person in dictPassiveActors
                where person.Value.Type == ActorType.Knight && person.Value.Status != ActorStatus.Gone
                orderby person.Value.ActID
                select person.Value.ActID;
            listOfKnights = knights.ToList();
            return listOfKnights;
        }

        /// <summary>
        /// handles all start (day 0) Game stuff
        /// </summary>
        public void ProcessStartGame()
        {
            Game.logTurn?.Write("--- ProcessStartGame (World.cs)");
            Game.history.AgePassiveCharacters(dictPassiveActors);
            CalculateCrows();

        }

        /// <summary>
        /// handles all pre-turn stuff, part 1 (Notification messages)
        /// </summary>
        public bool ProcessStartTurnEarly()
        {
            bool notificationStatus = false; //is a notification msg needed?
            Game.infoChannel.ClearConsole(ConsoleDisplay.Event);
            Game.logTurn?.Write("--- ProcessStartTurn (World.cs)");
            Game.logTurn?.Write($"Day {Game.gameTurn + 1}, Turn {Game.gameTurn}");
            UpdateActorMoveStatus(MoveActors());
            if (UpdatePlayerStatus() == true) { notificationStatus = true; }
            if (UpdateWorldStatus() == true) { notificationStatus = true; }
            CheckStationaryActiveActors();
            CalculateCrows();
            //Enemies
            UpdateAIController();
            SetEnemyActivity();
            return notificationStatus;
        }

        /// <summary>
        /// handles pre-turn stuff, part 2 (events)
        /// </summary>
        public void ProcessStartTurnLate()
        {
            //Game.infoChannel.ClearConsole(ConsoleDisplay.Event);
            //Create events
            Game.director.CheckPlayerEvents();
            Game.director.CheckFollowerEvents(dictActiveActors);
            //Player events first
            if (Game.director.ResolvePlayerEvents())
            { Game._specialMode = SpecialMode.PlayerEvent; }
            else
            {
                //Follwer events last
                if (Game.director.ResolveFollowerEvents())
                { Game._specialMode = SpecialMode.FollowerEvent; }
            }
            //update position of all key characters on map layers
            UpdateFollowerPositions();
            UpdateEnemiesPositions();
            UpdateActiveActors();
            UpdateBloodHound(); //needs to be right at the end of ProcessStartTurn
        }

        /// <summary>
        /// handles all end of turn stuff
        /// </summary>
        public void ProcessEndTurn()
        {
            Game.logTurn?.Write("--- ProcessEndTurn (World.cs)");
            Game.logTurn?.Write($"Day {Game.gameTurn + 1}, Turn {Game.gameTurn}");
            Game.map.UpdateMap();
            Game.director.HousekeepEvents();
            Game.director.CheckEventTimers();
            HousekeepActors();
            Game.gameTurn++;
        }

        /// <summary>
        /// handles all relevant status changes for the Player
        /// </summary>
        private bool UpdatePlayerStatus()
        {
            bool updateStatus = false; //does a message need to be shown?
            Game.logTurn?.Write("--- UpdatePlayerStatus (World.cs)");
            Active player = GetActiveActor(1);
            if (player != null)
            {
                //Sea Voyage Status
                if (player.Status == ActorStatus.AtSea)
                {
                    string description;
                    player.VoyageTimer--;
                    if (player.VoyageTimer == 0)
                    {
                        //arrived at Location
                        string locName = GetLocationName(player.LocID);
                        description = string.Format("{0} {1} has arrived at {2} onboard the S.S \"{3}\"", player.Title, player.Name, locName, player.ShipName);
                        SetPlayerRecord(new Record(description, 1, player.LocID, GetRefID(player.LocID), CurrentActorIncident.Travel));
                        SetMessage(new Message(description, MessageType.Move));
                        //notification message
                        RLColor foreColor = RLColor.Black;
                        RLColor backColor = Color._background1;
                        List<Snippet> msgList = new List<Snippet>();
                        msgList.Add(new Snippet($"The S.S \"{player.ShipName}\" has docked today with {player.Title} {player.Name} onboard", Color._goodTrait, backColor));
                        msgList.Add(new Snippet(""));
                        msgList.Add(new Snippet("- o -", RLColor.Gray, backColor));
                        msgList.Add(new Snippet(""));
                        SetNotification(msgList);
                        updateStatus = true;
                        //reset actor instances
                        player.Status = ActorStatus.AtLocation;
                        player.ShipName = "Unknown";
                        player.SeaName = "Unknown";
                        player.VoyageSafe = true;
                        
                    }
                    else
                    {
                        description = string.Format("{0} {1} is at Sea onboard the S.S \"{2}\", bound for {3}, arriving in {4} days", player.Title, player.Name, player.ShipName,
                            GetLocationName(player.LocID), player.VoyageTimer);
                        SetMessage(new Message(description, MessageType.Move));
                    }
                    Game.logTurn?.Write(description);
                }
                //Death Timer active
                if (player.DeathTimer < 999)
                {
                    player.DeathTimer--;
                    Game.logTurn?.Write($"{player.Title} {player.Name} Death Timer reduced by 1 to {player.DeathTimer}");
                    if (player.DeathTimer <= 0)
                    {
                        //end of game
                        Game.SetEndGame("Death Timer expired");
                    }
                }
            }
            else { Game.SetError(new Error(219, "Invalid Player (null)")); }
            return updateStatus;
        }


        /// <summary>
        /// updates Movement map layer for the different actors (key is mapMarker which is also the ActID of the character moving) Enemies are only shown if known.
        /// </summary>
        private void UpdateActorMoveStatus(Dictionary<int, Position> dictMoveActors)
        {
            int marker;
            //clear out the Movement layer of the grid first
            Game.map.ClearMapLayer(MapLayer.Movement);
            //loop dictionary of move actors
            foreach (var pos in dictMoveActors)
            {
                marker = -1;
                //get actor
                Actor person = GetAnyActor(pos.Key);
                if (person != null)
                {
                    marker = pos.Key;
                    if (person is Enemy)
                    {
                        //enemies are shown as '999' indicating Known status (converted to '0' by map.DrawMapRL)
                        Enemy enemy = person as Enemy;
                        if (enemy.Known == true)
                        { marker = 999; }
                        else { marker = -1; }
                    }
                    //show on map only if known
                    if (marker > 0)
                    { Game.map.SetMapInfo(MapLayer.Movement, pos.Value.PosX, pos.Value.PosY, marker); }
                }
                else { Game.SetError(new Error(157, "Invalid key (ActID) in dictMoveActors (not found in dict)")); }
            }
        }

        /// <summary>
        /// Calculates crow %'s at start of trun
        /// </summary>
        private void CalculateCrows()
        {
            int distance, chance;
            //Player is assumed to be the first record in dictActiveActors
            Player player = (Player)GetActiveActor(1);
            Position posPlayer = player.GetActorPosition();
            //Top up Player Crows to the maximum allowed
            player.CrowsNumber = Game.constant.GetValue(Global.CROW_NUMBER);
            //loop through active players
            foreach (var actor in dictActiveActors)
            {
                if (actor.Value is Follower)
                {
                    actor.Value.ClearCrowTooltips();
                    actor.Value.Activated = false;
                    Position pos = actor.Value.GetActorPosition();
                    distance = Game.utility.GetDistance(posPlayer.PosX, posPlayer.PosY, pos.PosX, pos.PosY);
                    chance = 100 - (distance * 2) + actor.Value.CrowBonus;
                    chance = Math.Min(100, chance);

                    if (player.Status != ActorStatus.AtLocation)
                    {
                        //no crows can be sent if Player isn't at a Location
                        actor.Value.CrowChance = 0;
                        actor.Value.CrowBonus = 0;
                        actor.Value.CrowDistance = distance;
                        //actor.Value.CrowBonus = 0;
                        actor.Value.AddCrowTooltip("No crows can be sent, or received, if the Player is travelling, or is being held");
                    }
                    else
                    {
                        if (actor.Value.Status == ActorStatus.AtLocation)
                        {
                            if (actor.Value.LocID != player.LocID)
                            {
                                //Normal operations -> Player and Follower both at a Location
                                actor.Value.CrowChance = chance;
                                actor.Value.CrowDistance = distance;
                                //actor.Value.CrowBonus = 0;
                                actor.Value.AddCrowTooltip(string.Format("Chance is {0}%  (One hundred less distance doubled plus any bonus)", chance));
                                if (actor.Value.CrowBonus > 0)
                                {
                                    actor.Value.AddCrowTooltip(string.Format("Includes a cumulative bonus of +{0}% from previous failed crows that might be delayed",
                                      Game.constant.GetValue(Global.CROW_BONUS)));
                                }
                            }
                            else
                            {
                                //both at the same location -> no crow required and automatic activation
                                actor.Value.Activated = true;
                                actor.Value.CrowChance = 100;
                                actor.Value.AddCrowTooltip("Automatic activation as at the same location as the Player");
                            }
                        }
                        else
                        {
                            //no crows can be sent if Follower isn't at a Location
                            actor.Value.CrowChance = 0;
                            actor.Value.CrowDistance = distance;
                            actor.Value.CrowBonus = 0;
                            actor.Value.AddCrowTooltip("No crows can be sent to the Follower if they are travelling");
                        }
                    }
                    if (distance > 0)
                    { actor.Value.AddCrowTooltip(string.Format("Distance from Player is {0} leagues, as the crow flies", distance)); }
                }
            }
        }

        /// <summary>
        /// Send a crow to a loyal follower
        /// </summary>
        public List<Snippet> SendCrow(int actorID)
        {
            List<Snippet> listSnippet = new List<Snippet>();
            string description, messageText, locName;
            int chance, num;
            Active actor = GetActiveActor(actorID);
            Player player = (Player)GetActiveActor(1);
            int bonus = Game.constant.GetValue(Global.CROW_BONUS);
            if (player.Status == ActorStatus.AtLocation)
            {
                if (player.CrowsNumber > 0)
                {
                    if (actor != null)
                    {
                        if (actorID != 1)
                        {
                            if (actor.Status == ActorStatus.AtLocation)
                            {
                                if (actor.LocID != player.LocID)
                                {
                                    if (actor.Delay == 0)
                                    {
                                        if (actor.Activated == false)
                                        {
                                            locName = GetLocationName(actor.LocID);
                                            num = rnd.Next(100);
                                            chance = actor.CrowChance + actor.CrowBonus;
                                            description = string.Format("chance of Crow arriving {0}%, or less. Roll {1}", chance, num);
                                            listSnippet.Add(new Snippet(string.Format("Crow dispatched to {0}, Aid {1}, at {2} (distance {3} leagues)", actor.Name, actor.ActID, locName, actor.CrowDistance)));
                                            player.CrowsNumber--;
                                            messageText = string.Format("Crow sent to {0}, Aid {1}, at {2} ({3}% chance of arriving, roll {4}, {5})", actor.Name, actor.ActID, locName, chance,
                                                num, num < chance ? "Arrived" : "Failed");
                                            Message message = new Message(messageText, actor.ActID, actor.LocID, MessageType.Crow);
                                            SetMessage(message);
                                            if (num < chance)
                                            {
                                                //success!
                                                actor.Activated = true;
                                                actor.CrowBonus = 0;
                                                listSnippet.Add(new Snippet(string.Format("Crow success! {0} activated ({1})", actor.Name, description), RLColor.Yellow, RLColor.Black));
                                                //Game.messageLog.Add(new Snippet(string.Format("Crow arrived, {0} activated", actor.Name)));
                                                Message message_1 = new Message(string.Format("{0}, Aid {1}, has been Activated", actor.Name, actor.ActID), MessageType.Activation);
                                                SetMessage(message_1);
                                            }
                                            else
                                            //failed the roll, apply bonus
                                            {
                                                actor.Activated = false;
                                                listSnippet.Add(new Snippet(string.Format("The Crow failed to arrive ({0})", description)));
                                                actor.CrowBonus += bonus;
                                                actor.AddCrowTooltip(string.Format("An additional bonus of +{0}% applies from a previous failed crow that might have been delayed", bonus));
                                            }
                                            listSnippet.Add(new Snippet(string.Format("You have {0} {1} remaining", player.CrowsNumber, player.CrowsNumber == 1 ? "Crow" : "Crows")));
                                        }
                                        else
                                        //already activated
                                        { listSnippet.Add(new Snippet(string.Format("{0} is already activated and awaiting your orders!", actor.Name))); }
                                    }
                                    else
                                    {
                                        //actor delayed
                                        { listSnippet.Add(new Snippet(string.Format("Crow can NOT be dispatched to {0} as they are delayed (\"{1}\"", actor.Name, actor.DelayReason))); }
                                    }
                                }
                                else
                                {
                                    //at same location as player
                                    listSnippet.Add(new Snippet(string.Format("No crow required as {0} is present at the same location as yourself", actor.Name)));
                                    actor.Activated = true;
                                }
                            }
                            else
                            //actor not at a location
                            { listSnippet.Add(new Snippet(string.Format("Crow can NOT be dispatched to {0} as they aren't at a location", actor.Name))); }
                        }
                        else
                        //sending a crow to yourself
                        { listSnippet.Add(new Snippet("There is no need to send a crow to yourself!")); }
                    }
                    else
                    //invalid actor
                    { listSnippet.Add(new Snippet("Unknown Actor. No crow sent.")); }
                }
                else
                //run out of crows
                { listSnippet.Add(new Snippet("You have run out of crows. More will be available next turn")); }
            }
            else
            {
                //Main error states
                if (player.Status == ActorStatus.Travelling) { listSnippet.Add(new Snippet("You are unable to dispatch crows while you are Travelling", RLColor.LightRed, RLColor.Black)); }
                else if (player.Status == ActorStatus.AtSea) { listSnippet.Add(new Snippet("You are unable to dispatch crows while at Sea", RLColor.LightRed, RLColor.Black)); }
                else if (player.Status == ActorStatus.Captured) { listSnippet.Add(new Snippet("You are unable to dispatch crows while you are Incarcerated", RLColor.LightRed, RLColor.Black)); }
                else if (player.Status == ActorStatus.Gone) { listSnippet.Add(new Snippet("You are unable to dispatch crows from the AfterLife", RLColor.LightRed, RLColor.Black)); }
                else { listSnippet.Add(new Snippet(string.Format("Your Status isn't recognised (\"{0}\") and crows are consequently unavailable", player.Status), RLColor.LightRed, RLColor.Black)); }
            }
            return listSnippet;
        }

        /// <summary>
        /// provides # of crows remaining
        /// </summary>
        /// <returns></returns>
        public int GetCrowsAvailable()
        {
            Player player = (Player)GetActiveActor(1);
            //snippet = new Snippet(string.Format("You have {0} {1} remaining", numCrows, numCrows == 1 ? "Crow" : "Crows"));
            return player.CrowsNumber;
        }

        /// <summary>
        /// handles end of turn housekeeping for all actor types
        /// </summary>
        private void HousekeepActors()
        {
            //All actors -> decrement any Condition timers
            foreach (var actor in dictAllActors)
            {
                if (actor.Value.CheckConditions() == true)
                { actor.Value.UpdateConditionTimers(); }
            }
            //Active actors -> decrement any delays
            foreach (var actor in dictActiveActors)
            {
                if (actor.Value.Delay > 0)
                {
                    actor.Value.Delay--;
                    if (actor.Value.Delay == 0)
                    { actor.Value.DelayReason = null; }
                }
                //reset Found and listOfEnemies (search routines)
                actor.Value.Found = false;
                actor.Value.Capture = false;
                actor.Value.ResetEnemies();
                actor.Value.ResetSearched();
                //Player
                if (actor.Value.ActID == 1)
                {
                    //incarcerated?
                    if (actor.Value.Status == ActorStatus.Captured)
                    {
                        actor.Value.Known = true; actor.Value.Revert = 2;
                        //raise Legend_King each turn player is held in dungeon
                        int legendLoss = Game.constant.GetValue(Global.LOSS_OF_LEGEND);
                        int currentValue = Game.director.GetGameState(DataPoint.Legend_King, DataState.Good);
                        int newValue = Math.Abs(Game.director.ChangeData(currentValue, legendLoss, Event_System.EventCalc.Add));
                        Game.director.SetGameState(DataPoint.Legend_King, DataState.Good, newValue, true);
                        //message
                        string description = string.Format("The Legend of {0} {1} grows (+{2}) while the Usurper is incarcerated", Game.lore.NewKing.Title, Game.lore.NewKing.Name, legendLoss);
                        SetMessage(new Message(description, MessageType.Incarceration));
                    }
                }
            }
        }

        /// <summary>
        /// returns number of object types in dictionary
        /// </summary>
        /// <param name="possType"></param>
        /// <returns></returns>
        internal int GetPossessionsCount(PossessionType possType)
        {
            int num = 0;
            switch (possType)
            {
                case PossessionType.Item:
                    var itemResult = from possObject in dictPossessions
                                     where possObject.Value is Item
                                     select possObject;
                    num = itemResult.Count();
                    break;
                case PossessionType.Secret:
                    var secretResult = from possObject in dictPossessions
                                       where possObject.Value is Secret
                                       select possObject;
                    num = secretResult.Count();
                    break;
                case PossessionType.None:
                    Game.SetError(new Error(120, "Invalid possType Input (None)"));
                    break;
                default:
                    Game.SetError(new Error(120, string.Format("Invalid possType Input (\"{0}\")", possType)));
                    break;
            }
            return num;
        }

        /// <summary>
        /// returns a list of year + description of the specific object type in dictionary
        /// </summary>
        /// <param name="possType"></param>
        /// <returns></returns>
        internal List<string> GetPossessionsSummary(PossessionType possType)
        {
            List<string> tempList = new List<string>();
            switch (possType)
            {
                case PossessionType.Secret:
                    IEnumerable<string> secretList =
                    from secret in dictPossessions
                    where secret.Value is Secret
                    orderby secret.Value.Year
                    select Convert.ToString(secret.Value.Year + " " + secret.Value.Description);
                    tempList = secretList.ToList();
                    break;
                case PossessionType.Item:
                    IEnumerable<string> itemListActive =
                        from items in dictPossessions.Values.OfType<Item>()
                        where items.ItemType == PossItemType.Active && items.WhoHas > 0
                        select Convert.ToString("ItemID " + items.ItemID + ", \"" + items.Description + "\", Type: " + items.ItemType + ", " + GetActorDetails(items.WhoHas, false));
                    tempList = itemListActive.ToList();
                    IEnumerable<string> itemListPassive =
                        from items in dictPossessions.Values.OfType<Item>()
                        where items.ItemType == PossItemType.Passive && items.WhoHas > 0
                        select Convert.ToString("ItemID " + items.ItemID + ", \"" + items.Description + "\", Type: " + items.ItemType + ", " + GetActorDetails(items.WhoHas, false));
                    tempList.AddRange(itemListPassive.ToList());
                    break;
                case PossessionType.None:
                    Game.SetError(new Error(121, "Invalid possType Input (None)"));
                    break;
                default:
                    Game.SetError(new Error(121, string.Format("Invalid possType Input (\"{0}\")", possType)));
                    break;
            }

            return tempList;
        }

        /// <summary>
        /// checks all active followers and updates their position on the map 'Information' layer (used to show characters if the Information toggle is pressed ("I")
        /// </summary>
        private void UpdateFollowerPositions()
        {
            Game.map.ClearMapLayer(MapLayer.Followers);
            foreach (var follower in dictActiveActors)
            {
                if (follower.Key > 0 && follower.Value.Status != ActorStatus.Gone)
                {
                    Position pos = follower.Value.GetActorPosition();
                    if (pos != null)
                    { Game.map.SetMapInfo(MapLayer.Followers, pos.PosX, pos.PosY, follower.Key); }
                }
            }
        }

        /// <summary>
        /// shows all known enemies
        /// </summary>
        private void UpdateEnemiesPositions()
        {
            Game.map.ClearMapLayer(MapLayer.Enemies);
            Game.map.ClearMapLayer(MapLayer.EnemiesDebug);
            int expire = Game.constant.GetValue(Global.KNOWN_REVERT);
            //loop dictionary -> only place on map layer if known
            foreach (var enemy in dictEnemyActors)
            {
                if (enemy.Value.Status != ActorStatus.Gone)
                {
                    Position pos = enemy.Value.GetActorPosition();
                    //add to enemiesDebug layer regardless (shows all enemies at current positions)
                    Game.map.SetMapInfo(MapLayer.EnemiesDebug, pos.PosX, pos.PosY, 1);
                    //normal enemies Layer (only what is known by the player)
                    if (enemy.Value.Known == true)
                    {
                        //show enemy with a map marker indicating how many days old the information is -> 1 day old as Known
                        if (pos != null)
                        { Game.map.SetMapInfo(MapLayer.Enemies, pos.PosX, pos.PosY, 1); }
                    }
                    else if (enemy.Value.TurnsUnknown <= expire)
                    {
                        //show enemy with a map marker indicating how many days old the information is (show last known position, not current one).
                        Position pos_1 = enemy.Value.LastKnownPos;
                        if (pos_1 != null)
                        { Game.map.SetMapInfo(MapLayer.Enemies, pos_1.PosX, pos_1.PosY, enemy.Value.TurnsUnknown); }
                    }
                }
            }
        }

        /// <summary>
        /// start of turn Housekeeping for Active Actors
        /// </summary>
        private void UpdateActiveActors()
        {
            Game.logTurn?.Write("--- UpdateActiveActors (World.cs)");
            foreach (var actor in dictActiveActors)
            {
                //if Known, decrement their revert status
                if (actor.Value.Known == true)
                {
                    actor.Value.LastKnownLocID = actor.Value.LocID;
                    actor.Value.TurnsUnknown = 0;
                    actor.Value.Revert--;
                    Game.logTurn?.Write(string.Format(" {0} {1} has had their Revert Timer reduced from {2} to {3}", actor.Value.Title, actor.Value.Name, actor.Value.Revert + 1, actor.Value.Revert));
                    if (actor.Value.Revert <= 0)
                    {
                        //Reverts from Known to Unknown state
                        actor.Value.Known = false;
                        string eventText = string.Format("{0} {1} is no longer \"Known\" as sufficient time has passed", actor.Value.Title, actor.Value.Name);
                        Message message = new Message(eventText, MessageType.Known);
                        SetMessage(message);
                        int refID = GetRefID(actor.Value.LocID);
                        if (actor.Value.ActID == 1)
                        { SetPlayerRecord(new Record(eventText, actor.Value.ActID, actor.Value.LocID, refID, CurrentActorIncident.Known)); }
                        else if (actor.Value.ActID > 1)
                        { SetCurrentRecord(new Record(eventText, actor.Value.ActID, actor.Value.LocID, refID, CurrentActorIncident.Known)); }
                        Game.logTurn?.Write(eventText);
                    }
                }
                else if (actor.Value.Known == false)
                {
                    actor.Value.TurnsUnknown++;
                    Game.logTurn?.Write(string.Format(" {0} {1} has had their TurnsUnknown Timer increased from {2} to {3}",
                        actor.Value.Title, actor.Value.Name, actor.Value.TurnsUnknown - 1, actor.Value.TurnsUnknown));
                }
            }
        }

        /// <summary>
        /// set up the two refID -> LocID (& vice versa) dictionaries at start of game
        /// </summary>
        private void InitialiseConversionDicts()
        {
            List<Location> listOfLocations = Game.map.GetLocations();
            if (listOfLocations != null)
            {
                int refID, locID;
                //get all other Loc & Ref data directly from map
                foreach (Location loc in listOfLocations)
                {
                    locID = loc.LocationID;
                    //set up conversion dictionaries
                    refID = Game.map.GetMapInfo(MapLayer.RefID, loc.GetPosX(), loc.GetPosY());
                    if (refID > 0)
                    {
                        try
                        { dictConvertLocToRef.Add(locID, refID); }
                        catch (ArgumentException)
                        { Game.SetError(new Error(145, "Invalid LocID, Record already exists")); }
                        try
                        { dictConvertRefToLoc.Add(refID, locID); }
                        catch (ArgumentException)
                        { Game.SetError(new Error(145, "Invalid RefID, Record already exists")); }
                    }
                }
            }
            else { Game.SetError(new Error(145, "Invalid listOfLocations (null)")); }
        }

        /// <summary>
        /// get corresponding RefID from LocID. Returns 0 if not found.
        /// </summary>
        /// <param name="locID"></param>
        /// <returns></returns>
        internal int GetRefID(int locID)
        {
            if (locID > 0)
            {
                if (dictConvertLocToRef.ContainsKey(locID) == true)
                { return dictConvertLocToRef[locID]; }
                else { Game.SetError(new Error(146, "Invalid LocID (record not found")); }
            }
            return 0;
        }

        /// <summary>
        /// get corresponding LocID from RefID. Returns 0 if not found.
        /// </summary>
        /// <param name="refID"></param>
        /// <returns></returns>
        internal int GetLocID(int refID)
        {
            if (refID > 0)
            {
                if (dictConvertRefToLoc.ContainsKey(refID) == true)
                { return dictConvertRefToLoc[refID]; }
                else { Game.SetError(new Error(147, "Invalid refID (record not found")); }
            }
            return 0;
        }

        /// <summary>
        /// Master AI controller, checked each turn, determines HuntMode for each enemy based on big picture analysis
        /// </summary>
        private void UpdateAIController()
        {
            int threshold = Game.constant.GetValue(Global.AI_HUNT_THRESHOLD); //max # turns since Player last known that AI will continue to hunt
            int knownStatus = GetActiveActorTrackingStatus(1); //if '0' then Known, if > 0 then # of days since last known
            int playerLocID, distance, enemyDM;
            int turnsToDestination = 0; //# of turns for Player to reach their destination if travelling (used to adjust threshold)
            Game.logTurn?.Write("--- UpdateAIController (World.cs)");
            //get player
            Player player = (Player)GetActiveActor(1);
            if (player != null)
            {
                //Travelling? Allow for time taken to reach destination
                if (player.Status == ActorStatus.Travelling)
                {
                    //loop List of Move objects looking for Player's party
                    for (int i = 0; i < listMoveObjects.Count; i++)
                    {
                        Move moveObject = listMoveObjects[i];
                        if (moveObject.PlayerInParty == true)
                        {
                            //player found, determine how many route segments left
                            turnsToDestination = moveObject.CheckTurnsToDestination();
                            Game.logTurn?.Write(string.Format(" [AI -> Notification] Player is Travelling -> {0} turns from their destination", turnsToDestination));
                            break;
                        }
                    }
                }
                //ignore all this if player Incarcerated in a dungeon?
                if (player.Status == ActorStatus.AtLocation || player.Status == ActorStatus.Travelling)
                {
                    //threshold is adjusted upwards if Player enroute to a destination
                    threshold += turnsToDestination;
                    //Player location is current, if known, or last known if not. Will be destination if travelling.
                    if (knownStatus == 0) { playerLocID = GetActiveActorLocByID(1); }
                    else { playerLocID = GetActiveActorLastKnownLoc(1); }
                    if (playerLocID > 0)
                    {
                        //can only hunt a recently known player for so long before reverting back to normal behaviour (there is a time taken test below which tests threshold on a tighter basis)
                        if (knownStatus <= threshold)
                        {
                            //Known
                            Location loc = Game.network.GetLocation(playerLocID);
                            if (loc != null)
                            {
                                Position playerPos = loc.GetPosition();
                                //dictionary to handle sorted distance data
                                Dictionary<int, int> tempDict = new Dictionary<int, int>();
                                foreach (var enemy in dictEnemyActors)
                                {
                                    //store enemies in tempDict by dist to player (key is ActID, value distance)
                                    Position enemyPos = enemy.Value.GetActorPosition();
                                    if (playerPos != null && enemyPos != null)
                                    {
                                        //only check enemies at a location (those who are travelling will have to wait)
                                        if (enemy.Value.Status == ActorStatus.AtLocation)
                                        {
                                            List<Route> route = Game.network.GetRouteAnywhere(enemyPos, playerPos);
                                            distance = Game.network.GetDistance(route);
                                            try
                                            { tempDict.Add(enemy.Value.ActID, distance); }
                                            catch (ArgumentException)
                                            { Game.SetError(new Error(167, string.Format("Invalid enemy ID {0} (duplicate)", enemy.Value.ActID))); }
                                        }
                                        else {
                                            Game.logTurn?.Write(string.Format(" [AI -> Notification] {0} {1}, ActID {2} is Travelling to {3}", enemy.Value.Title, enemy.Value.Name,
                                            enemy.Value.ActID, GetLocationName(enemy.Value.LocID))); }
                                    }
                                    else
                                    {
                                        Game.SetError(new Error(167, string.Format("Invalid Player ({0}:{1}) or Enemy Position ({2}:{3})", playerPos.PosX, playerPos.PosY,
                                     enemyPos.PosX, enemyPos.PosY)));
                                    }
                                }
                                //sort dictionary by distance
                                if (tempDict.Count > 0)
                                {
                                    var sorted = from pair in tempDict orderby pair.Value ascending select pair;
                                    foreach (var pair in sorted)
                                    {
                                        Enemy enemy = (Enemy)GetAnyActor(pair.Key);
                                        if (enemy != null)
                                        {
                                            //set nemesis to have double the normal threshold (will hunt at twice the distance from the player than an inquisitor)
                                            enemyDM = 1;
                                            if (enemy is Nemesis) { enemyDM = 2; }
                                            //can enemy reach player loc within threshold time? (distance / speed = # of turns <= threshold # of turns allowed
                                            if ((pair.Value / enemy.Speed) <= (threshold * enemyDM))
                                            { enemy.HuntMode = true; }
                                            else { enemy.HuntMode = false; }
                                            Game.logTurn?.Write(string.Format(" [AI -> Mode] enemyID {0},  distance -> {1}  Threshold (turns) -> {2}  Mode -> {3}", pair.Key, pair.Value,
                                                threshold * enemyDM, enemy.HuntMode == true ? "Hunt" : "Normal"));
                                        }
                                        else { Game.SetError(new Error(167, string.Format("Invalid enemy, ID {0} (null)", pair.Key))); }
                                    }
                                }
                                else { Game.logTurn?.Write(" [AI -> Notification] tempDictionary has too few records to sort (zero)"); }
                            }
                            else { Game.SetError(new Error(167, "Invalid Loc (null) Dictionary not updated")); }
                        }
                        else
                        {
                            //Unknown -> all enemies at a location are set to normal mode (huntmode 'false')
                            foreach (var enemy in dictEnemyActors)
                            {
                                if (enemy.Value.Status == ActorStatus.AtLocation)
                                {
                                    enemy.Value.HuntMode = false;
                                    Game.logTurn?.Write(string.Format(" [AI -> Player Unknown] {0} {1}, Act ID {2} Mode -> Normal", enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID));
                                }
                            }
                        }
                    }
                    else { Game.SetError(new Error(167, "Warning -> LocID of Player has returned Zero")); }
                }
                else if (player.Status == ActorStatus.Captured)
                {
                    //Incarcerated in a dungeon -> all enemies at a location are set to normal mode (huntmode 'false')
                    foreach (var enemy in dictEnemyActors)
                    {
                        if (enemy.Value.Status == ActorStatus.AtLocation)
                        {
                            enemy.Value.HuntMode = false;
                            Game.logTurn?.Write(string.Format(" [AI -> Player Captured] {0} {1}, Act ID {2} Mode -> Normal", enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID));
                        }
                    }
                }
            }
            else { Game.SetError(new Error(167, "Invalid player (Null), set Enemy AI bypassed")); }
        }

        /// <summary>
        /// handles AI for all enemies, also updates status (known, etc.)
        /// </summary>
        private void SetEnemyActivity()
        {
            Player player = (Player)GetActiveActor(1);
            if (player != null)
            {
                int turnsDM; //DM for the # of turns spent on the same goal (prevents enemy being locked into a set goal due to bad rolls)
                int playerLocID = player.LocID;
                int turnsUnknown = player.TurnsUnknown;
                bool huntStatus;
                int ai_search = Game.constant.GetValue(Global.AI_CONTINUE_SEARCH);
                int ai_hide = Game.constant.GetValue(Global.AI_CONTINUE_HIDE);
                int ai_wait = Game.constant.GetValue(Global.AI_CONTINUE_WAIT);
                int revert = Game.constant.GetValue(Global.KNOWN_REVERT);
                Game.logTurn?.Write("--- SetEnemyActivity (World.cs)");
                //loop enemy dictionary
                foreach (var enemy in dictEnemyActors)
                {
                    //debug -> random chance of enemy being known
                    if (enemy.Value.Known == false && rnd.Next(100) < 20)
                    {
                        enemy.Value.Known = true; enemy.Value.Revert = revert;
                        Game.logTurn?.Write(string.Format(" [Enemy -> Known] {0} ActID {1} has become KNOWN", enemy.Value.Name, enemy.Value.ActID));
                    }

                    //update status -> unknown
                    if (enemy.Value.Known == false) { enemy.Value.TurnsUnknown++; enemy.Value.Revert = 0; }
                    else
                    {
                        //known
                        enemy.Value.TurnsUnknown = 0;
                        enemy.Value.LastKnownLocID = enemy.Value.LocID;
                        enemy.Value.LastKnownPos = enemy.Value.GetActorPosition();
                        enemy.Value.LastKnownGoal = enemy.Value.Goal;
                        enemy.Value.Revert--;
                        if (enemy.Value.Revert <= 0)
                        {
                            enemy.Value.Revert = 0; enemy.Value.Known = false; enemy.Value.TurnsUnknown++;
                            Game.logTurn?.Write(string.Format(" [Enemy -> Unknown] {0} ActID {1} has reverted to Unknown status (timer elapsed)", enemy.Value.Name, enemy.Value.ActID));
                        }
                    }
                    //continue on with existing goal or get a new one?
                    if (enemy.Value is Inquisitor || enemy.Value is Nemesis)
                    {
                        //inquisitors -> if Move then automatic (continues on with Move)
                        if (enemy.Value.Goal != ActorGoal.Move)
                        {
                            huntStatus = enemy.Value.HuntMode;
                            turnsDM = enemy.Value.GoalTurns; //+1 % chance of changing goal per turn spent on existing goal
                            enemy.Value.GoalTurns++;
                            switch (enemy.Value.Goal)
                            {
                                case ActorGoal.None:
                                    //auto assign new goal
                                    SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown);
                                    break;
                                case ActorGoal.Wait:
                                    if (huntStatus == true)
                                    {
                                        //Player Known -> Will Search if same Loc
                                        SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown);
                                    }
                                    else
                                    {
                                        //Player Unknown
                                        if (rnd.Next(100) > (ai_wait + turnsDM))
                                        { SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown); }
                                        else { Game.logTurn?.Write(string.Format(" [Enemy -> Goal] {0}, ActID {1} retains Goal -> {2}", enemy.Value.Name, enemy.Value.ActID, enemy.Value.Goal)); }
                                    }
                                    break;
                                case ActorGoal.Search:
                                    if (huntStatus == true)
                                    {
                                        //Player Known -> if actor at different location then new goal
                                        if (enemy.Value.LocID != playerLocID)
                                        { SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown); }
                                    }
                                    else
                                    {
                                        //Player Unknown
                                        if (rnd.Next(100) > (ai_search + turnsDM))
                                        { SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown); }
                                        else { Game.logTurn?.Write(string.Format(" [Enemy -> Goal] {0}, ActID {1} retains Goal -> {2}", enemy.Value.Name, enemy.Value.ActID, enemy.Value.Goal)); }
                                    }
                                    break;
                                case ActorGoal.Hide:
                                    if (huntStatus == true)
                                    {
                                        //Player Known -> if actor at different location then new goal
                                        if (enemy.Value.LocID != playerLocID)
                                        { SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown); }
                                    }
                                    else
                                    {
                                        //Player Unknown
                                        if (rnd.Next(100) > (ai_hide + turnsDM))
                                        { SetEnemyGoal(enemy.Value, huntStatus, playerLocID, turnsUnknown); }
                                        else { Game.logTurn?.Write(string.Format(" [Enemy -> Goal] {0}, ActID {1} retains Goal -> {2}", enemy.Value.Name, enemy.Value.ActID, enemy.Value.Goal)); }
                                    }
                                    break;
                                default:
                                    Game.SetError(new Error(155, string.Format("Invalid Enemy Goal (\"{0}\")", enemy.Value.Goal)));
                                    break;
                            }
                        }
                    }
                    else
                    {
                        //all other enemies
                    }
                }
            }
            else { Game.SetError(new Error(155, "Invalid Player (null)")); }
        }

        /// <summary>
        /// sub method to provide a new goal when required -> Incorporates all necessary AI logic
        /// <param name="knowStatus">if '0' then player status is Unknown</param>
        /// <param name="playerLocID">current locID or Player's destination locId if travelling</param>
        /// <param name="turnsUnknown">Number of Turns player has been unknown for ('0' -> known)</param>
        /// </summary>
        /// <param name="enemy"></param>
        private void SetEnemyGoal(Enemy enemy, bool huntStatus, int playerLocID, int turnsUnknown)
        {
            Game.logTurn?.Write("--- SetEnemyGoal (World.cs)");
            bool huntMoveFlag = false;
            int rndNum, refID, tempDistance, enemyDistance, tempLocID;
            int currentBranch = -1;
            ActorGoal newGoal = ActorGoal.None;
            if (enemy != null)
            {
                if (playerLocID > 0)
                {
                    //get location of enemy
                    Location loc = Game.network.GetLocation(enemy.LocID);
                    if (loc != null)
                    {
                        //get branch info
                        refID = GetRefID(enemy.LocID);
                        if (refID > 0)
                        {
                            House house = null;
                            if (refID == 9999) //capital
                            { currentBranch = 0; }
                            else
                            {
                                house = GetHouse(refID);
                                currentBranch = house.Branch;
                            }
                            //debug
                            Game.logTurn?.Write(string.Format(" [Goal -> Branch] {0}, ActID {1} Assigned Branch -> {2} Current Branch -> {3}", enemy.Name, enemy.ActID, enemy.AssignedBranch, currentBranch));
                            //Mode -> Hunt or Normal (set by UpdateAIController)
                            if (huntStatus == true)
                            {
                                //Player Known, Hunt Mode -> not at same location
                                if (enemy.LocID != playerLocID)
                                {
                                    newGoal = ActorGoal.Move;
                                    huntMoveFlag = true;
                                }
                                //Player Known, Hunt Mode -> Same location -> Search
                                else { newGoal = ActorGoal.Search; }
                            }
                            else
                            {
                                //Normal Mode -> Player Unknown
                                rndNum = rnd.Next(100);
                                //Possible goals depend on location type
                                if (house != null)
                                {
                                    if (house is MajorHouse)
                                    {
                                        //Major House -> Wait 30, Hide 20, Move 50
                                        if (rndNum <= 30) { newGoal = ActorGoal.Wait; }
                                        else if (rndNum >= 50) { newGoal = ActorGoal.Move; }
                                        else { newGoal = ActorGoal.Hide; }
                                    }
                                    else if (house is MinorHouse)
                                    {
                                        //Minor House -> Wait 30, Move 70
                                        if (rndNum <= 30) { newGoal = ActorGoal.Wait; }
                                        else { newGoal = ActorGoal.Move; }
                                    }
                                    else if (house is InnHouse)
                                    {
                                        //Inn -> Wait 20, Hide 30, Move 50
                                        if (rndNum <= 20) { newGoal = ActorGoal.Wait; }
                                        else if (rndNum >= 50) { newGoal = ActorGoal.Move; }
                                        else { newGoal = ActorGoal.Hide; }
                                    }
                                    else { Game.SetError(new Error(156, "Invalid House type (not in list)")); }
                                }
                                else if (refID == 9999)
                                {
                                    //Capital
                                    if (enemy.AssignedBranch == 0)
                                    {
                                        //Capital (where enemy should be) -> Wait 70, Hide 30
                                        if (rndNum <= 70) { newGoal = ActorGoal.Wait; }
                                        else { newGoal = ActorGoal.Hide; }
                                    }
                                    else
                                    {
                                        //Capital -> Wait 30, Hide 20, Move 50
                                        if (rndNum <= 30) { newGoal = ActorGoal.Wait; }
                                        else if (rndNum >= 50) { newGoal = ActorGoal.Move; }
                                        else { newGoal = ActorGoal.Hide; }
                                    }
                                }
                            }
                        }
                        else
                        {
                            Game.SetError(new Error(156, string.Format("Enemy {0}, ID {1}, LocID {2} has an Invalid RefID (zero or less)", enemy.Name, enemy.ActID, enemy.LocID)));
                            //give default goal of Move
                            newGoal = ActorGoal.Move;
                        }

                        //reset Goal turns if new goal different to old goal
                        if (newGoal != enemy.Goal)
                        {
                            enemy.GoalTurns = 0;
                            //assign new goal
                            enemy.Goal = newGoal;
                            Game.logTurn?.Write(string.Format(" [Goal -> New] {0}, ActID {1}, {2}, assigned new Goal -> {3}", enemy.Name, enemy.ActID, ShowLocationCoords(enemy.LocID),
                                enemy.Goal));
                        }
                        //
                        // --- Handle all Move logic here
                        //
                        if (newGoal == ActorGoal.Move)
                        {
                            Position posOrigin = enemy.GetActorPosition();
                            List<int> listNeighbours = loc.GetNeighboursLocID();
                            int destinationLocID = 0;
                            //
                            //-- HUNT mode
                            //
                            if (huntMoveFlag == true)
                            {
                                // - Move One Node closer to Player's last known location
                                if (turnsUnknown > 3 && rnd.Next(100) < 50)
                                {
                                    Location locTarget = Game.network.GetLocation(playerLocID);
                                    if (locTarget != null)
                                    {
                                        Position posTarget = locTarget.GetPosition();
                                        List<Position> pathTemp = Game.network.GetPathAnywhere(posOrigin, posTarget);
                                        //loop path looking for the first viable location along path
                                        for (int i = 0; i < pathTemp.Count; i++)
                                        {
                                            Position posTemp = pathTemp[i];
                                            if (posTemp != null)
                                            {
                                                tempLocID = Game.map.GetMapInfo(MapLayer.LocID, posTemp.PosX, posTemp.PosY);
                                                if (tempLocID > 0)
                                                {
                                                    Game.logTurn?.Write(string.Format(" [Goal -> Move] {0}, ActID {1} -> One Node closer to Player -> {2}, LocID {3}", enemy.Name, enemy.ActID,
                                                    GetLocationName(tempLocID), tempLocID));
                                                    destinationLocID = tempLocID; break;
                                                }
                                            }
                                            else { Game.SetError(new Error(156, "Invalid Position (null) in pathTemp")); }
                                        }
                                        //error check
                                        if (destinationLocID == 0)
                                        {
                                            destinationLocID = playerLocID;
                                            Game.logTurn?.Write(string.Format(" [Goal -> Alert] {0}, ActID [1} has been assigned a default PlayerLocID [move One Node closer] as no viable node was found",
                                                enemy.Name, enemy.ActID));
                                        }
                                    }
                                    else { Game.SetError(new Error(156, "Invalid locTarget (null) Viable Node not searched for")); }
                                }
                                // - Move Directly to Player's last known location
                                else
                                {
                                    Game.logTurn?.Write(string.Format(" [Goal -> Move] {0}, ActID {1} -> Player's last known location -> {2}, LocID {3}", enemy.Name, enemy.ActID,
                                                   GetLocationName(playerLocID), playerLocID));
                                    destinationLocID = playerLocID;
                                }
                            }
                            //
                            // -- NORMAL Mode
                            //
                            else
                            {
                                // - Correct Branch
                                if (enemy.AssignedBranch == currentBranch)
                                {
                                    //Not at Capital
                                    if (enemy.LocID > 1)
                                    {
                                        List<int> tempLocList = new List<int>();
                                        //change direction of travel?
                                        bool reverseStatus = false;
                                        switch (enemy.MoveOut)
                                        {
                                            case true:
                                                //slightly higher chance of reversing outward movement in order to keep inquisitors closer to the capital
                                                if (rnd.Next(100) < 15)
                                                { reverseStatus = true; }
                                                break;
                                            case false:
                                                if (rnd.Next(100) < 10)
                                                { reverseStatus = true; }
                                                break;
                                        }
                                        if (reverseStatus == true)
                                        {
                                            Game.logTurn?.Write(string.Format(" [Goal -> Alert] {0}, ActID {1} has reversed their MoveOut status from {2} to {3}", enemy.Name, enemy.ActID, enemy.MoveOut,
                                                enemy.MoveOut == true ? "False" : "True"));
                                            if (enemy.MoveOut == true) { enemy.MoveOut = false; }
                                            else { enemy.MoveOut = true; }
                                        }
                                        enemyDistance = loc.DistanceToCapital;
                                        for (int i = 0; i < listNeighbours.Count; i++)
                                        {
                                            Location locTemp = Game.network.GetLocation(listNeighbours[i]);
                                            if (locTemp != null)
                                            {
                                                tempDistance = locTemp.DistanceToCapital;

                                                if (enemy.MoveOut == true)
                                                {
                                                    //move outwards towards capital -> select any that are further out (also check not going across a connector)
                                                    if (tempDistance > enemyDistance && locTemp.GetBranch() == enemy.AssignedBranch)
                                                    { tempLocList.Add(listNeighbours[i]); }
                                                }
                                                else
                                                {
                                                    //move inwards towards capital -> select any that are further in
                                                    if (tempDistance < enemyDistance)
                                                    { tempLocList.Add(listNeighbours[i]); }
                                                }
                                            }
                                            else
                                            { Game.SetError(new Error(156, "Invalid LocID (zero or less) [Not at Capital] in ListOfNeighbours")); }
                                        }
                                        //any viable selections?
                                        if (tempLocList.Count > 0)
                                        {
                                            //randomly select a destination
                                            destinationLocID = tempLocList[rnd.Next(0, tempLocList.Count)];
                                            Game.logTurn?.Write(string.Format(" [Goal -> Move] {0}, ActID {1} -> Move {2} -> {3}, LocID {4}", enemy.Name, enemy.ActID, enemy.MoveOut == true ? "Outwards" : "Inwards",
                                                   GetLocationName(destinationLocID), destinationLocID));
                                        }
                                        else
                                        {
                                            //else must have reached the end of a branch -> reverse move direction to prevent an endless loop
                                            Game.logTurn?.Write(string.Format(" [Goal -> Alert] {0}, ActID {1} has reversed their MoveOut status [end of the Road] from {2} to {3}", enemy.Name, enemy.ActID,
                                                enemy.MoveOut, enemy.MoveOut == true ? "False" : "True"));
                                            if (enemy.MoveOut == true) { enemy.MoveOut = false; }
                                            else { enemy.MoveOut = true; }
                                            //NOTE: destinationLocID left unassigned (default '0') so that a random selection will be made at the end.
                                        }
                                    }
                                    //At Capital
                                    else if (enemy.LocID == 1)
                                    {
                                        //Currently at the Capital -> Shouldn't get to this situation (see above)
                                        Game.logTurn?.Write(string.Format(" [Goal -> Alert] Normal Mode, {0}, ActID {1} At Capital with correct branch -> Unassigned", enemy.Name, enemy.ActID));
                                    }
                                }
                                // - Incorrect Branch
                                else if (enemy.AssignedBranch != currentBranch && currentBranch > -1)
                                {
                                    //Not at Capital
                                    if (enemy.LocID > 1)
                                    {
                                        //return to Capital
                                        destinationLocID = 1;
                                        Game.logTurn?.Write(string.Format(" [Goal -> Move] {0}, ActID {1} -> Return to Capital -> {2}, LocID {3}", enemy.Name, enemy.ActID,
                                                   GetLocationName(destinationLocID), destinationLocID));
                                    }
                                    //At Capital
                                    else if (enemy.LocID == 1)
                                    {
                                        for (int i = 0; i < listNeighbours.Count; i++)
                                        {
                                            if (listNeighbours[i] > 0)
                                            {
                                                Location locTemp = Game.network.GetLocation(listNeighbours[i]);
                                                if (locTemp != null)
                                                {
                                                    if (locTemp.GetBranch() == enemy.AssignedBranch)
                                                    {
                                                        destinationLocID = listNeighbours[i];
                                                        Game.logTurn?.Write(string.Format(" [Goal -> Move] {0}, ActID {1} -> Capital to Correct Branch -> {2}, LocID {3}", enemy.Name, enemy.ActID,
                                                        GetLocationName(destinationLocID), destinationLocID));
                                                        break;
                                                    }
                                                }
                                                else { Game.SetError(new Error(156, "Invalid Loc (null) Enemy Goal not set")); }
                                            }
                                            else
                                            { Game.SetError(new Error(156, "Invalid LocID (zero or less) [at Capital] in ListOfNeighbours")); }
                                        }
                                    }
                                }
                                else
                                { Game.SetError(new Error(156, "Invalid branch value (default of -1)")); }
                            }
                            //valid destination found ? -> otherwise assign random neighbour
                            if (destinationLocID == 0)
                            {
                                destinationLocID = listNeighbours[rnd.Next(0, listNeighbours.Count)];
                                Game.logTurn?.Write(string.Format(" [Goal -> Alert] No valid destination found for {0}, ActID {1}. Assigned Random neighbour, {2}, LocID {3}", enemy.Name, enemy.ActID,
                                    GetLocationName(destinationLocID), destinationLocID));
                            }
                            //Move enemy
                            Location locMove = Game.network.GetLocation(destinationLocID);
                            if (locMove != null)
                            {
                                Position posDestination = locMove.GetPosition();
                                //List<Position> pathToTravel = Game.network.GetPathAnywhere(posOrigin, posDestination);
                                InitiateMoveActor(enemy.ActID, posOrigin, posDestination);
                            }
                            else { Game.SetError(new Error(156, "Invalid locMove (null) Enemy isn't Moved")); }
                        }
                    }
                    else { Game.SetError(new Error(156, string.Format("Invalid playerLocID (zero or less), existing goal retained for actID {0}", enemy.ActID))); }
                }
                else { Game.SetError(new Error(156, string.Format("Invalid Enemy Location (null), for LocID {0}, Enemy ID {1}", enemy.LocID, enemy.ActID))); }
            }
            else { Game.SetError(new Error(156, "Invalid enemy input (null), existing goal retained")); }
        }


        /// <summary>
        /// checks Active Character when moving for presence of Enemy in same place
        /// <param name="charID">ActID of active character</param>
        /// <param name="pos">Current Position of active character</param>
        /// </summary>
        internal bool CheckIfFoundActive(Position pos, int charID)
        {
            int rndNum, threshold;
            bool found = false;
            int knownDM = 0; //modifier for search if active character known
            int known_revert = Game.constant.GetValue(Global.KNOWN_REVERT);
            int ai_known = Game.constant.GetValue(Global.AI_SEARCH_KNOWN);
            int ai_hide = Game.constant.GetValue(Global.AI_SEARCH_HIDE);
            int ai_move = Game.constant.GetValue(Global.AI_SEARCH_MOVE);
            int ai_search = Game.constant.GetValue(Global.AI_SEARCH_SEARCH);
            int ai_wait = Game.constant.GetValue(Global.AI_SEARCH_WAIT);
            //active characters only
            Actor actor = GetAnyActor(charID);
            if (actor != null && actor.Status != ActorStatus.Gone && actor.Status != ActorStatus.Captured)
            {
                if (actor is Active)
                {
                    Active active = actor as Active;
                    //find player in any situation, find follower only if Known
                    if (active is Player || (active is Follower && active.Known == true))
                    {
                        Game.logTurn?.Write("--- CheckIfFoundActive (World.cs)");
                        foreach (var enemy in dictEnemyActors)
                        {
                            found = false;
                            Position posEnemy = enemy.Value.GetActorPosition();
                            if (posEnemy != null && pos != null)
                            {
                                //debug
                                Game.logTurn?.Write(string.Format(" [Search -> Debug] Enemy, {0}, ID {1} at {2}:{3}, Active {4}, ID {5}, at {6}:{7}", enemy.Value.Name, enemy.Value.ActID, posEnemy.PosX, posEnemy.PosY,
                                    active.Name, active.ActID, pos.PosX, pos.PosY));
                                if (posEnemy.PosX == pos.PosX && posEnemy.PosY == pos.PosY)
                                {
                                    //in same spot
                                    Game.logTurn?.Write(string.Format(" [Search -> Alert] {0} {1}, ActID {2}, is in the same place as Active {3}, ID {4}, (loc {5}:{6})", enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID,
                                        active.Name, active.ActID, pos.PosX, pos.PosY));
                                    //only search if enemy hasn't already searched for this actor this turn
                                    if (active.CheckSearchedOnList(enemy.Value.ActID) == false)
                                    {
                                        //add DM if actor Known
                                        if (active.Known == true) { knownDM = ai_known; }
                                        rndNum = rnd.Next(100);
                                        threshold = 0;
                                        //chance varies depending on current enemy activity
                                        switch (enemy.Value.Goal)
                                        {
                                            case ActorGoal.Hide:
                                                threshold = ai_hide + knownDM;
                                                break;
                                            case ActorGoal.Move:
                                                threshold = ai_move + knownDM;
                                                break;
                                            case ActorGoal.Search:
                                                threshold = ai_search + knownDM;
                                                break;
                                            case ActorGoal.Wait:
                                                threshold = ai_wait + knownDM;
                                                break;
                                        }
                                        if (rndNum < threshold) { found = true; }
                                        Game.logTurn?.Write(string.Format(" [SEARCH -> Active] Random {0} < {1} (ai {2} + known {3}) -> {4} ", rndNum, threshold, threshold - knownDM, knownDM,
                                            rndNum < threshold ? "Success" : "Fail"));
                                        //add to list of searched to prevent same enemy making multiple searches per turn
                                        if (active.AddSearched(enemy.Value.ActID) == true)
                                        { Game.logTurn?.Write(string.Format(" [Search -> ListSearched] {0} {1}, ActID {2} Searched -> Enemy ActID {3} added", active.Title, active.Name, active.ActID, enemy.Value.ActID)); }

                                        if (found == true)
                                        {
                                            string locName = GetLocationName(pos);
                                            if (String.IsNullOrEmpty(locName) == true) { locName = string.Format("Loc {0}:{1}", pos.PosX, pos.PosY); }
                                            Game.logTurn?.Write(string.Format(" [SEARCH -> Active] {0} {1} has been Spotted by {2}, ActID {3} at loc {4}:{5} -> Activated {6}", active.Title, active.Name, enemy.Value.Name,
                                                enemy.Value.ActID, pos.PosX, pos.PosY, enemy.Value.Activated));
                                            active.Found = true;
                                            Game.logTurn?.Write(string.Format(" [Search -> ListEnemy] {0} {1}, ActID {2} as Spotted -> True and Enemy ActID {3} added", active.Title, active.Name, active.ActID, enemy.Value.ActID));
                                            //Stuff that happens when found
                                            string description = "Unknown";
                                            int locID = Game.map.GetMapInfo(MapLayer.LocID, pos.PosX, pos.PosY);
                                            int refID = Game.map.GetMapInfo(MapLayer.RefID, pos.PosX, pos.PosY);
                                            //different outcomes for Player and Followers
                                            if (active is Player)
                                            {
                                                //if unknown then becomes known
                                                if (active.Known == false)
                                                {
                                                    if (active.AddEnemy(enemy.Value.ActID, enemy.Value.Activated) == true)
                                                    {
                                                        active.Known = true; active.Revert = known_revert;
                                                        description = string.Format("{0} {1}, ActID {2}, has been Spotted by {3} {4}, ActID {5} at {6}", active.Title, active.Name, active.ActID,
                                                            enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID, locName);
                                                        Record record = new Record(description, active.ActID, locID, refID, CurrentActorIncident.Known);
                                                        SetPlayerRecord(record);
                                                        SetMessage(new Message(description, MessageType.Search));
                                                    }
                                                }
                                                else if (active.Known == true)
                                                {
                                                    if (active.CheckEnemyOnList(enemy.Value.ActID) == false)
                                                    {
                                                        //if already known then challenge/capture (But only if character hasn't already found player in the same turn -> must be another character)
                                                        if (active.AddEnemy(enemy.Value.ActID, enemy.Value.Activated) == true)
                                                        {
                                                            active.Revert = known_revert;
                                                            description = string.Format("{0} {1}, ActID {2}, has been Found by {3} {4}, ActID {5} at {6}", active.Title, active.Name, active.ActID,
                                                                    enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID, locName);
                                                            if (enemy.Value.Activated == true)
                                                            {
                                                                //only activated enemies can capture (Inquisitors ae always activated, Nemesis only if the gods are angry)
                                                                active.Capture = true;
                                                            }
                                                            Record record = new Record(description, active.ActID, locID, refID, CurrentActorIncident.Search);
                                                            SetPlayerRecord(record);
                                                            SetMessage(new Message(description, MessageType.Search));
                                                        }
                                                        else
                                                        {
                                                            //enemy has already found Player this turn
                                                            Game.logTurn?.Write(string.Format(" [Search -> Previous] {0} {1}, ActID {2} has already Found Player this turn -> Result Cancelled", enemy.Value.Title,
                                                                enemy.Value.Name, enemy.Value.ActID));
                                                        }
                                                    }

                                                }
                                            }
                                            else if (active is Follower)
                                            {
                                                //can only be captured (assumed to be Known)
                                                if (active.AddEnemy(enemy.Value.ActID, enemy.Value.Activated) == true)
                                                {

                                                    if (enemy.Value is Inquisitor)
                                                    {
                                                        active.Known = true; active.Revert = known_revert;
                                                        description = string.Format("{0} {1}, ActID {2}, has been Spotted by {3} {4}, ActID {5} at {6}", active.Title, active.Name, active.ActID,
                                                            enemy.Value.Title, enemy.Value.Name, enemy.Value.ActID, locName);
                                                        Record record = new Record(description, active.ActID, locID, refID, CurrentActorIncident.Search);
                                                        SetCurrentRecord(record);
                                                        SetMessage(new Message(description, MessageType.Search));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else { Game.logTurn?.Write(string.Format(" [Search -> Notification] {0} {1}, ActID {2} Already on List, no Search -> Enemy ActID {3}", active.Title, active.Name, active.ActID, enemy.Value.ActID)); }
                                }
                            }
                            else { Game.SetError(new Error(161, string.Format("Invalid Enemy (actID {0}) Pos (null) or Active (actID {1}) Pos (null)", enemy.Value.ActID, active.ActID))); }
                        }
                    }
                    else { Game.logTurn?.Write(string.Format(" [Search -> Notification] Invalid actor (NOT Player || NOT Follower && Known) {0}, ActID {1}", active.Name, active.ActID)); }
                }
            }
            else { Game.SetError(new Error(161, string.Format("Invalid actor (null or ActorStatus.Gone) charID \"{0}\", Status {1}", charID, actor.Status))); }
            return found;
        }

        /// <summary>
        /// checks Enemy Character when moving for presence of Active character in same place
        /// <param name="charID">ActID of Enemy character</param>
        /// <param name="pos">Current Position of Enemy character</param>
        /// </summary>
        internal bool CheckIfFoundEnemy(Position pos, int charID)
        {
            int rndNum, threshold;
            bool found = false;
            int known_revert = Game.constant.GetValue(Global.KNOWN_REVERT);
            int ai_known = Game.constant.GetValue(Global.AI_SEARCH_KNOWN);
            int ai_hide = Game.constant.GetValue(Global.AI_SEARCH_HIDE);
            int ai_move = Game.constant.GetValue(Global.AI_SEARCH_MOVE);
            int ai_search = Game.constant.GetValue(Global.AI_SEARCH_SEARCH);
            int ai_wait = Game.constant.GetValue(Global.AI_SEARCH_WAIT);
            int knownDM = 0; //modifier for search if player known
            //get enemy
            Actor actor = GetAnyActor(charID);
            if (actor != null && actor.Status != ActorStatus.Gone)
            {
                if (actor is Enemy)
                {
                    Enemy enemy = actor as Enemy;
                    Game.logTurn?.Write("--- CheckIfFoundEnemy (World.cs)");
                    //loop Active Actors and check if in same position as enemy
                    foreach (var active in dictActiveActors)
                    {
                        found = false;
                        Position posActive = active.Value.GetActorPosition();
                        if (posActive != null && pos != null)
                        {
                            //find player in any situation, find follower only if Known
                            if (active.Value is Player && active.Value.Status != ActorStatus.Captured || (active.Value is Follower && active.Value.Known == true))
                            {
                                //debug
                                Game.logTurn?.Write(string.Format(" [Search -> Debug] Active {0}, ID {1} at {2}:{3}, Enemy at {4}:{5} ({6}, ID {7}", active.Value.Name, active.Value.ActID,
                                    posActive.PosX, posActive.PosY, pos.PosX, pos.PosY, enemy.Name, enemy.ActID));
                                if (posActive.PosX == pos.PosX && posActive.PosY == pos.PosY)
                                {
                                    //in same spot
                                    Game.logTurn?.Write(string.Format(" [Search -> Alert] {0} {1}, ActID {2}, is in the same place as the Enemy, loc {3}:{4} ({5}, ID {6})", active.Value.Title, active.Value.Name,
                                        active.Value.ActID, pos.PosX, pos.PosY, enemy.Name, enemy.ActID));
                                    //only search if enemy hasn't already searched for this actor this turn
                                    if (active.Value.CheckSearchedOnList(enemy.ActID) == false)
                                    {
                                        //figure out if spotted and handle disguise and safe house star reduction
                                        if (active.Value.Known == true) { knownDM = ai_known; }
                                        rndNum = rnd.Next(100);
                                        threshold = 0;
                                        //chance depends on enemies current activity
                                        switch (enemy.Goal)
                                        {
                                            case ActorGoal.Hide:
                                                threshold = ai_hide + knownDM;
                                                break;
                                            case ActorGoal.Move:
                                                threshold = ai_move + knownDM;
                                                break;
                                            case ActorGoal.Search:
                                                threshold = ai_search + knownDM;
                                                break;
                                            case ActorGoal.Wait:
                                                threshold = ai_wait + knownDM;
                                                break;
                                        }
                                        if (rndNum < threshold)
                                        { found = true; }
                                        Game.logTurn?.Write(string.Format(" [SEARCH -> Active] Random {0} < {1} (ai {2} + known {3}) -> {4} ", rndNum, threshold, threshold - knownDM, knownDM,
                                            rndNum < threshold ? "Success" : "Fail"));
                                        //add to list of Searched to prevent same enemy making multiple search attempts on this actor per turn
                                        if (active.Value.AddSearched(enemy.ActID) == true)
                                        { Game.logTurn?.Write(string.Format(" [Search -> ListSearched] {0} {1}, ActID {2} Searched -> Enemy ActID {3} added", active.Value.Title, active.Value.Name, active.Value.ActID, enemy.ActID)); }

                                        if (found == true)
                                        {
                                            string locName = GetLocationName(pos);
                                            if (locName.Equals("Unknown") == true) { locName = string.Format("Loc {0}:{1}", pos.PosX, pos.PosY); } //travelling
                                            if (String.IsNullOrEmpty(locName) == true) { locName = string.Format("Loc {0}:{1}", pos.PosX, pos.PosY); }
                                            Game.logTurn?.Write(string.Format(" [SEARCH -> Enemy] {0} {1} has been Spotted by {2}, ActID {3} at {4} -> Activated {5}", active.Value.Title, active.Value.Name,
                                                enemy.Name, enemy.ActID, locName, enemy.Activated));
                                            active.Value.Found = true;
                                            Game.logTurn?.Write(string.Format(" [Search -> ListEnemies] {0} {1}, ActID {2} is Found -> True and Enemy ActID {3} added", active.Value.Title, active.Value.Name, active.Value.ActID, enemy.ActID));
                                            //Stuff that happens when found
                                            string description = "Unknown";
                                            int locID = Game.map.GetMapInfo(MapLayer.LocID, pos.PosX, pos.PosY);
                                            int refID = Game.map.GetMapInfo(MapLayer.RefID, pos.PosX, pos.PosY);
                                            if (active.Value is Player)
                                            {
                                                //if unknown then becomes known
                                                if (active.Value.Known == false)
                                                {
                                                    if (active.Value.AddEnemy(enemy.ActID, enemy.Activated) == true)
                                                    {
                                                        active.Value.Known = true; active.Value.Revert = known_revert;
                                                        description = string.Format("{0} {1}, ActID {2}, has been Spotted by {3} {4}, ActID {5} at {6}", active.Value.Title, active.Value.Name,
                                                            active.Value.ActID, enemy.Title, enemy.Name, enemy.ActID, locName);
                                                        Record record = new Record(description, active.Value.ActID, locID, refID, CurrentActorIncident.Known);
                                                        SetPlayerRecord(record);
                                                        SetMessage(new Message(description, MessageType.Search));
                                                    }
                                                }
                                                else if (active.Value.Known == true)
                                                {
                                                    if (active.Value.CheckEnemyOnList(enemy.ActID) == false)
                                                    {
                                                        //if already known then challenge/capture (But only if character hasn't already found player in the same turn -> must be another character)
                                                        if (active.Value.AddEnemy(enemy.ActID, enemy.Activated) == true)
                                                        {
                                                            active.Value.Revert = known_revert;
                                                            description = string.Format("{0} {1}, ActID {2}, has been Found by {3} {4}, ActID {5} at {6}", active.Value.Title, active.Value.Name,
                                                                active.Value.ActID, enemy.Title, enemy.Name, enemy.ActID, locName);
                                                            if (enemy.Activated == true)
                                                            {
                                                                //only activated enemies can capture (Inquisitors are always activated, Nemesis only when gods are angry)
                                                                active.Value.Capture = true;
                                                            }
                                                            Record record = new Record(description, active.Value.ActID, locID, refID, CurrentActorIncident.Search);
                                                            SetPlayerRecord(record);
                                                            SetMessage(new Message(description, MessageType.Search));
                                                        }
                                                    }
                                                    else
                                                    {
                                                        //enemy has already found player this turn
                                                        Game.logTurn?.Write(string.Format(" [Search -> Previous] {0} {1}, ActID {2} has previously Found the Player -> Result Cancelled", enemy.Title, enemy.Name,
                                                            enemy.ActID));
                                                    }
                                                }

                                            }
                                            else if (active.Value is Follower)
                                            {
                                                //can only be captured (assumed to be Known)
                                                if (active.Value.AddEnemy(enemy.ActID, enemy.Activated) == true)
                                                {
                                                    if (enemy is Inquisitor)
                                                    {
                                                        active.Value.Known = true; active.Value.Revert = known_revert; active.Value.Capture = true;
                                                        description = string.Format("{0} {1}, ActID {2}, has been Spotted by {3} {4}, ActID {5} at {6}", active.Value.Title, active.Value.Name, active.Value.ActID,
                                                            enemy.Title, enemy.Name, enemy.ActID, locName);
                                                        Record record = new Record(description, active.Value.ActID, locID, refID, CurrentActorIncident.Search);
                                                        SetCurrentRecord(record);
                                                        SetMessage(new Message(description, MessageType.Search));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else { Game.logTurn?.Write(string.Format(" [Search -> Notification] {0} {1}, ActID {2} already on List, not Searched -> Enemy ActID {3}", active.Value.Title, active.Value.Name, active.Value.ActID, enemy.ActID)); }
                                }
                            }
                        }
                        else { Game.SetError(new Error(161, string.Format("Invalid Enemy (actID {0}) Pos (null) or Active (actID {1}) Pos (null)", enemy.ActID, active.Value.ActID))); }
                    }
                }
                else { Game.SetError(new Error(161, string.Format("Invalid actor (NOT Enemy) charID \"{0}\"", charID))); }
            }
            else { Game.SetError(new Error(161, string.Format("Invalid Enemy actor (null or ActorStatus.Gone) charID \"{0}\", Status {1}", charID, actor.Status))); }
            return found;
        }

        /// <summary>
        /// Checks Active actors who haven't moved to see if they have been found
        /// </summary>
        private void CheckStationaryActiveActors()
        {
            Game.logTurn?.Write("--- CheckStationaryActiveActors (World.cs)");
            //loop active actors 
            foreach (var actor in dictActiveActors)
            {
                if (actor.Value.Status == ActorStatus.AtLocation)
                {
                    Game.logTurn?.Write(string.Format(" [Search -> Stationary] {0} {1}, ActID {2} is AtLocation", actor.Value.Title, actor.Value.Name, actor.Value.ActID));
                    Position pos = actor.Value.GetActorPosition();
                    if (pos != null)
                    {
                        if (actor.Value is Player)
                        { CheckIfFoundActive(pos, actor.Value.ActID); }
                        else if (actor.Value is Follower)
                        {
                            //must be a Follower
                            if (actor.Value.Known == true)
                            { CheckIfFoundActive(pos, actor.Value.ActID); }
                        }
                        else { Game.SetError(new Error(162, string.Format("Unknown Actor type for \"{0} {1}\" ID {2}", actor.Value.Title, actor.Value.Name, actor.Value.ActID))); }
                    }
                }
                else { Game.logTurn?.Write(string.Format(" [Search -> Stationary] {0} {1}, ActID {2} is {3}", actor.Value.Title, actor.Value.Name, actor.Value.ActID, actor.Value.Status)); }
            }
        }

        /// <summary>
        /// Analyses map and sets up the desired part of the AI array (# enemies at capital and # enemies to allocate to each branch)
        /// </summary>
        private void InitialiseAI()
        {
            Game.logStart?.Write("--- InitialiseAI (World.cs)");
            int connectorBonus = Game.constant.GetValue(Global.AI_CONNECTOR);
            //work out branch priorities
            int numBranches = Game.network.GetNumBranches();
            int numLocs = Game.network.GetNumLocations() - 1; //ignore capital
            int[] arrayTemp = new int[5]; // (1 to 4 branches with 0 being Capital)
            //allocate # loc's to each branch
            int tempNumLocs = 0;
            for (int i = 1; i < arrayTemp.Length; i++)
            { arrayTemp[i] = Game.network.GetNumLocsByBranch(i); tempNumLocs += arrayTemp[i]; }
            //tallies match?
            if (tempNumLocs != numLocs)
            { Game.SetError(new Error(165, string.Format("Loc's don't tally (tempNumLocs (GetNumLocsByBranch) {0} numLocs (GetNumLocations) {1})", tempNumLocs, numLocs))); }
            //allow for connectors (provide more flexibility and make a branch more valuable to the enemy if present)
            int adjustedNumLocs = 0;
            for (int i = 1; i < arrayTemp.Length; i++)
            {
                if (Game.network.GetBranchConnectorStatus(i) == true)
                { arrayTemp[i] += connectorBonus; }
                adjustedNumLocs += arrayTemp[i];
            }
            //work out how many enemies should stay in the captial (normal operations)
            int totalEnemies = Game.constant.GetValue(Global.INQUISITORS);
            int enemiesInCapital = (int)Math.Round((double)(totalEnemies * Game.constant.GetValue(Global.AI_CAPITAL)) / 100);
            int remainingEnemies = totalEnemies - enemiesInCapital;
            //boundary check
            if (remainingEnemies == 0)
            {
                Game.SetError(new Error(165, "Invalid Remaining Enemies (Zero)"));
                remainingEnemies = 1; enemiesInCapital -= 1; enemiesInCapital = Math.Max(enemiesInCapital, 1);
            }
            arrayAI[1, 0] = enemiesInCapital;
            //assign the desired number of enemies to each relevant branch
            int percent, branchEnemies;
            int poolOfEnemies = remainingEnemies;
            for (int i = 1; i < arrayTemp.Length; i++)
            {
                percent = (int)Math.Round((double)(arrayTemp[i] * 100) / adjustedNumLocs);
                branchEnemies = (int)Math.Round((double)(remainingEnemies * percent) / 100);
                //check we aren't over allocating
                if (branchEnemies > poolOfEnemies)
                {
                    if (poolOfEnemies == 0)
                    {
                        if (enemiesInCapital > 0)
                        {
                            //move an enemy from Capital duty to branch duty
                            arrayAI[1, 0]--;
                        }
                        else { branchEnemies = 0; }
                    }
                    else { branchEnemies = poolOfEnemies; }
                }
                arrayAI[1, i] = branchEnemies;
                //track total number of allocated enemies
                poolOfEnemies -= branchEnemies;
            }
            //any unallocated actors get placed in the capital
            if (poolOfEnemies > 0)
            { arrayAI[1, 0] += poolOfEnemies; }
            //copy finalised data from range 1 to range 2 (temp data used for assigning enemies in InitialiseEnemyActors)
            for (int i = 0; i <= arrayAI.GetUpperBound(1); i++)
            { arrayAI[2, i] = arrayAI[1, i]; }
            //display arrayAI

            for (int i = 0; i <= arrayAI.GetUpperBound(1); i++)
            { Game.logStart?.Write(string.Format(" {0} {1} -> Current {2} -> Desired {3} -> adjusted Loc's {4}", i > 0 ? "Branch " : "Capital", i, arrayAI[0, i], arrayAI[1, i],
                arrayTemp[i])); }
        }

        /// <summary>
        /// tracks active and enemy actors at the start of each turn
        /// </summary>
        private void UpdateBloodHound()
        {
            BloodHound bloodhound = new BloodHound();
            //clear out temp lists
            listTempActiveActors.Clear();
            listTempEnemyActors.Clear();
            //active actors
            foreach (var active in dictActiveActors)
            {
                ActorSpy activeSpy = new ActorSpy(active.Value.ActID, active.Value.GetActorPosition(), active.Value.Status, active.Value.Known);
                listTempActiveActors.Add(activeSpy);
            }
            bloodhound.SetActiveActors(listTempActiveActors);
            //enemy actors
            foreach (var enemy in dictEnemyActors)
            {
                ActorSpy enemySpy = new ActorSpy(enemy.Value.ActID, enemy.Value.GetActorPosition(), enemy.Value.Status, enemy.Value.Known, enemy.Value.Goal, enemy.Value.HuntMode);
                listTempEnemyActors.Add(enemySpy);
            }
            bloodhound.SetEnemyActors(listTempEnemyActors);
            //add to dictionary
            try
            { dictBloodHound.Add(Game.gameTurn, bloodhound); }
            catch (ArgumentException)
            { Game.SetError(new Error(171, string.Format("Invalid gameTurn \"{0}\", (duplicate Entry) -> Bloodhound entry Not added", Game.gameTurn))); }
        }

        /// <summary>
        /// handles logistics when Player is captured
        /// </summary>
        /// <param name="actID"></param>
        /// <param name="enemyID">actID of enemy who captured the player</param>
        public void SetPlayerCaptured(int enemyID)
        {
            Game.logTurn?.Write("--- SetPlayerCaptured (World.cs)");
            string description, dungeonLoc;
            Player player = (Player)GetActiveActor(1);
            if (player != null)
            {
                //player travelling when captured?
                if (player.Status == ActorStatus.Travelling)
                {
                    //loop list Move Objects and delete the Players
                    for (int i = 0; i < listMoveObjects.Count; i++)
                    {
                        Move moveObject = listMoveObjects[i];
                        if (moveObject.PlayerInParty == true)
                        {
                            Game.logTurn?.Write(string.Format(" [Capture -> Move Object] {0} {1}'s journey to {2} has been deleted", player.Title, player.Name, moveObject.GetDestination()));
                            listMoveObjects.RemoveAt(i);
                            break;
                        }
                    }
                }
                //change status
                player.Status = ActorStatus.Captured;
                player.DeathTimer = 20;
                Enemy enemy = GetEnemyActor(enemyID);
                if (enemy != null)
                {
                    if (enemy is Inquisitor)
                    {
                        //assign nearest major House / capital locID as the place where the player is held
                        int heldLocID = 0;
                        int tempRefID = 0;
                        int refID = 0;
                        if (player.LocID == 1) { tempRefID = 9999; Game.logTurn?.Write(" [Captured] dungeon -> Capital"); }
                        else
                        {
                            Location loc = Game.network.GetLocation(player.LocID);
                            if (loc != null)
                            {
                                //not at Capital -> At Major House?
                                House house = GetHouse(loc.RefID);
                                if (house != null)
                                {
                                    if ((house is MajorHouse) == false)
                                    {
                                        //find nearest Major house/Capital moving Inwards
                                        List<Route> routeToCapital = loc.GetRouteToCapital();
                                        List<Position> pathToCapital = routeToCapital[0].GetPath();
                                        int distIn = 0; int refIn = 0;
                                        for (int i = 0; i < pathToCapital.Count; i++)
                                        {
                                            Position pos = pathToCapital[i];
                                            if (pos != null)
                                            {
                                                refID = Game.map.GetMapInfo(MapLayer.RefID, pos.PosX, pos.PosY);
                                                if (refID > 0)
                                                {
                                                    if (refID == 9999 || refID < 100)
                                                    { refIn = refID; distIn = i; break; }
                                                }
                                            }
                                        }
                                        //find nearest Major house moving Outwards
                                        int branch = loc.GetBranch();
                                        List<Location> listBranchLocs = Game.network.GetBranchLocs(branch);
                                        int distOut = 0; int refOut = 0;
                                        int playerLocIndex = -1;
                                        if (listBranchLocs != null && listBranchLocs.Count > 0)
                                        {
                                            //loop through list and find player's current location
                                            for (int i = 0; i < listBranchLocs.Count; i++)
                                            {
                                                if (listBranchLocs[i].LocationID == player.LocID)
                                                { playerLocIndex = i; break; }
                                            }
                                            //found Player's loc in the list?
                                            if (playerLocIndex > -1)
                                            {
                                                //loop through branch list starting from player's current loc, moving outwards (redundantly start at player's current loc to avoid possible index overshoot)
                                                for (int i = playerLocIndex; i < listBranchLocs.Count; i++)
                                                {
                                                    House tempHouse = GetHouse(listBranchLocs[i].RefID);
                                                    if (tempHouse is MajorHouse)
                                                    {
                                                        //found the first Major House along
                                                        distOut = listBranchLocs[i].DistanceToCapital - loc.DistanceToCapital;
                                                        refOut = listBranchLocs[i].RefID;
                                                        //need to check the actual distance as it could be on a seperate branch and be much further than initially assumed
                                                        List<Route> route = Game.network.GetRouteAnywhere(loc.GetPosition(), listBranchLocs[i].GetPosition());
                                                        int checkDistance = Game.network.GetDistance(route);
                                                        if (checkDistance > distOut)
                                                        {
                                                            Game.logTurn?.Write(string.Format(" [Captured -> CheckDistance] distOut increased from {0} to {1}", distOut, checkDistance));
                                                            distOut = checkDistance;
                                                        }
                                                        break;
                                                    }
                                                }
                                            }
                                            else { Game.SetError(new Error(174, "Player's Loc not found in search through listBranchLocs.Search outwards Cancelled")); }
                                        }
                                        else { Game.SetError(new Error(174, "Invalid listBranchLocs (Null or Zero Count) Search outwards cancelled")); }
                                        //Compare in and out and find closest, favouring inwards (if equal distance)
                                        if (refIn > 0 && refOut == 0) { tempRefID = refIn; Game.logTurn?.Write(" [Captured] dungeon -> In (no out)"); }
                                        else if (refOut > 0 && refIn == 0) { tempRefID = refOut; Game.logTurn?.Write(" [Captured] dungeon -> Out (no in)"); }
                                        else if (distIn <= distOut) { tempRefID = refIn; Game.logTurn?.Write(" [Captured] dungeon -> In (distance <= out)"); }
                                        else if (distIn > distOut) { tempRefID = refOut; Game.logTurn?.Write(" [Captured] dungeon -> Out (distance < in)"); }
                                        else
                                        {
                                            Game.SetError(new Error(174, string.Format("Unable to get a valid dungeon loc, refIn -> {0} distIn -> {1} refOut -> {2} distOut -> {3}, default to Capital",
                                            refIn, distIn, refOut, distOut)));
                                        }
                                        Game.logTurn?.Write(string.Format(" [Captured -> Debug] refIn -> {0} distIn -> {1} refOut -> {2} distOut -> {3} tempRefID -> {4}",
                                            refIn, distIn, refOut, distOut, tempRefID));
                                    }
                                    else { Game.logTurn?.Write(" [Captured] Major House dungeon"); }
                                }
                                else { Game.SetError(new Error(174, string.Format("Invalid House returned (null) from player.LocID \"{0}\"", player.LocID))); }
                            }
                            else { Game.SetError(new Error(174, string.Format("Invalid Location returned (null) from player.LocID \"{0}\"", player.LocID))); }
                        }
                        //found a dungeon?
                        if (tempRefID > 0)
                        { heldLocID = GetLocID(tempRefID); }
                        else { Game.SetError(new Error(174, "Unable to find a suitable location for Incarceration -> Default to KingsKeep")); heldLocID = 1; }
                        //update Player LocID (dungeon), set Known to true (should be already)
                        player.LocID = heldLocID;
                        player.Known = true;
                        dungeonLoc = GetLocationName(heldLocID);
                        //Player loses any items they possess (needs to be a reverse loop as you're deleting as you go
                        if (player.CheckItems() == true)
                        {
                            int possID;
                            List<int> tempItems = player.GetItems();
                            for (int k = tempItems.Count - 1; k >= 0; k--)
                            {
                                possID = tempItems[k];
                                if (player.RemoveItem(possID) == true)
                                {
                                    Item item = GetItem(possID);
                                    //admin
                                    description = string.Format("ItemID {0}, {1}, has been confiscated by the {2} Dungeon Master", item.ItemID, item.Description, dungeonLoc);
                                    SetMessage(new Message(description, MessageType.Incarceration));
                                    SetPlayerRecord(new Record(description, player.ActID, player.LocID, tempRefID, CurrentActorIncident.Challenge));
                                }
                            }
                        }
                        //administration
                        description = string.Format("{0} has been Captured by {1} {2}, ActID {3} and is to be held at {4}", player.Name, enemy.Title, enemy.Name, enemy.ActID, dungeonLoc);
                        SetMessage(new Message(description, MessageType.Search));
                        SetPlayerRecord(new Record(description, player.ActID, player.LocID, tempRefID, CurrentActorIncident.Search));
                        SetCurrentRecord(new Record(description, enemy.ActID, player.LocID, tempRefID, CurrentActorIncident.Search));
                    }
                    else if (enemy is Nemesis)
                    {
                        //Nemsis capturing Player logic goes here -> TODO
                    }
                }
                else { Game.SetError(new Error(174, "Invalid Enemy (null)")); }
            }
            else { Game.SetError(new Error(174, "Invalid Player (null)")); }
        }

        /// <summary>
        /// seeds procgen world with all the interesting stuff
        /// </summary>
        private void InitialiseWorldDevelopment()
        {
            Game.logStart?.Write("--- InitialiseWorldDevelopment (World.cs)");
            //Placeholder -> List of all Passive Items
            IEnumerable<Item> listItems =
                from items in dictPossessions.Values.OfType<Item>()
                where items.ItemType == PossItemType.Passive
                select items;
            List<Item> listPassiveItems = listItems.ToList();
            //get list of live Passive actors
            IEnumerable<Passive> listActors =
                from actors in dictPassiveActors
                where actors.Value.Status == ActorStatus.AtLocation && !(actors.Value is Special)
                select actors.Value;
            List<Passive> listPassiveActors = listActors.ToList();

            int rndIndex;
            //assign each passive item to a random actor
            for (int i = 0; i < listPassiveItems.Count; i++)
            {
                Item item = listPassiveItems[i];
                rndIndex = rnd.Next(listPassiveActors.Count);
                Passive passive = listPassiveActors[rndIndex];
                passive.AddItem(item.PossID);
                Game.logStart?.Write(string.Format("ItemID {0}, \"{1}\", given to {2} {3}, ActID {4}, at {5} {6}", item.ItemID, item.Description, passive.Title, passive.Name, passive.ActID,
                    GetLocationName(passive.LocID), ShowLocationCoords(passive.LocID)));
                listPassiveActors.RemoveAt(rndIndex);
            }

        }

        /// <summary>
        /// Set up a notification message (straight message, no user input). Will automatically add or append where necessary. Snippets should be pre-formatted
        /// </summary>
        /// <param name="notificationList"></param>
        public void SetNotification(List<Snippet> notificationList)
        {
            if (notificationList != null)
            {
                //take a list of snippets and set up ready to go. Might need to switch to special mode.
                if (notificationList.Count > 0)
                {
                    List<Snippet> eventList = new List<Snippet>();
                    RLColor backColor = Color._background1;
                    if (Game.infoChannel.GetListCount(ConsoleDisplay.Event) == 0)
                    {
                        //no existing records, create header
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("Hear Yea, Hear Yea, Hear Yea!", RLColor.Blue, backColor));
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                        eventList.Add(new Snippet(""));
                    }
                    //add new records
                    eventList.AddRange(notificationList);
                    Game.infoChannel.SetInfoList(eventList, ConsoleDisplay.Event);
                    Game._specialMode = SpecialMode.Notification;
                }
                else { Game.SetError(new Error(223, "Invalid notificationList input (no records)")); }
            }
            else { Game.SetError(new Error(223, "Invalid notificationList input (null)")); }
        }

        /// <summary>
        /// Set up a confirmation message (message with Yes or No user input). Snippets should be pre-formatted. No appending takes place, one-shot only
        /// </summary>
        /// <param name="confirmationList"></param>
        public void SetConfirmation(List<Snippet> confirmationList)
        {
            if (confirmationList != null)
            {
                //take a list of snippets and set up ready to go. Might need to switch to special mode.
                if (confirmationList.Count > 0)
                {
                    List<Snippet> eventList = new List<Snippet>();
                    RLColor backColor = Color._background1;
                    //add new records
                    eventList.AddRange(confirmationList);
                    Game.infoChannel.ClearConsole(ConsoleDisplay.Event);
                    Game.infoChannel.SetInfoList(eventList, ConsoleDisplay.Event);
                    Game._specialMode = SpecialMode.Confirm;
                }
                else { Game.SetError(new Error(225, "Invalid confirmationList input (no records)")); }
            }
            else { Game.SetError(new Error(225, "Invalid confirmationList input (null)")); }
        }

        /// <summary>
        /// Updates world events and triggers a Notification message
        /// </summary>
        /// <returns></returns>
        private bool UpdateWorldStatus()
        {
            bool notificationStatus = false;
            List<Snippet> eventList = new List<Snippet>();
            RLColor foreColor = RLColor.Black;
            RLColor backColor = Color._background1;
            Active player = GetActiveActor(1);
            if (player != null)
            {
                switch (player.Status)
                {
                    case ActorStatus.AtLocation:
                        //debug
                        eventList.Add(new Snippet("Blight has hit wheat crops at The Twins. Food shortages loom.", foreColor, backColor));
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("Rumour that the King has the pox and that he is going mad", foreColor, backColor));
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                        eventList.Add(new Snippet(""));
                        break;
                    case ActorStatus.Travelling:
                        eventList.Add(new Snippet("A passing Merchant tells of trouble in the Court of Casterly Rock", foreColor, backColor));
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                        eventList.Add(new Snippet(""));
                        break;
                    case ActorStatus.AtSea:
                        eventList.Add(new Snippet("The Captain tells tales of war in the far-off-lands", foreColor, backColor));
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                        eventList.Add(new Snippet(""));
                        break;
                    case ActorStatus.Captured:
                        eventList.Add(new Snippet("You overhear a guard arguing with another prison about food shortages in the Castle", foreColor, backColor));
                        eventList.Add(new Snippet(""));
                        eventList.Add(new Snippet("- 0 -", RLColor.Gray, backColor));
                        eventList.Add(new Snippet(""));
                        break;
                }
                //any world message to display?
                if (eventList.Count > 0)
                {
                    notificationStatus = true;
                    SetNotification(eventList);
                }
            }
            else { Game.SetError(new Error(224, "Invalid player (null)")); }
            return notificationStatus;
        }

        //new Methods above here
    }
}